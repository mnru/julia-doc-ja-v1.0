<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>制御フロー · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125166476-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">始めよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li class="current"><a class="toctext" href="control-flow.html">制御フロー</a><ul class="internal"><li><a class="toctext" href="#man-compound-expressions-1">複合式</a></li><li><a class="toctext" href="#man-conditional-evaluation-1">条件評価</a></li><li><a class="toctext" href="#短絡評価-1">短絡評価</a></li><li><a class="toctext" href="#man-loops-1">反復評価：ループ</a></li><li><a class="toctext" href="#例外処理-1">例外処理</a></li><li><a class="toctext" href="#man-tasks-1">タスク (別名　コルーチン)</a></li></ul></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">コンストラクタ</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="control-flow.html">制御フロー</a></li></ul><a class="edit-page" href="https://github.com/mnru/julia-doc-ja-v1.0-source/blob/master/src/manual/control-flow.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>制御フロー</span><a class="fa fa-bars" href="#"></a></div></header><p>`<a href="# Control Flow"></a></p><h1><a class="nav-anchor" id="制御フロー-1" href="#制御フロー-1">制御フロー</a></h1><!--
Julia provides a variety of control flow constructs:

  * [Compound Expressions](@ref man-compound-expressions): `begin` and `(;)`.
  * [Conditional Evaluation](@ref man-conditional-evaluation): `if`-`elseif`-`else` and `?:` (ternary operator).
  * [Short-Circuit Evaluation](@ref): `&&`, `||` and chained comparisons.
  * [Repeated Evaluation: Loops](@ref man-loops): `while` and `for`.
  * [Exception Handling](@ref): `try`-`catch`, [`error`](@ref) and [`throw`](@ref).
  * [Tasks (aka Coroutines)](@ref man-tasks): [`yieldto`](@ref).
--><p>Juliaには様々な制御フローがあります。</p><ul><li><a href="control-flow.html#man-compound-expressions-1">複合式</a>: <code>begin</code>と <code>(;)</code></li><li><a href="control-flow.html#man-conditional-evaluation-1">条件評価</a>: <code>if</code>-<code>elseif</code>-<code>else</code> と <code>?:</code> (三項演算子)</li><li><a href="control-flow.html#短絡評価-1">短絡評価</a>: <code>&amp;&amp;</code>, <code>||</code> と　比較の連鎖</li><li><a href="control-flow.html#man-loops-1">反復評価：ループ</a>: <code>while</code> と <code>for</code>.</li><li><a href="control-flow.html#例外処理-1">例外処理</a>: <code>try</code>-<code>catch</code>, <a href="../base/base.html#Base.error"><code>error</code></a> と <a href="../base/base.html#Core.throw"><code>throw</code></a>.</li><li><a href="control-flow.html#man-tasks-1">タスク (別名コルーチン)</a>: <a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>.</li></ul><!--
The first five control flow mechanisms are standard to high-level programming languages. [`Task`](@ref)s
are not so standard: they provide non-local control flow, making it possible to switch between
temporarily-suspended computations. This is a powerful construct: both exception handling and
cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no
direct usage of tasks, but certain problems can be solved much more easily by using tasks.
--><p>最初の５つの制御フローのしくみは高水準のプログラム言語に標準的なものです。 タスクはそれほど標準的ではありませんが、非ローカルの制御フローで一時的に中断した計算を切り替える事ができます。 これは強力で、例外処理や協調的マルチタスクは、Juliaでは、タスクを使って実装されています。 日々のプログラムでタスクを直接使うわけではないですが、ある種のプログラムの問題ではタスクを使うと簡単に解決できます。</p><p>`<a href="## [Compound Expressions](@id man-compound-expressions)"></a></p><h2><a class="nav-anchor" id="man-compound-expressions-1" href="#man-compound-expressions-1">複合式</a></h2><!--
Sometimes it is convenient to have a single expression which evaluates several subexpressions
in order, returning the value of the last subexpression as its value. There are two Julia constructs
that accomplish this: `begin` blocks and `(;)` chains. The value of both compound expression constructs
is that of the last subexpression. Here's an example of a `begin` block:
--><p>単一の式で、何個かの部分式を順に評価し、最後の部分式の値をその式の値として返す、といったことができると便利なことが時々あります。 Juliaにはこれを達成する２つの構文があります。<code>begin</code>ブロックとセミコロン<code>(;)</code>連鎖です。  共に複合式の値は、最後の部分式の値です。 ここに<code>begin</code>ブロックの例を挙げます。</p><pre><code class="language-julia-repl">julia&gt; z = begin
           x = 1
           y = 2
           x + y
       end
3</code></pre><!--
Since these are fairly small, simple expressions, they could easily be placed onto a single line,
which is where the `(;)` chain syntax comes in handy:
--><p>これはかなり小さな単一式なので、簡単にセミコロン<code>(;)</code>連鎖の構文を使って一行にまとめることができます。</p><pre><code class="language-julia-repl">julia&gt; z = (x = 1; y = 2; x + y)
3</code></pre><!--
This syntax is particularly useful with the terse single-line function definition form introduced
in [Functions](@ref). Although it is typical, there is no requirement that `begin` blocks be multiline
or that `(;)` chains be single-line:
--><p>この構文は、特に<a href="manual/@ref">関数</a>で紹介した、簡潔な１行での関数の定義に役立ちます。 <code>begin</code>ブロックは複数行で、セミコロン<code>(;)</code>連鎖は１行で使うのが普通ですが、必ずしもこれに従う必要はありません。</p><pre><code class="language-julia-repl">julia&gt; begin x = 1; y = 2; x + y end
3

julia&gt; (x = 1;
        y = 2;
        x + y)
3</code></pre><p>`<a href="## [Conditional Evaluation](@id man-conditional-evaluation)"></a></p><h2><a class="nav-anchor" id="man-conditional-evaluation-1" href="#man-conditional-evaluation-1">条件評価</a></h2><!--
Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the
value of a boolean expression. Here is the anatomy of the `if`-`elseif`-`else` conditional syntax:
--><p>条件評価を使うと、コードの一部を評価するかどうかを、ブール式の値によって決めることができます。 ここで<code>if</code>-<code>elseif</code>-<code>else</code>の条件構文を解析してみます。</p><pre><code class="language-julia">if x &lt; y
    println(&quot;x is less than y&quot;)
elseif x &gt; y
    println(&quot;x is greater than y&quot;)
else
    println(&quot;x is equal to y&quot;)
end</code></pre><!--
If the condition expression `x < y` is `true`, then the corresponding block is evaluated; otherwise
the condition expression `x > y` is evaluated, and if it is `true`, the corresponding block is
evaluated; if neither expression is true, the `else` block is evaluated. Here it is in action:
--><p>条件式<code>x &lt; y</code>が<code>true</code>のとき、対応するブロックが評価されます。 これが成り立たない時は、<code>x &gt; y</code>が評価されて、これが<code>true</code>のときに、対応するブロックが評価されます。 どちらの式も真ではない時、<code>else</code>ブロックが評価されます。 実際に動作させてみると、</p><pre><code class="language-julia-repl">julia&gt; function test(x, y)
           if x &lt; y
               println(&quot;x is less than y&quot;)
           elseif x &gt; y
               println(&quot;x is greater than y&quot;)
           else
               println(&quot;x is equal to y&quot;)
           end
       end
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</code></pre><!--
The `elseif` and `else` blocks are optional, and as many `elseif` blocks as desired can be used.
The condition expressions in the `if`-`elseif`-`else` construct are evaluated until the first
one evaluates to `true`, after which the associated block is evaluated, and no further condition
expressions or blocks are evaluated.
--><p><code>elseif</code>と<code>else</code>のブロックは省略可能で、<code>elseif</code>ブロックは好きな数だけ使うことができます。 <code>if</code>-<code>elseif</code>-<code>else</code>構文の条件式は、初めて<code>true</code>に評価されるものが出てくるまで続き、あとはその真の条件式に対応するブロックが評価され、 さらに条件式やブロックが評価されることはありません。</p><!--
`if` blocks are "leaky", i.e. they do not introduce a local scope. This means that new variables
defined inside the `if` clauses can be used after the `if` block, even if they weren't defined
before. So, we could have defined the `test` function above as
--><p><code>if</code>ブロックには、&quot;漏れ&quot;があります。 つまり、ローカルスコープを採用していません。 これは、<code>if</code>節の中で定義した新しい変数は、<code>if</code>句の後ろで、たとえ<code>if</code>文の前に定義がないときでさえ、利用できることを意味します。 そのため、上述の<code>test</code>関数を以下のようにも定義できるのです。</p><pre><code class="language-julia-repl">julia&gt; function test(x,y)
           if x &lt; y
               relation = &quot;less than&quot;
           elseif x == y
               relation = &quot;equal to&quot;
           else
               relation = &quot;greater than&quot;
           end
           println(&quot;x is &quot;, relation, &quot; y.&quot;)
       end
test (generic function with 1 method)

julia&gt; test(2, 1)
x is greater than y.</code></pre><!--
The variable `relation` is declared inside the `if` block, but used outside. However, when depending
on this behavior, make sure all possible code paths define a value for the variable. The following
change to the above function results in a runtime error
--><p>変数<code>relation</code>は<code>if</code>ブロックの中で宣言していますが、外側でも使えます。 しかし、この挙動を利用する時は、総ての取りうる分岐に対して変数が定義されているかどうか確かめる必要があります。 以下のように上述の関数を書換えると、実行時エラーが発生します。</p><pre><code class="language-julia-repl">julia&gt; function test(x,y)
           if x &lt; y
               relation = &quot;less than&quot;
           elseif x == y
               relation = &quot;equal to&quot;
           end
           println(&quot;x is &quot;, relation, &quot; y.&quot;)
       end
test (generic function with 1 method)

julia&gt; test(1,2)
x is less than y.

julia&gt; test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7</code></pre><!--
`if` blocks also return a value, which may seem unintuitive to users coming from many other languages.
This value is simply the return value of the last executed statement in the branch that was chosen,
so

--><p>また、<code>if</code>ブロックは値を返しますが、他のプログラム言語出身のユーザーには、直観に反するかもしれません。 この値は、選択した分岐の中で最後に実行した文の単なる戻り値です。</p><pre><code class="language-julia-repl">julia&gt; x = 3
3

julia&gt; if x &gt; 0
           &quot;positive!&quot;
       else
           &quot;negative...&quot;
       end
&quot;positive!&quot;</code></pre><!--
Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit
Evaluation in Julia, as outlined in the next section.

Unlike C, MATLAB, Perl, Python, and Ruby -- but like Java, and a few other stricter, typed languages
-- it is an error if the value of a conditional expression is anything but `true` or `false`:

--><p>とても短い（１行の）条件文は、Juliaではよく短絡評価を使って表現される点に注意してください。 これは、次のセクションで概説します。</p><p>C, MATLAB, Perl, Python, Rubyなどとは異なり、しかしJavaやその他少数の型付き言語と同様に、 条件式の値が <code>true</code>や<code>false</code>以外の場合は、エラーになります。</p><pre><code class="language-julia-repl">julia&gt; if 1
           println(&quot;true&quot;)
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><!--
This error indicates that the conditional was of the wrong type: [`Int64`](@ref) rather
than the required [`Bool`](@ref).
--><p>このエラーは、条件式の値の型が、求められる<a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>ではなく不当な<a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>であることを示します。</p><!--
The so-called "ternary operator", `?:`, is closely related to the `if`-`elseif`-`else` syntax,
but is used where a conditional choice between single expression values is required, as opposed
to conditional execution of longer blocks of code. It gets its name from being the only operator
in most languages taking three operands:
--><p>いわゆる&quot;三項演算子&quot;の<code>?:</code>は<code>if</code>-<code>elseif</code>-<code>else</code>構文にとても近いですが、 条件式の選択が単一式の値からだけの場合に限られます。 長いブロックのコードを持つ条件文を実行する場合は使えません。 この名前の由来は、多くの言語で被演算子が３個の唯一の演算子だからです。</p><pre><code class="language-julia">a ? b : c</code></pre><!--
The expression `a`, before the `?`, is a condition expression, and the ternary operation evaluates
the expression `b`, before the `:`, if the condition `a` is `true` or the expression `c`, after
the `:`, if it is `false`. Note that the spaces around `?` and `:` are mandatory: an expression
like `a?b:c` is not a valid ternary expression (but a newline is acceptable after both the `?` and
the `:`).
--><p><code>?</code>の前の式<code>a</code>は条件式で、<code>a</code>が<code>true</code>の時は、<code>:</code>の前の式<code>b</code>を評価し、<code>a</code>が<code>false</code>の時は式<code>c</code>を評価します。 <code>?</code>や<code>:</code>の周りの空白は必須である点に注意してください。  <code>a?b:c</code>のように書いた式は、無効な三項演算子です。  （しかし<code>?</code>や<code>:</code>のあとに改行を入れるのは構いません）</p><!--
The easiest way to understand this behavior is to see an example. In the previous example, the
`println` call is shared by all three branches: the only real choice is which literal string to
print. This could be written more concisely using the ternary operator. For the sake of clarity,
let's try a two-way version first:
--><p>この挙動を理解する一番簡単な方法は、例をみることです。 前述の例では、<code>println</code>の呼び出しは３つの分岐で共有しています。 実際に選択しているのは、印字する文字列リテラルです。 これは、三項演算子を使ってもっと簡潔に書くことができます。 もっとはっきりさせるために、先に２つの選択の場合をやってみましょう。</p><pre><code class="language-julia-repl">julia&gt; x = 1; y = 2;

julia&gt; println(x &lt; y ? &quot;less than&quot; : &quot;not less than&quot;)
less than

julia&gt; x = 1; y = 0;

julia&gt; println(x &lt; y ? &quot;less than&quot; : &quot;not less than&quot;)
not less than</code></pre><!--
If the expression `x < y` is true, the entire ternary operator expression evaluates to the string
`"less than"` and otherwise it evaluates to the string `"not less than"`. The original three-way
example requires chaining multiple uses of the ternary operator together:
--><p>式<code>x &lt; y</code>が真の時は、文字列<code>&quot;less than&quot;</code>、そうではない場合は文字列<code>&quot;not less than&quot;</code>に 三項演算子全体が評価されます。 もともとの３選択の例には、三項演算子を複数連鎖させる必要があります。</p><pre><code class="language-julia-repl">julia&gt; test(x, y) = println(x &lt; y ? &quot;x is less than y&quot;    :
                            x &gt; y ? &quot;x is greater than y&quot; : &quot;x is equal to y&quot;)
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</code></pre><!--
To facilitate chaining, the operator associates from right to left.

It is significant that like `if`-`elseif`-`else`, the expressions before and after the `:` are
only evaluated if the condition expression evaluates to `true` or `false`, respectively:
--><p>連鎖を簡単にするために、この演算子は右から左へと結合します。</p><p>重要なことですが、 <code>if</code>-<code>elseif</code>-<code>else</code>と同じように、<code>:</code>の前と後だけが条件式の評価値が<code>true</code>か<code>false</code>に従って評価されます。</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; 1 &lt; 2 ? v(&quot;yes&quot;) : v(&quot;no&quot;)
yes
&quot;yes&quot;

julia&gt; 1 &gt; 2 ? v(&quot;yes&quot;) : v(&quot;no&quot;)
no
&quot;no&quot;</code></pre><p>`<a href="## Short-Circuit Evaluation"></a></p><h2><a class="nav-anchor" id="短絡評価-1" href="#短絡評価-1">短絡評価</a></h2><!--
Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in
most imperative programming languages having the `&&` and `||` boolean operators: in a series
of boolean expressions connected by these operators, only the minimum number of expressions are
evaluated as are necessary to determine the final boolean value of the entire chain. Explicitly,
this means that:
--><p>短絡評価は条件評価ととても良く似ています。 この挙動は、ほとんどの命令型言語が持っているブール値の演算子<code>&amp;&amp;</code>と<code>||</code>で見られます。 これらの演算子でつなげたブール式の中で、連鎖全体の最終的なブール値を決めるのに必要な最低限の数の式だけが評価されます。 この意味を具体的に書くと、</p><!--
  * In the expression `a && b`, the subexpression `b` is only evaluated if `a` evaluates to `true`.
  * In the expression `a || b`, the subexpression `b` is only evaluated if `a` evaluates to `false`.
--><ul><li>式<code>a &amp;&amp; b</code>の部分式<code>b</code>は、<code>a</code>の評価が<code>true</code>の時だけ評価される。</li><li>式<code>a || b</code>の部分式<code>b</code>は、<code>a</code>の評価が<code>false</code>の時だけ評価される。</li></ul><!--
The reasoning is that `a && b` must be `false` if `a` is `false`, regardless of the value of
`b`, and likewise, the value of `a || b` must be true if `a` is `true`, regardless of the value
of `b`. Both `&&` and `||` associate to the right, but `&&` has higher precedence than `||` does.
It's easy to experiment with this behavior:
--><p>この論拠としては、<code>a &amp;&amp; b</code>は<code>a</code>が<code>false</code>の時は<code>b</code>の値にかかわらず必ず<code>false</code>になり、同様に <code>a &amp;&amp; b</code>は<code>a</code>が<code>ture</code>の時は<code>b</code>の値にかかわらず必ず<code>true</code>からです。 <code>&amp;&amp;</code>と<code>||</code>は両方とも右結合ですが、<code>&amp;&amp;</code>のほうが <code>||</code>より優先順位が高いです。 この挙動は簡単に実験できます。</p><pre><code class="language-julia-repl">julia&gt; t(x) = (println(x); true)
t (generic function with 1 method)

julia&gt; f(x) = (println(x); false)
f (generic function with 1 method)

julia&gt; t(1) &amp;&amp; t(2)
1
2
true

julia&gt; t(1) &amp;&amp; f(2)
1
2
false

julia&gt; f(1) &amp;&amp; t(2)
1
false

julia&gt; f(1) &amp;&amp; f(2)
1
false

julia&gt; t(1) || t(2)
1
true

julia&gt; t(1) || f(2)
1
true

julia&gt; f(1) || t(2)
1
2
true

julia&gt; f(1) || f(2)
1
2
false</code></pre><!--
You can easily experiment in the same way with the associativity and precedence of various combinations
of `&&` and `||` operators.

This behavior is frequently used in Julia to form an alternative to very short `if` statements.
Instead of `if <cond> <statement> end`, one can write `<cond> && <statement>` (which could be
read as: <cond> *and then* <statement>). Similarly, instead of `if ! <cond> <statement> end`,
one can write `<cond> || <statement>` (which could be read as: <cond> *or else* <statement>).

For example, a recursive factorial routine could be defined like this:
--><p><code>&amp;&amp;</code>や<code>||</code>の様々な結合について、結合性や優先順位を、同じ方法で簡単に実験することができます。</p><p>この挙動は、Juliaではよく利用されて、とても短い<code>if</code>文の代わりになっています。 <code>if &lt;条件&gt; &lt;文&gt; end</code>, の代わりに<code>&lt;条件&gt; &amp;&amp; &lt;文&gt;</code>と書くことができます。 これは（&lt;条件&gt;ならば&lt;文&gt;）と読むことができます。 同様に <code>if ! &lt;条件&gt; &lt;文&gt; end</code>は <code>&lt;条件&gt; || &lt;文&gt;</code>と書くことができます。 これは（&lt;条件&gt;でなけば&lt;文&gt;）と読むことができます。</p><p>例えば、再帰的な階乗の計算はこのように定義できます。</p><pre><code class="language-julia-repl">julia&gt; function fact(n::Int)
           n &gt;= 0 || error(&quot;n must be non-negative&quot;)
           n == 0 &amp;&amp; return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia&gt; fact(5)
120

julia&gt; fact(0)
1

julia&gt; fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fact(::Int64) at ./none:2
 [3] top-level scope</code></pre><!--
Boolean operations *without* short-circuit evaluation can be done with the bitwise boolean operators
introduced in [Mathematical Operations and Elementary Functions](@ref): `&` and `|`. These are
normal functions, which happen to support infix operator syntax, but always evaluate their arguments:
--><p>短絡評価を <strong>しない</strong> ブール演算子は、<a href="manual/@ref">算術演算子と初等関数</a>で紹介したビット演算子の<code>&amp;</code>と<code>|</code>を使って処理することができます。 これらは通常の関数で、たまたま中置記法の演算子を持ち、しかし引数を常に評価します。</p><pre><code class="language-julia-repl">julia&gt; f(1) &amp; t(2)
1
2
false

julia&gt; t(1) | t(2)
1
2
true</code></pre><!--
Just like condition expressions used in `if`, `elseif` or the ternary operator, the operands of
`&&` or `||` must be boolean values (`true` or `false`). Using a non-boolean value anywhere except
for the last entry in a conditional chain is an error:
--><p><code>if</code>、<code>elseif</code>や三項演算子の中で使われる条件式と同じように、<code>&amp;&amp;</code>や<code>||</code>で使われる被演算子はブール値(<code>true</code>か <code>false</code>) でなければなりません。 ブール値以外を条件連鎖の末尾以外で使うとエラーが発生します。</p><pre><code class="language-julia-repl">julia&gt; 1 &amp;&amp; true
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><!--
On the other hand, any type of expression can be used at the end of a conditional chain. It will
be evaluated and returned depending on the preceding conditionals:
--><p>一方、条件連鎖の末尾では、どんな型の式でも使えます。 これは先行する条件式に応じて評価され、戻り値として返されます。</p><pre><code class="language-julia-repl">julia&gt; true &amp;&amp; (x = (1, 2, 3))
(1, 2, 3)

julia&gt; false &amp;&amp; (x = (1, 2, 3))
false</code></pre><p>`<a href="## [Repeated Evaluation: Loops](@id man-loops)"></a></p><h2><a class="nav-anchor" id="man-loops-1" href="#man-loops-1">反復評価：ループ</a></h2><!--
There are two constructs for repeated evaluation of expressions: the `while` loop and the `for`
loop. Here is an example of a `while` loop:
--><p>式の反復評価をする構文は２つあります。 <code>while</code>ループと<code>for</code>ループです。 <code>while</code>ループの例を示します。</p><pre><code class="language-julia-repl">julia&gt; i = 1;

julia&gt; while i &lt;= 5
           println(i)
           global i += 1
       end
1
2
3
4
5</code></pre><!--
The `while` loop evaluates the condition expression (`i <= 5` in this case), and as long it remains
`true`, keeps also evaluating the body of the `while` loop. If the condition expression is `false`
when the `while` loop is first reached, the body is never evaluated.

The `for` loop makes common repeated evaluation idioms easier to write. Since counting up and
down like the above `while` loop does is so common, it can be expressed more concisely with a
`for` loop:
--><p><code>while</code>ループは条件式を評価し（この場合は<code>i &lt;= 5</code>）、それが<code>true</code>である限り<code>while</code>ループの本体の評価を続けます。 条件式の評価が初めて<code>false</code>になった時、それ以降、本体の評価はまったく行いません。</p><p><code>for</code>ループはよくある反復評価を簡単に書くための慣用表現です。 上記の<code>while</code>ループのようなカウントアップ・カウントダウンは、よく使うために、もっと簡潔な<code>for</code>ループで表現できるのです。</p><pre><code class="language-julia-repl">julia&gt; for i = 1:5
           println(i)
       end
1
2
3
4
5</code></pre><!--
Here the `1:5` is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The `for`
loop iterates through these values, assigning each one in turn to the variable `i`. One rather
important distinction between the previous `while` loop form and the `for` loop form is the scope
during which the variable is visible. If the variable `i` has not been introduced in another
scope, in the `for` loop form, it is visible only inside of the `for` loop, and not
outside/afterwards. You'll either need a new interactive session instance or a different variable
name to test this:
--><p>ここで、<code>1:5</code>は範囲オブジェクトで、1, 2, 3, 4, 5という数列を表しています。 <code>for</code>ループはこれらの値に対する反復処理を行い、各値を変数<code>i</code>に代入します。 前述の<code>while</code>ループと形式と<code>for</code>ループ形式のかなり重要な違いは、変数の見えるスコープです。 変数<code>i</code>が別のスコープに導入されていない場合、<code>for</code>ループ形式では、<code>i</code>の見えるのは、for<code>ループの中だけで、外側や for</code>ループ以降からは見えません。 よって検査をするためには、新しい対話セッションを始めるか、別の変数名を使う必要があります。</p><pre><code class="language-julia-repl">julia&gt; for j = 1:5
           println(j)
       end
1
2
3
4
5

julia&gt; j
ERROR: UndefVarError: j not defined</code></pre><!--
See [Scope of Variables](@ref scope-of-variables) for a detailed explanation of variable scope and how it works in
Julia.

In general, the `for` loop construct can iterate over any container. In these cases, the alternative
(but fully equivalent) keyword `in` or `∈` is typically used instead of `=`, since it makes
the code read more clearly:
--><p>Juliaでの変数のスコープと挙動の詳細な説明と<a href="variables-and-scoping.html#scope-of-variables-1">変数のスコープ</a>を参照してください。</p><p>一般に、<code>for</code>ループ構文はどんなコンテナに対しても反復を行うことができます。 代替の（しかし完全に等価な）キーワードの<code>in</code>や<code>∈</code>は、<code>=</code>の代わりによく使われます。 というのも、コードがもっと分かりやすくなるからです。</p><pre><code class="language-julia-repl">julia&gt; for i in [1,4,0]
           println(i)
       end
1
4
0

julia&gt; for s ∈ [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
           println(s)
       end
foo
bar
baz</code></pre><!--
Various types of iterable containers will be introduced and discussed in later sections of the
manual (see, e.g., [Multi-dimensional Arrays](@ref man-multi-dim-arrays)).

It is sometimes convenient to terminate the repetition of a `while` before the test condition
is falsified or stop iterating in a `for` loop before the end of the iterable object is reached.
This can be accomplished with the `break` keyword:
--><p>様々なタイプのイテラブルなコンテナについて、マニュアルのあとのセクションで紹介と議論を行います。 （例えば <a href="arrays.html#man-multi-dim-arrays-1">多次元配列</a>を参照してください）</p><p><code>while</code>ループで条件式の検査が偽になる前や、<code>for</code>ループがイテラブルなオブジェクトの最後に達する前に 終了できると便利なことがよくあります。 <code>break</code>キーワードを使うとこれを達成できます。</p><pre><code class="language-julia-repl">julia&gt; i = 1;

julia&gt; while true
           println(i)
           if i &gt;= 5
               break
           end
           global i += 1
       end
1
2
3
4
5

julia&gt; for j = 1:1000
           println(j)
           if j &gt;= 5
               break
           end
       end
1
2
3
4
5</code></pre><!--
Without the `break` keyword, the above `while` loop would never terminate on its own, and the `for` loop would iterate up to 1000. These loops are both exited early by using `break`.

In other circumstances, it is handy to be able to stop an iteration and move on to the next one
immediately. The `continue` keyword accomplishes this:
--><p><code>break</code>キーワードがなければ、上記の<code>while</code>ループは、決して勝手に終わらず、<code>for</code>ループは1000まで反復を行うでしょう。 これらのループは両方とも<code>break</code>を使って、早い段階で終了しています。</p><p>他の状況では、反復を止めて、すぐに次に移ることができると便利なことがあります。 <code>continue</code>キーワードによってこれを達成できます。</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9</code></pre><!--
This is a somewhat contrived example since we could produce the same behavior more clearly by
negating the condition and placing the `println` call inside the `if` block. In realistic usage
there is more code to be evaluated after the `continue`, and often there are multiple points from
which one calls `continue`.

Multiple nested `for` loops can be combined into a single outer loop, forming the cartesian product
of its iterables:
--><p>この例はちょっと不自然です。 というのも、条件を否定し、<code>println</code>の呼び出しを<code>if</code>ブロックの中においたほうが、同じ挙動をもっと明快に実現できるからです。 現実的な用法では、<code>continue</code>のあとに評価すべきコードがもっとあって、<code>continue</code>を呼び出す箇所も複数あるでしょう。</p><p>多重にネストした<code>for</code>ループは、統合して、各イテラブルオブジェクトの直積に対する、1つの外側のループにすることができます。</p><pre><code class="language-julia-repl">julia&gt; for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)</code></pre><!--
With this syntax, iterables may still refer to outer loop variables; e.g. `for i = 1:n, j = 1:i`
is valid.
However a `break` statement inside such a loop exits the entire nest of loops, not just the inner one.
Both variables (`i` and `j`) are set to their current iteration values each time the inner loop runs.
Therefore, assignments to `i` will not be visible to subsequent iterations:
--><p>この構文では、イテラブルが外側のループの変数を参照することが可能です。 例えば、<code>for i = 1:n, j = 1:i</code>は有効です。 しかし、このようなループの中にある<code>break</code>文によって、内側だけでなく、ネストしたループ全体を脱出します。 両方の変数(<code>i</code> と<code>j</code>)とも、内側のループが実行されるごとに、その回の値が代入されます。 そのため<code>i</code>に対する代入は以降の回の反復からは見えません。</p><pre><code class="language-julia-repl">julia&gt; for i = 1:2, j = 3:4
           println((i, j))
           i = 0
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)</code></pre><!--
If this example were rewritten to use a `for` keyword for each variable, then the output would
be different: the second and fourth values would contain `0`.
--><p>この例で各変数ごとに<code>for</code>キーワード使うように書き直したとすると、出力は変わるでしょう。 2番目と4番目の出力は<code>0</code>を含むでしょう。</p><p>`<a href="## Exception Handling"></a></p><h2><a class="nav-anchor" id="例外処理-1" href="#例外処理-1">例外処理</a></h2><!--
When an unexpected condition occurs, a function may be unable to return a reasonable value to
its caller. In such cases, it may be best for the exceptional condition to either terminate the
program while printing a diagnostic error message, or if the programmer has provided code to handle
such exceptional circumstances then allow that code to take the appropriate action.
--><p>不測の事態が発生した場合、関数は呼び出し側に応えて、適切な値を返すことができないかもしれません。 そんな場合、例外的な状況に対する最善策は、プログラムを終了する一方で、状況を診断するエラーメッセージを表示することかもしれないし、 例外的な事態に対処するコードが用意されている場合は、そのコードを適切に動作させることかもしれません。</p><p><code>[](### Built-in</code>Exception`s)</p><h3><a class="nav-anchor" id="組込みの-**例外**-1" href="#組込みの-**例外**-1">組込みの <strong>例外</strong></a></h3><!--
`Exception`s are thrown when an unexpected condition has occurred. The built-in `Exception`s listed
below all interrupt the normal flow of control.
--><p><code>例外</code>は不測の事態が発生した時に投げられます。 下記の組込みの<code>例外</code>のリストはすべて、通常の制御フローを中断します。</p><!--
| `Exception`                   |
|:----------------------------- |
| [`ArgumentError`](@ref)       |
| [`BoundsError`](@ref)         |
| [`CompositeException`](@ref)  |
| [`DivideError`](@ref)         |
| [`DomainError`](@ref)         |
| [`EOFError`](@ref)            |
| [`ErrorException`](@ref)      |
| [`InexactError`](@ref)        |
| [`InitError`](@ref)           |
| [`InterruptException`](@ref)  |
| `InvalidStateException`       |
| [`KeyError`](@ref)            |
| [`LoadError`](@ref)           |
| [`OutOfMemoryError`](@ref)    |
| [`ReadOnlyMemoryError`](@ref) |
| [`RemoteException`](@ref)     |
| [`MethodError`](@ref)         |
| [`OverflowError`](@ref)       |
| [`Meta.ParseError`](@ref)     |
| [`SystemError`](@ref)         |
| [`TypeError`](@ref)           |
| [`UndefRefError`](@ref)       |
| [`UndefVarError`](@ref)       |
| [`StringIndexError`](@ref)    |

--><table><tr><th><code>例外</code></th></tr><tr><td><a href="../base/base.html#Core.ArgumentError"><code>ArgumentError</code></a></td></tr><tr><td><a href="../base/base.html#Core.BoundsError"><code>BoundsError</code></a></td></tr><tr><td><a href="../base/base.html#Base.CompositeException"><code>CompositeException</code></a></td></tr><tr><td><a href="../base/base.html#Core.DivideError"><code>DivideError</code></a></td></tr><tr><td><a href="../base/base.html#Core.DomainError"><code>DomainError</code></a></td></tr><tr><td><a href="../base/base.html#Base.EOFError"><code>EOFError</code></a></td></tr><tr><td><a href="../base/base.html#Core.ErrorException"><code>ErrorException</code></a></td></tr><tr><td><a href="../base/base.html#Core.InexactError"><code>InexactError</code></a></td></tr><tr><td><a href="../base/base.html#Core.InitError"><code>InitError</code></a></td></tr><tr><td><a href="../base/base.html#Core.InterruptException"><code>InterruptException</code></a></td></tr><tr><td><code>InvalidStateException</code></td></tr><tr><td><a href="../base/base.html#Base.KeyError"><code>KeyError</code></a></td></tr><tr><td><a href="../base/base.html#Core.LoadError"><code>LoadError</code></a></td></tr><tr><td><a href="../base/base.html#Core.OutOfMemoryError"><code>OutOfMemoryError</code></a></td></tr><tr><td><a href="../base/base.html#Core.ReadOnlyMemoryError"><code>ReadOnlyMemoryError</code></a></td></tr><tr><td><a href="../stdlib/Distributed.html#Distributed.RemoteException"><code>RemoteException</code></a></td></tr><tr><td><a href="../base/base.html#Core.MethodError"><code>MethodError</code></a></td></tr><tr><td><a href="../base/base.html#Core.OverflowError"><code>OverflowError</code></a></td></tr><tr><td><a href="../base/base.html#Base.Meta.ParseError"><code>Meta.ParseError</code></a></td></tr><tr><td><a href="../base/base.html#Base.SystemError"><code>SystemError</code></a></td></tr><tr><td><a href="../base/base.html#Core.TypeError"><code>TypeError</code></a></td></tr><tr><td><a href="../base/base.html#Core.UndefRefError"><code>UndefRefError</code></a></td></tr><tr><td><a href="../base/base.html#Core.UndefVarError"><code>UndefVarError</code></a></td></tr><tr><td><a href="../base/base.html#Base.StringIndexError"><code>StringIndexError</code></a></td></tr></table><!--
For example, the [`sqrt`](@ref) function throws a [`DomainError`](@ref) if applied to a negative
real value:
--><p>例えば、<a href="../base/math.html#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>関数は、負の実数に適用しようとすると <a href="../base/base.html#Core.DomainError"><code>DomainError</code></a>を投げます。</p><pre><code class="language-julia-repl">julia&gt; sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre><!--
You may define your own exceptions in the following way:
--><p>以下のようにして、自分で例外を定義することができます。</p><pre><code class="language-julia-repl">julia&gt; struct MyCustomException &lt;: Exception end</code></pre><p><code>[](### The [</code>throw`](@ref) function)</p><h3><a class="nav-anchor" id="[throw](@ref)関数-1" href="#[throw](@ref)関数-1"><a href="../base/base.html#Core.throw"><code>throw</code></a>関数</a></h3><!--
Exceptions can be created explicitly with [`throw`](@ref). For example, a function defined only
for nonnegative numbers could be written to [`throw`](@ref) a [`DomainError`](@ref) if the argument
is negative:
--><p>例外は<a href="../base/base.html#Core.throw"><code>throw</code></a>を使って明示的に生成することができます。 例えば、非負の数にのみ定義されている関数を、引数が負の時に <a href="../base/base.html#Core.DomainError"><code>DomainError</code></a>を<a href="../base/base.html#Core.throw"><code>throw</code></a>することで定義できます。</p><pre><code class="language-julia-repl">julia&gt; f(x) = x&gt;=0 ? exp(-x) : throw(DomainError(x, &quot;argument must be nonnegative&quot;))
f (generic function with 1 method)

julia&gt; f(1)
0.36787944117144233

julia&gt; f(-1)
ERROR: DomainError with -1:
argument must be nonnegative
Stacktrace:
 [1] f(::Int64) at ./none:1</code></pre><!--
Note that [`DomainError`](@ref) without parentheses is not an exception, but a type of exception.
It needs to be called to obtain an `Exception` object:
--><p><a href="../base/base.html#Core.DomainError"><code>DomainError</code></a>に括弧を付けないと例外ではなく、例外の型になります。 <code>Exception</code>オブジェクトを補足する時に必要となり呼び出されます。</p><pre><code class="language-julia-repl">julia&gt; typeof(DomainError(nothing)) &lt;: Exception
true

julia&gt; typeof(DomainError) &lt;: Exception
false</code></pre><!--
Additionally, some exception types take one or more arguments that are used for error reporting:
--><p>さらに、例外の型の中には、エラー報告のために、1個以上の引数を取るものがあります。</p><pre><code class="language-julia-repl">julia&gt; throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined</code></pre><!--
This mechanism can be implemented easily by custom exception types following the way [`UndefVarError`](@ref)
is written:
--><p>このしくみは、<a href="../base/base.html#Core.UndefVarError"><code>UndefVarError</code></a>の書き方に従って、独自の型を作ると、簡単に実装できます。</p><pre><code class="language-julia-repl">julia&gt; struct MyUndefVarError &lt;: Exception
           var::Symbol
       end

julia&gt; Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, &quot; not defined&quot;)</code></pre><!--
!!! note
    When writing an error message, it is preferred to make the first word lowercase. For example,
    `size(A) == size(B) || throw(DimensionMismatch("size of A not equal to size of B"))`

    is preferred over

    `size(A) == size(B) || throw(DimensionMismatch("Size of A not equal to size of B"))`.

    However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument
    to a function is a capital letter: `size(A,1) == size(B,2) || throw(DimensionMismatch("A has first dimension..."))`.

--><p>!!! 注意     エラーメッセージを書く時は、小文字で始めるのが好ましいです。例えば、</p><pre><code class="language-none">`size(A) == size(B) || throw(DimensionMismatch(&quot;size of A not equal to size of B&quot;))`

の方が、下記のものより好ましいです。

`size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))`

しかし、意図的に、出だしの文字を大文字のままにする場合もたまにあります。
例えば、関数の引数が大文字の場合の時です。

 `size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))`</code></pre><h3><a class="nav-anchor" id="エラー-1" href="#エラー-1">エラー</a></h3><!--
The [`error`](@ref) function is used to produce an [`ErrorException`](@ref) that interrupts
the normal flow of control.

Suppose we want to stop execution immediately if the square root of a negative number is taken.
To do this, we can define a fussy version of the [`sqrt`](@ref) function that raises an error
if its argument is negative:
--><p><a href="../base/base.html#Base.error"><code>error</code></a>関数は、通常の制御フローを中断する<a href="../base/base.html#Core.ErrorException"><code>ErrorException</code></a>を生成するために利用されます。</p><p>平方根の関数の引数に負の数を受け取ると即座に実行を停止したいとします。 これを行うために、引数が負の時にエラーをおこす小うるさい<a href="../base/math.html#Base.sqrt-Tuple{Real}"><code>sqrt</code></a>を定義できます。</p><pre><code class="language-julia-repl">julia&gt; fussy_sqrt(x) = x &gt;= 0 ? sqrt(x) : error(&quot;negative x not allowed&quot;)
fussy_sqrt (generic function with 1 method)

julia&gt; fussy_sqrt(2)
1.4142135623730951

julia&gt; fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt(::Int64) at ./none:1
 [3] top-level scope</code></pre><!--
If `fussy_sqrt` is called with a negative value from another function, instead of trying to continue
execution of the calling function, it returns immediately, displaying the error message in the
interactive session:
--><p><code>fussy_sqrt</code>が負の数と共に、他の関数から呼ばれると、関数を呼び出して実行しようとする代わりに、 即座に終了して対話セッションにエラーメッセージを表示します。 </p><pre><code class="language-julia-repl">julia&gt; function verbose_fussy_sqrt(x)
           println(&quot;before fussy_sqrt&quot;)
           r = fussy_sqrt(x)
           println(&quot;after fussy_sqrt&quot;)
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia&gt; verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia&gt; verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] error at ./error.jl:33 [inlined]
 [2] fussy_sqrt at ./none:1 [inlined]
 [3] verbose_fussy_sqrt(::Int64) at ./none:3
 [4] top-level scope</code></pre><p><code>[](### The</code>try/catch` statement)</p><h3><a class="nav-anchor" id="try/catch-文-1" href="#try/catch-文-1"><code>try/catch</code> 文</a></h3><!--
The `try/catch` statement allows for `Exception`s to be tested for. For example, a customized
square root function can be written to automatically call either the real or complex square root
method on demand using `Exception`s :
--><p><code>try/catch</code>文では、<code>例外</code>を試行することができます。 例えば、<code>例外</code>を使って、実数と複素数のどちらかの平方根メソッドを要求次第で自動で呼び出す、独自の平方根関数を書くことができます。</p><pre><code class="language-julia-repl">julia&gt; f(x) = try
           sqrt(x)
       catch
           sqrt(complex(x, 0))
       end
f (generic function with 1 method)

julia&gt; f(1)
1.0

julia&gt; f(-1)
0.0 + 1.0im</code></pre><!--
It is important to note that in real code computing this function, one would compare `x` to zero
instead of catching an exception. The exception is much slower than simply comparing and branching.

`try/catch` statements also allow the `Exception` to be saved in a variable. The following
contrived example calculates the square root of the second element of `x` if `x`
is indexable, otherwise assumes `x` is a real number and returns its square root:
--><p>重要なので注意しておきたい点は、関数を実際のコードの中で計算する時は、例外を補足するのではなくて、<code>x</code>を０と比較する点です。 単に比較して分岐するよりも、はるかに例外は遅いのです。</p><p><code>try/catch</code>文では、<code>例外</code>を変数に保存することができます。 以下の不自然な例では、<code>x</code>にインデックスがある場合には、<code>x</code>の第２要素の平方根を計算し、 そうでなければ<code>x</code>を実数とみなしてその平方根を返します。</p><pre><code class="language-julia-repl">julia&gt; sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia&gt; sqrt_second([1 4])
2.0

julia&gt; sqrt_second([1 -4])
0.0 + 2.0im

julia&gt; sqrt_second(9)
3.0

julia&gt; sqrt_second(-9)
ERROR: DomainError with -9.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]</code></pre><!--
Note that the symbol following `catch` will always be interpreted as a name for the exception,
so care is needed when writing `try/catch` expressions on a single line. The following code will
*not* work to return the value of `x` in case of an error:
--><p><code>catch</code>に続く記号は常に例外の名前として解釈されることに注意してください。 そのため、<code>try/catch</code>式を１行で書く場合は、注意が必要です。 以下のコードはエラーの場合には<code>x</code>の値を返しません。</p><pre><code class="language-julia">try bad() catch x end</code></pre><!--
Instead, use a semicolon or insert a line break after `catch`:
--><p>代替策として、セミコロンを使ったり、<code>catch</code>のあとに改行を入れたりします。</p><pre><code class="language-julia">try bad() catch; x end

try bad()
catch
    x
end</code></pre><!--
The power of the `try/catch` construct lies in the ability to unwind a deeply nested computation
immediately to a much higher level in the stack of calling functions. There are situations where
no error has occurred, but the ability to unwind the stack and pass a value to a higher level
is desirable. Julia provides the [`rethrow`](@ref), [`backtrace`](@ref) and [`catch_backtrace`](@ref)
functions for more advanced error handling.
--><p><code>try/catch</code>構文の威力は、深くネストした計算を直ちに巻き戻して、 関数呼び出しスタックのはるかに高水準まで戻って来ることが可能な点にあります。</p><p><code>[](###</code>finally` Clauses)</p><h3><a class="nav-anchor" id="finally-節-1" href="#finally-節-1"><code>finally</code> 節</a></h3><!--
In code that performs state changes or uses resources like files, there is typically clean-up
work (such as closing files) that needs to be done when the code is finished. Exceptions potentially
complicate this task, since they can cause a block of code to exit before reaching its normal
end. The `finally` keyword provides a way to run some code when a given block of code exits, regardless
of how it exits.
--><p>状態の変化やファイルのようなリソースの使用を伴うコードには、通常、コードの終了時にすべき整理作業(ファイルを閉じるなど) があります。 例外があるとこの作業が複雑になる可能性があります。というのも、最後に達して正常終了する前に、例外がコードブロックを実行することもあるからです。 <code>finally</code>キーワードは、どのように終了しようとも、コードブロックが終了する前に、何らかのコードを実行する手段を提供します。</p><!--
For example, here is how we can guarantee that an opened file is closed:
--><p>ここで、開いたファイルを必ず閉じることを保証する例を挙げます。</p><pre><code class="language-julia">f = open(&quot;file&quot;)
try
    # operate on file f
finally
    close(f)
end</code></pre><!--
When control leaves the `try` block (for example due to a `return`, or just finishing normally),
`close(f)` will be executed. If the `try` block exits due to an exception, the exception will
continue propagating. A `catch` block may be combined with `try` and `finally` as well. In this
case the `finally` block will run after `catch` has handled the error.
--><p>制御が<code>try</code>ブロックを離れる時（例えば<code>return</code>による場合、正常終了の場合など）に、<code>close(f)</code> が実行されます。 <code>try</code>ブロックが例外によって終了する場合、例外は伝播を続けます。 <code>catch</code>ブロックを<code>try</code>や<code>finally</code>と組み合わせても構いません。 この場合は、<code>finally</code>ブロックは<code>catch</code>がエラー処理をしたあとに実行されます。</p><p>`<a href="## [Tasks (aka Coroutines)](@id man-tasks)"></a></p><h2><a class="nav-anchor" id="man-tasks-1" href="#man-tasks-1">タスク (別名　コルーチン)</a></h2><!--
Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible
manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight
threads, cooperative multitasking, or one-shot continuations.
--><p>タスクは計算の中断や再開を柔軟に行うことを可能にする制御フローの機能です。 この機能は、対称コルーチン、軽量スレッド、協調的マルチタスク、ワンショット継続などの別名でよばれることもあります。</p><!--
When a piece of computing work (in practice, executing a particular function) is designated as
a [`Task`](@ref), it becomes possible to interrupt it by switching to another [`Task`](@ref).
The original [`Task`](@ref) can later be resumed, at which point it will pick up right where it
left off. At first, this may seem similar to a function call. However there are two key differences.
First, switching tasks does not use any space, so any number of task switches can occur without
consuming the call stack. Second, switching among tasks can occur in any order, unlike function
calls, where the called function must finish executing before control returns to the calling function.
--><p>ひとまとまりの計算作業(実のところ、特定の関数の実行)を<a href="../base/parallel.html#Core.Task"><code>Task</code></a>に指定して実行すると、 これを中断して別の <a href="../base/parallel.html#Core.Task"><code>Task</code></a>に切り替えることができます。 もともとの <a href="../base/parallel.html#Core.Task"><code>Task</code></a>は後で中断したところから再開することができます。 一見、これは関数呼び出しと同じように見えるかもしれません。 しかし、２つの重要な違いがあります。 まず、タスクの切り替えにはメモリ領域を使用しません。 このため、切り替えるタスクの数をいくら増やしても、コールスタックを消費しません。 次に、タスクの切り替えは、どんな順番でもよく、関数呼び出しとは異なります。 関数呼び出しの場合は、呼び出される関数は、呼び出す関数に制御が戻る前に、実行を終了する必要があります。</p><!--
This kind of control flow can make it much easier to solve certain problems. In some problems,
the various pieces of required work are not naturally related by function calls; there is no obvious
"caller" or "callee" among the jobs that need to be done. An example is the producer-consumer
problem, where one complex procedure is generating values and another complex procedure is consuming
them. The consumer cannot simply call a producer function to get a value, because the producer
may have more values to generate and so might not yet be ready to return. With tasks, the producer
and consumer can both run as long as they need to, passing values back and forth as necessary.
--><p>この種の制御フローのを使うと、ある種の問題は簡単に解決できます。 ある種の問題では、関数呼び出しでは、様々な種類の作業を、自然に関連付けることができません。 なすべき仕事の「呼び出す側」と「呼び出される側」がはっきりしないものがあります。 例として挙げる「生産者/消費者」問題では、複雑な処理が値を生成する一方で、別の複雑な処理がそれを消費します。 消費者は値を得るために、単に生産者関数を呼び出せばいいわけではありません。 生産者には他にも生産すべき値があり、まだ値を返す準備ができていないかもしれないからです。 タスクを使うと、生産者と消費者は必要に応じて値をやり取りしながら、両者とも必要なだけ作動することができます。</p><!--
Julia provides a [`Channel`](@ref) mechanism for solving this problem.
A [`Channel`](@ref) is a waitable first-in first-out queue which can have
multiple tasks reading from and writing to it.

Let's define a producer task, which produces values via the [`put!`](@ref) call.
To consume values, we need to schedule the producer to run in a new task. A special [`Channel`](@ref)
constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel.
We can then [`take!`](@ref) values repeatedly from the channel object:
--><p>Juliaにはこの問題を解決するために<a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>の仕組みがあります。 <a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>は待機可能な先入先出のキューで複数のタスクを読取り・書込みが可能です。</p><p>生産者タスクを定義しましょう。 これは、<a href="../stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}"><code>put!</code></a>の呼び出しによって値の生産を行います。 値を消費するには、生産者が新しいタスクを実行するようにスケジュールする必要があります。 １引数の関数を引数とする<a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>の特殊なコンストラクタを使って、チャネルに束縛したタスクを実行することができます。 <a href="../stdlib/Distributed.html#Base.take!-Tuple{RemoteChannel,Vararg{Any,N} where N}"><code>take!</code></a>を使ってチャネルオブジェクトがら繰り返し値を取得することができます。</p><pre><code class="language-julia-repl">julia&gt; function producer(c::Channel)
           put!(c, &quot;start&quot;)
           for n=1:4
               put!(c, 2n)
           end
           put!(c, &quot;stop&quot;)
       end;

julia&gt; chnl = Channel(producer);

julia&gt; take!(chnl)
&quot;start&quot;

julia&gt; take!(chnl)
2

julia&gt; take!(chnl)
4

julia&gt; take!(chnl)
6

julia&gt; take!(chnl)
8

julia&gt; take!(chnl)
&quot;stop&quot;</code></pre><!--
One way to think of this behavior is that `producer` was able to return multiple times. Between
calls to [`put!`](@ref), the producer's execution is suspended and the consumer has control.

The returned [`Channel`](@ref) can be used as an iterable object in a `for` loop, in which case the
loop variable takes on all the produced values. The loop is terminated when the channel is closed.
--><p>「生産者」は何回も値を返すことができる、というのはこの挙動の解釈の１つです。 <a href="../stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}"><code>put!</code></a>の呼び出しの合間で、生産者の実行は中断し、制御が消費者に移ります。</p><p>戻り値の<a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>は<code>for</code>ループの中でイテラブルオブジェクトとして利用可能で、 この場合、ループの変数は、生産される値すべてを取ります。 チャネルが閉じるとループは終了します。</p><pre><code class="language-julia-repl">julia&gt; for x in Channel(producer)
           println(x)
       end
start
2
4
6
8
stop</code></pre><!--
Note that we did not have to explicitly close the channel in the producer. This is because
the act of binding a [`Channel`](@ref) to a [`Task`](@ref) associates the open lifetime of
a channel with that of the bound task. The channel object is closed automatically when the task
terminates. Multiple channels can be bound to a task, and vice-versa.

While the [`Task`](@ref) constructor expects a 0-argument function, the [`Channel`](@ref)
method which creates a channel bound task expects a function that accepts a single argument of
type [`Channel`](@ref). A common pattern is for the producer to be parameterized, in which case a partial
function application is needed to create a 0 or 1 argument [anonymous function](@ref man-anonymous-functions).

For [`Task`](@ref) objects this can be done either directly or by use of a convenience macro:
--><p>生産者のチャネルを明示的に閉じる必要はないことに注意してください。 これは、<a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>が<a href="../base/parallel.html#Core.Task"><code>Task</code></a>を束縛しているために、 チャネルの開いている生涯期間が、束縛したタスクの生涯期間に関連付けられているからです。 チャネルオブジェクトはタスクが終了すると自動的に閉じられます。 タスクは複数のチャネルに束縛可能で、逆も成り立ちます。</p><p><a href="../base/parallel.html#Core.Task"><code>Task</code></a>のコンストラクタの引数は、引数0個の関数ですが、 <a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>のメソッドは、<a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>型の引数1個を持つ関数で、 タスクを束縛したチャネルを生成します。 生産者をパラメータ化することは、よくあるパターンですが、この場合は引数が0個または１個の<a href="functions.html#man-anonymous-functions-1">無名関数</a> を作るために部分関数の適用が必要です。</p><p><a href="../base/parallel.html#Core.Task"><code>Task</code></a>オブジェクトに対して、これは、直接、または便利なマクロを使って行います。</p><pre><code class="language-julia">function mytask(myarg)
    ...
end

taskHdl = Task(() -&gt; mytask(7))
# or, equivalently
taskHdl = @task mytask(7)</code></pre><!--
To orchestrate more advanced work distribution patterns, [`bind`](@ref) and [`schedule`](@ref)
can be used in conjunction with [`Task`](@ref) and [`Channel`](@ref)
constructors to explicitly link a set of channels with a set of producer/consumer tasks.

Note that currently Julia tasks are not scheduled to run on separate CPU cores.
True kernel threads are discussed under the topic of [Parallel Computing](@ref).
--><p>より高度な作業分配パターンを編成するために、<a href="../stdlib/Sockets.html#Base.bind"><code>bind</code></a> や<a href="../base/parallel.html#Base.schedule"><code>schedule</code></a>を <a href="../base/parallel.html#Core.Task"><code>Task</code></a>や<a href="../base/parallel.html#Base.Channel"><code>Channel</code></a>と一緒に使って、チャネルの集合と生産者/消費者のタスクの集合を、 明示的に連携させることができます。</p><p>現時点では、Juliaのタスクは、別々のCPUのコアにスケジュールされない点に注意してください。 真のカーネルスレッドの関しては<a href="parallel-computing.html#並列コンピューティング-1">並列コンピューティング</a>のトピックで議論します。</p><p>　`<a href="manual/　### Core task operations"></a></p><h3><a class="nav-anchor" id="コアタスク処理-1" href="#コアタスク処理-1">コアタスク処理</a></h3><!--
Let us explore the low level construct [`yieldto`](@ref) to understand how task switching works.
`yieldto(task,value)` suspends the current task, switches to the specified `task`, and causes
that task's last [`yieldto`](@ref) call to return the specified `value`. Notice that [`yieldto`](@ref)
is the only operation required to use task-style control flow; instead of calling and returning
we are always just switching to a different task. This is why this feature is also called "symmetric
coroutines"; each task is switched to and from using the same mechanism.
--><p>タスクの切り替える方法について理解するために、低レベル関数の<a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>を探索してみましょう。 <code>yieldto(task,value)</code>は現在のタスクを中断し、指定した<code>task</code>に切り替えます。 そして、タスクの最後の<a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>呼び出しに対して、指定した<code>value</code>を返します。 <a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>だけがタスク型の制御フローに唯一必要な操作だということに注意してください。 関数を呼び出したり、値を返したりする代わりに、タスクを別のものに切り替えているだけです。 これはこの機能が「対象コルーチン」と呼ばれる理由です。 それぞれのタスクの切替が全く同じ仕組みを使っているからです。</p><!--
[`yieldto`](@ref) is powerful, but most uses of tasks do not invoke it directly. Consider why
this might be. If you switch away from the current task, you will probably want to switch back
to it at some point, but knowing when to switch back, and knowing which task has the responsibility
of switching back, can require considerable coordination. For example, [`put!`](@ref) and [`take!`](@ref)
are blocking operations, which, when used in the context of channels maintain state to remember
who the consumers are. Not needing to manually keep track of the consuming task is what makes [`put!`](@ref)
easier to use than the low-level [`yieldto`](@ref).
--><p><a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>は強力ですが、たいていは直接呼び出されることはありません。これはなぜなのか、考えてみましょう。 現時点のタスクを中断する場合、おそらくいつか再開するでしょうが、それがいつで、再開に対して責任を持つタスクがどれなのかを知るには、 相当な調整が必要になるでしょう。 例えば<a href="../stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}"><code>put!</code></a>や<a href="../stdlib/Distributed.html#Base.take!-Tuple{RemoteChannel,Vararg{Any,N} where N}"><code>take!</code></a>は他を中断する操作ですが、チャネルと共に使う場合は、状態を保持して、誰がが消費者なのかを覚えます。 手動で消費者タスクを追跡する必要がないため、<a href="../stdlib/Distributed.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}"><code>put!</code></a>は低レベルの<a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>よりも使いやすくなっています。</p><!--
In addition to [`yieldto`](@ref), a few other basic functions are needed to use tasks effectively.

  * [`current_task`](@ref) gets a reference to the currently-running task.
  * [`istaskdone`](@ref) queries whether a task has exited.
  * [`istaskstarted`](@ref) queries whether a task has run yet.
  * [`task_local_storage`](@ref) manipulates a key-value store specific to the current task.
--><p><a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>の他に、タスクを効率的に使うために必要な基本的な別の関数がいくつかあります。</p><ul><li><a href="../base/parallel.html#Base.current_task"><code>current_task</code></a> 現在実行しているタスクへの参照を取得します。</li><li><a href="../base/parallel.html#Base.istaskdone"><code>istaskdone</code></a> タスクが終了しているかどうか問い合わせをします。</li><li><a href="../base/parallel.html#Base.istaskstarted"><code>istaskstarted</code></a> タスクがまだ実行中かどうか問い合わせをします。</li><li><a href="../base/parallel.html#Base.task_local_storage-Tuple{Any}"><code>task_local_storage</code></a> 現在のタスクに固有の、キーバリューの保存を操作します。</li></ul><p>`<a href="### Tasks and events"></a></p><h3><a class="nav-anchor" id="タスクとイベント-1" href="#タスクとイベント-1">タスクとイベント</a></h3><!--
Most task switches occur as a result of waiting for events such as I/O requests, and are performed
by a scheduler included in Julia Base. The scheduler maintains a queue of runnable tasks,
and executes an event loop that restarts tasks based on external events such as message arrival.

The basic function for waiting for an event is [`wait`](@ref). Several objects implement [`wait`](@ref);
for example, given a `Process` object, [`wait`](@ref) will wait for it to exit. [`wait`](@ref)
is often implicit; for example, a [`wait`](@ref) can happen inside a call to [`read`](@ref)
to wait for data to be available.
--><p>ほとんどのタスクの切替はI/O要求などのイベントを待機した結果として発生し、 JuliaのBaseライブラリに含まれるスケジューラによって実行されます。 スケジューラは実行可能なタスクのキューを保持し、イベントループを実行します。 このイベントループは、メッセージの到着など、外部のイベントに基づいてタスクを再開します。 イベントを待機する基本的な関数は<a href="../stdlib/Distributed.html#Base.wait"><code>wait</code></a>です。 オブジェクトの中には<a href="../stdlib/Distributed.html#Base.wait"><code>wait</code></a>が実装されているものがいくつかあります。 例えば、<code>Process</code>オブジェクトの場合は、 <a href="../stdlib/Distributed.html#Base.wait"><code>wait</code></a>は終了まで待機します。  <a href="../stdlib/Distributed.html#Base.wait"><code>wait</code></a>暗黙裏に使われることもあります。  例えば、<a href="../base/io-network.html#Base.read"><code>read</code></a>を呼び出した際に、データが利用可能になるまで待機するために内部的に使うことがあります。</p><!--
In all of these cases, [`wait`](@ref) ultimately operates on a [`Condition`](@ref) object, which
is in charge of queueing and restarting tasks. When a task calls [`wait`](@ref) on a [`Condition`](@ref),
the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler.
The scheduler will then pick another task to run, or block waiting for external events. If all
goes well, eventually an event handler will call [`notify`](@ref) on the condition, which causes
tasks waiting for that condition to become runnable again.

A task created explicitly by calling [`Task`](@ref) is initially not known to the scheduler. This
allows you to manage tasks manually using [`yieldto`](@ref) if you wish. However, when such
a task waits for an event, it still gets restarted automatically when the event happens, as you
would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily
waiting for any events. This is done by calling [`schedule`](@ref), or using the [`@async`](@ref)
macro (see [Parallel Computing](@ref) for more details).
--><p>これらの場合すべてで、 <a href="../stdlib/Distributed.html#Base.wait"><code>wait</code></a>は最終的に<a href="../base/parallel.html#Base.Condition"><code>Condition</code></a>オブジェクトに作用します。 このオブジェクトはタスクのキューの管理とタスクの再開に対する責務を負っています。 タスクが<a href="../base/parallel.html#Base.Condition"><code>Condition</code></a>に作用する<a href="../stdlib/Distributed.html#Base.wait"><code>wait</code></a>を呼び出すと、 タスクは非実行可能とマークされ、状態のキューに加えられ、スケジューラに切り替わります。 スケジューラは別のタスクを実行したり、外部イベントに対して待機するためにブロックしたりします。 すべてうまくいくと、最終的に、イベントハンドラは状態に作用する <a href="../base/parallel.html#Base.notify"><code>notify</code></a> を呼び出し、 その結果、待機状態だったタスクが再び実行可能となります。</p><p><a href="../base/parallel.html#Core.Task"><code>Task</code></a>を呼び出して明示的に生成したタスクは、始めはスケジューラに認識されていません。  このため、望むのであれば、<a href="../base/parallel.html#Base.yieldto"><code>yieldto</code></a>を使って手動でタスクを管理することも可能です。  しかし、イベントを待機するタスクは、予測されるように、イベントが発生すると自動的に再開します。  また、どんなイベントも待つことなく、可能な場合はいつでも、スケジューラがタスクを実行するようにもできます。 これは、 <a href="../base/parallel.html#Base.schedule"><code>schedule</code></a>を呼び出したり、 <a href="../stdlib/Distributed.html#Base.@async"><code>@async</code></a>マクロを使うことで可能です。 （詳細は<a href="parallel-computing.html#並列コンピューティング-1">並列コンピューティング</a>を参照）</p><p>`<a href="### Task states"></a></p><h3><a class="nav-anchor" id="タスクの状態-1" href="#タスクの状態-1">タスクの状態</a></h3><!--
Tasks have a `state` field that describes their execution status. A [`Task`](@ref) `state` is one of the following
symbols:
--><p>タスクには実行状態を示す<code>state</code>フィールドがあります。 <a href="../base/parallel.html#Core.Task"><code>Task</code></a>の<code>state</code>は以下のシンボルのいずれかです。</p><!--
| Symbol      | Meaning                                            |
|:----------- |:-------------------------------------------------- |
| `:runnable` | Currently running, or available to be switched to  |
| `:waiting`  | Blocked waiting for a specific event               |
| `:queued`   | In the scheduler's run queue about to be restarted |
| `:done`     | Successfully finished executing                    |
| `:failed`   | Finished with an uncaught exception                |
--><table><tr><th>シンボル</th><th>意味</th></tr><tr><td><code>:runnable</code></td><td>現在実行中、または切替可能</td></tr><tr><td><code>:waiting</code></td><td>特定のイベントを待機しているためブロックされている</td></tr><tr><td><code>:queued</code></td><td>スケジューラの実行キューにあり、再開しようとしている</td></tr><tr><td><code>:done</code></td><td>実行が正常終了</td></tr><tr><td><code>:failed</code></td><td>例外が捕捉されないまま終了</td></tr></table><footer><hr/><a class="previous" href="functions.html"><span class="direction">Previous</span><span class="title">関数</span></a><a class="next" href="variables-and-scoping.html"><span class="direction">Next</span><span class="title">変数のスコープ</span></a></footer></article></body></html>
