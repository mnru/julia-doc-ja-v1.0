<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>メソッド · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125166476-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">始めよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li><a class="toctext" href="types.html">型</a></li><li class="current"><a class="toctext" href="methods.html">メソッド</a><ul class="internal"><li><a class="toctext" href="#メソッドの定義-1">メソッドの定義</a></li><li><a class="toctext" href="#man-ambiguities-1">メソッドの曖昧さ</a></li><li><a class="toctext" href="#パラメータメソッド-1">パラメータメソッド</a></li><li><a class="toctext" href="#メソッドの再定義-1">メソッドの再定義</a></li><li><a class="toctext" href="#パラメータメソッドのデザインパターン-1">パラメータメソッドのデザインパターン</a></li><li><a class="toctext" href="#パラメータ制限つきの可変引数メソッド-1">パラメータ制限つきの可変引数メソッド</a></li><li><a class="toctext" href="#オプション引数・キーワード引数に関する注記-1">オプション引数・キーワード引数に関する注記</a></li><li><a class="toctext" href="#関数的なオブジェクト-1">関数的なオブジェクト</a></li><li><a class="toctext" href="#空の汎化関数-1">空の汎化関数</a></li><li><a class="toctext" href="#man-method-design-ambiguities-1">メソッドの設計と曖昧さの回避</a></li></ul></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="methods.html">メソッド</a></li></ul><a class="edit-page" href="https://github.com/mnru/julia-doc-ja-v1.0-source/blob/master/src/manual/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>メソッド</span><a class="fa fa-bars" href="#"></a></div></header><p>`<a href="# Methods"></a></p><h1><a class="nav-anchor" id="メソッド-1" href="#メソッド-1">メソッド</a></h1><!--
Recall from [Functions](@ref man-functions) that a function is an object that maps a tuple of arguments to a
return value, or throws an exception if no appropriate value can be returned. It is common for
the same conceptual function or operation to be implemented quite differently for different types
of arguments: adding two integers is very different from adding two floating-point numbers, both
of which are distinct from adding an integer to a floating-point number. Despite their implementation
differences, these operations all fall under the general concept of "addition". Accordingly, in
Julia, these behaviors all belong to a single object: the `+` function.
--><p><a href="functions.html#man-functions-1">関数</a> の章を思い出してください。関数とは、引数のタプルを受け取り、戻り値を返す、または適切な値が返せない場合は例外を投げる、オブジェクトです。 概念的には等しい関数や演算が、引数の型によって実装がまったく異なる、ということはよくあります。 2つの整数を足すことと、2つの浮動小数点数を足すことは、全く異なるし、整数に浮動小数点数を足すこととも異なります。 実装が違っていても、これらの操作はすべて、一般的な概念の「足し算」に当てはまります。 したがって、Juliaでは、これらの挙動はすべて1つのオブジェクト「<code>+</code>関数」に属します。</p><!--
To facilitate using many different implementations of the same concept smoothly, functions need
not be defined all at once, but can rather be defined piecewise by providing specific behaviors
for certain combinations of argument types and counts. A definition of one possible behavior for
a function is called a *method*. Thus far, we have presented only examples of functions defined
with a single method, applicable to all types of arguments. However, the signatures of method
definitions can be annotated to indicate the types of arguments in addition to their number, and
more than a single method definition may be provided. When a function is applied to a particular
tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the
overall behavior of a function is a patchwork of the behaviors of its various method definitions.
If the patchwork is well designed, even though the implementations of the methods may be quite
different, the outward behavior of the function will appear seamless and consistent.
--><p>同じ概念の異なる多くの実装を、円滑に利用するためには、関数すべてを一度に定義する必要はなくて、引数の型と個数の組み合わせごとに、特定の動作を指定して、区分的に定義できます。 こうした関数の、とるかもしれない１つの動作の定義は、<strong>メソッド</strong> と呼ばれます。 ここまでで例示した関数は、単一のメソッドで定義されたものだけで、すべての型の引数に適用可能です。 しかし、メソッド定義のシグネチャに、型注釈をつけると、引数の型と数を指定でき、複数のメソッド定義を与えることができます。 関数が特定の引数の組に適用されるとき、それらの引数に適用可能なものから最も特化したメソッドが適用されます。 したがって、関数の全体的な動作は、さまざまなメソッド定義の動作のパッチワークです。 パッチワークがうまく設計されていれば、メソッドの実装がかなり異なっていても、外側からは関数の動作は継ぎ目なく一貫しているように見えます。</p><!--
The choice of which method to execute when a function is applied is called *dispatch*. Julia allows
the dispatch process to choose which of a function's methods to call based on the number of arguments
given, and on the types of all of the function's arguments. This is different than traditional
object-oriented languages, where dispatch occurs based only on the first argument, which often
has a special argument syntax, and is sometimes implied rather than explicitly written as an argument.
[^1] Using all of a function's arguments to choose which method should be invoked, rather than
just the first, is known as [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch).
Multiple dispatch is particularly useful for mathematical code, where it makes little sense to
artificially deem the operations to "belong" to one argument more than any of the others: does
the addition operation in `x + y` belong to `x` any more than it does to `y`? The implementation
of a mathematical operator generally depends on the types of all of its arguments. Even beyond
mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm
for structuring and organizing programs.
--><p>実行するメソッドを、関数が適用される際に選択することを、 <strong>ディスパッチ</strong> と呼ばれます。 Juliaでは、ディスパッチの過程で、関数のメソッドのどれを呼び出すか、関数のすべての引数の型と個数に基づいて、選択できます。 これは、従来のオブジェクト指向言語とは異なります。従来のオブジェクト指向言語では、通常は最初の引数のみに基づいてディスパッチが行われ、最初の引数を特別視して引数に見えないような構文を持つものもあります。</p><!--
[^1]:
    In C++ or Java, for example, in a method call like `obj.meth(arg1,arg2)`, the object obj "receives"
    the method call and is implicitly passed to the method via the `this` keyword, rather than as
    an explicit method argument. When the current `this` object is the receiver of a method call,
    it can be omitted altogether, writing just `meth(arg1,arg2)`, with `this` implied as the receiving
    object.

--><p>[^ 1] 関数の、最初の引数だけではなく、すべての引数を使用して、呼び出すメソッドを選択することは、<a href="https://en.wikipedia.org/wiki/">多重ディスパッチ</a>として知られています。 多重ディスパッチは特に数学のコードで有用です。演算がどの引数に、より「属している」かと不自然なことを考えても、意味がないからです。<code>x + y</code> の式の中の足し算は、 <code>x</code> に <code>y</code>よりも属してると思いますか？ 数学的演算子の実装は、一般には、すべての引数の型に依存しています。 しかし、数学的な操作以外でも、多重ディスパッチは、プログラムの構築し組織化する強力で便利なパラダイムです。</p><p>`<a href="## Defining Methods"></a></p><h2><a class="nav-anchor" id="メソッドの定義-1" href="#メソッドの定義-1">メソッドの定義</a></h2><!--
Until now, we have, in our examples, defined only functions with a single method having unconstrained
argument types. Such functions behave just like they would in traditional dynamically typed languages.
Nevertheless, we have used multiple dispatch and methods almost continually without being aware
of it: all of Julia's standard functions and operators, like the aforementioned `+` function,
have many methods defining their behavior over various possible combinations of argument type
and count.

When defining a function, one can optionally constrain the types of parameters it is applicable
to, using the `::` type-assertion operator, introduced in the section on [Composite Types](@ref):
--><p>今までの例では、引数に型の制約がない、単一のメソッドしかない関数しか定義していませんでした。 そのような関数は、従来の動的型付け言語と同じように動作します。 にもかかわらず、私たちは知らない間に、ほぼ断続的に多重ディスパッチとメソッドを使用してきました。 前述の<code>+</code>関数のような、Juliaの標準的な関数と演算子はすべて、多くのメソッドを持ち、引数の型と個数のさまざまな組み合わせに対して動作が定義されています。</p><p>関数を定義するときには、必要に応じて、<a href="types.html#複合型-1">複合型</a>に関するセクションで紹介した<code>::</code>型表明演算子を使って、適用可能なパラメータの型を、制限することができます。</p><pre><code class="language-julia-repl">julia&gt; f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)</code></pre><!--
This function definition applies only to calls where `x` and `y` are both values of type
[`Float64`](@ref):
--><p>関数を定義するときには、必要に応じて、<a href="types.html#複合型-1">複合型</a>に関するセクションで紹介した<code>::</code>型表明演算子を使って、適用可能なパラメータの型を、制限することができます。</p><pre><code class="language-julia-repl">julia&gt; f(2.0, 3.0)
7.0</code></pre><!--
Applying it to any other types of arguments will result in a [`MethodError`](@ref):
--><p>この関数定義を他の型の引数に適用すると、次のような<a href="../base/base.html#Core.MethodError"><code>MethodError</code></a>になります。</p><pre><code class="language-julia-repl">julia&gt; f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia&gt; f(2.0, &quot;3.0&quot;)
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f(&quot;2.0&quot;, &quot;3.0&quot;)
ERROR: MethodError: no method matching f(::String, ::String)</code></pre><!--
As you can see, the arguments must be precisely of type [`Float64`](@ref). Other numeric
types, such as integers or 32-bit floating-point values, are not automatically converted
to 64-bit floating-point, nor are strings parsed as numbers. Because `Float64` is a concrete
type and concrete types cannot be subclassed in Julia, such a definition can only be applied
to arguments that are exactly of type `Float64`. It may often be useful, however, to write
more general methods where the declared parameter types are abstract:
--><p>これを見て分かるように、引数はちょうど<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>型でなければなりません。 他の整数や32ビット浮動小数点数などの数値型は、自動的に64ビット浮動小数点数に変換されず、文字列も数字として解析されません。 <code>Float64</code>は具象型で、具象型はJuliaでは、サブクラス化できないので、このような定義はちょうど型が<code>Float64</code>の引数のみに適用ができます。 しかし、宣言するパラメータの型が抽象的な、汎化メソッドを書くと、けっこう役に立つかもしれません。</p><pre><code class="language-julia-repl">julia&gt; f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia&gt; f(2.0, 3)
1.0</code></pre><!--
This method definition applies to any pair of arguments that are instances of [`Number`](@ref).
They need not be of the same type, so long as they are each numeric values. The problem of
handling disparate numeric types is delegated to the arithmetic operations in the
expression `2x - y`.

To define a function with multiple methods, one simply defines the function multiple times, with
different numbers and types of arguments. The first method definition for a function creates the
function object, and subsequent method definitions add new methods to the existing function object.
The most specific method definition matching the number and types of the arguments will be executed
when the function is applied. Thus, the two method definitions above, taken together, define the
behavior for `f` over all pairs of instances of the abstract type `Number` -- but with a different
behavior specific to pairs of [`Float64`](@ref) values. If one of the arguments is a 64-bit
float but the other one is not, then the `f(Float64,Float64)` method cannot be called and
the more general `f(Number,Number)` method must be used:
--><p>このメソッド定義は<a href="../base/numbers.html#Core.Number"><code>Number</code></a>のインスタンスである任意の引数のペアに適用されます。 それらがそれぞれ数値である限り、同じ型である必要はありません。 異なる数値型を処理する問題は、式<code>2x - y</code>の算術演算に委譲されます。</p><p>複数のメソッドを持つ関数を定義するには、単に複数回の関数の定義を、数と型の異なる引数に対して、行うだけです。 最初のメソッド定義では、関数オブジェクトを作成され、次回以降のメソッド定義では、既存の関数オブジェクトに新しいメソッドが追加されます。 関数の適用時に、引数の数と型が最も一致するメソッド定義が実行されます。 したがって、上の2つのメソッド定義が一緒になって、抽象型<code>Number</code>のインスタンスのペアすべてに対して<code>f</code>の動作を定義しますが、値<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>のペアに固有の動作は異なります。 引数の1つが64ビット浮動小数点数で、もう1つがそうでない場合、この<code>f(Float64,Float64)</code>メソッドは呼び出すことができず、より一般的な<code>f(Number,Number)</code>メソッドを使用する必要があります。</p><pre><code class="language-julia-repl">julia&gt; f(2.0, 3.0)
7.0

julia&gt; f(2, 3.0)
1.0

julia&gt; f(2.0, 3)
1.0

julia&gt; f(2, 3)
1</code></pre><!--
The `2x + y` definition is only used in the first case, while the `2x - y` definition is used
in the others. No automatic casting or conversion of function arguments is ever performed: all
conversion in Julia is non-magical and completely explicit. [Conversion and Promotion](@ref conversion-and-promotion),
however, shows how clever application of sufficiently advanced technology can be indistinguishable
from magic. [^Clarke61]

For non-numeric values, and for fewer or more than two arguments, the function `f` remains undefined,
and applying it will still result in a [`MethodError`](@ref):
--><p><code>2x + y</code>という定義は、最初の場合にだけ使われていますが、<code>2x - y</code>という定義が、その他では使われています。 関数の引数の自動キャストや変換は一度も実行されません。 Juliaでは、すべての変換は魔法ではなく完全に明示的です。 しかし、[Conversion and Promotion]（@ ref conversion-and-promotion）では、十分に高度な技術をうまく使うと、魔法と区別できないほどになることを示しています。[^ Clarke61]</p><p>数値以外の値や2つ以上の引数の場合、関数<code>f</code>は未定義のままであり、そのまま適用すると次のように<a href="../base/base.html#Core.MethodError"><code>MethodError</code></a>がおこります。</p><pre><code class="language-julia-repl">julia&gt; f(&quot;foo&quot;, 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia&gt; f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1</code></pre><!--
You can easily see which methods exist for a function by entering the function object itself in
an interactive session:
--><p>対話セッションで関数オブジェクト自体を入力すると、関数にどんなメソッドが存在するかを簡単に確認できます。</p><pre><code class="language-julia-repl">julia&gt; f
f (generic function with 2 methods)</code></pre><!--
This output tells us that `f` is a function object with two methods. To find out what the signatures
of those methods are, use the [`methods`](@ref) function:
--><p>この出力は、<code>f</code>が2つのメソッドを持つ関数オブジェクトであることを示しています。 これらのメソッドのシグネチャを調べるには、<a href="../base/base.html#Base.methods"><code>methods()</code></a>関数を使用します。</p><pre><code class="language-julia-repl">julia&gt; methods(f)
# 2 methods for generic function &quot;f&quot;:
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1</code></pre><!--
which shows that `f` has two methods, one taking two `Float64` arguments and one taking arguments
of type `Number`. It also indicates the file and line number where the methods were defined: because
these methods were defined at the REPL, we get the apparent line number `none:1`.

In the absence of a type declaration with `::`, the type of a method parameter is `Any` by default,
meaning that it is unconstrained since all values in Julia are instances of the abstract type
`Any`. Thus, we can define a catch-all method for `f` like so:
--><p>すると表示されるのは、<code>f</code>が二つのメソッドを持っていて、一方は2つの<code>Float64</code>の引数を取り、他方は型が<code>Number</code>の引数を取ることです。 また、メソッドが定義されたファイルと行番号も表示されます。 これらのメソッドはREPLで定義されているため、見かけの行番号<code>none:1</code>が表示されます。</p><p><code>::</code>による型宣言がない場合、メソッドのパラメータの型はデフォルトでは<code>Any</code>であり、Juliaのすべての値が抽象型<code>Any</code>のインスタンスであるため、制約がないことを意味しています 。 したがって、<code>f</code>の全捕捉メソッドを以下のように定義することができます。</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = println(&quot;Whoa there, Nelly.&quot;)
f (generic function with 3 methods)

julia&gt; f(&quot;foo&quot;, 1)
Whoa there, Nelly.</code></pre><!--
This catch-all is less specific than any other possible method definition for a pair of parameter
values, so it will only be called on pairs of arguments to which no other method definition applies.

Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single
most powerful and central feature of the Julia language. Core operations typically have dozens
of methods:
--><p>この全捕捉は、どの引数のペアに対する他のメソッド定義よりも特化していないため、他のメソッド定義が適用されない引数のペアに対してのみ呼び出されます。</p><p>単純な考え方のように見えますが、値型に対する多重ディスパッチは、おそらくJulia言語の最も強力で中心的な機能です。中心となる演算には通常数十種類のメソッドがあります。</p><pre><code class="language-julia-repl">julia&gt; methods(+)
# 180 methods for generic function &quot;+&quot;:
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T&lt;:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424</code></pre><!--
Multiple dispatch together with the flexible parametric type system give Julia its ability to
abstractly express high-level algorithms decoupled from implementation details, yet generate efficient,
specialized code to handle each case at run time.
--><p>多重ディスパッチと柔軟なパラメトリック型システムによって、Juliaに与えられた能力は、高水準のアルゴリズムを抽象的に表現して、実装の詳細から切り離し、実行時に各ケースに特化して処理する効率的なコードを生成することです。</p><p>`<a href="## [Method Ambiguities](@id man-ambiguities)"></a></p><h2><a class="nav-anchor" id="man-ambiguities-1" href="#man-ambiguities-1">メソッドの曖昧さ</a></h2><!--
It is possible to define a set of function methods such that there is no unique most specific
method applicable to some combinations of arguments:
--><p>ある種の引数の組み合わせに対しては、最も特化するメソッドが一意に定まらない、関数メソッドの組み合わせに、定義がなってしまう可能性があります。</p><pre><code class="language-julia-repl">julia&gt; g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia&gt; g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:
  g(x, y::Float64) in Main at none:1
  g(x::Float64, y) in Main at none:1
Possible fix, define
  g(::Float64, ::Float64)</code></pre><!--
Here the call `g(2.0, 3.0)` could be handled by either the `g(Float64, Any)` or the `g(Any, Float64)`
method, and neither is more specific than the other. In such cases, Julia raises a [`MethodError`](@ref)
rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate
method for the intersection case:
--><p>ここでの関数呼び出し<code>g(2.0, 3.0)</code>は、<code>g(Float64, Any)</code>と<code>g(Any, Float64)</code> のメソッドによって処理可能ですが、どちらがより特化しているかは決められません。 このような場合、Juliaは勝手にメソッドを選択せずに、<a href="../base/base.html#Core.MethodError"><code>MethodError</code></a>を発生させます。  共通する場合に特化したメソッドを指定することで、メソッドの曖昧さをなくすことができます。</p><pre><code class="language-julia-repl">julia&gt; g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
10.0</code></pre><!--
It is recommended that the disambiguating method be defined first, since otherwise the ambiguity
exists, if transiently, until the more specific method is defined.

In more complex cases, resolving method ambiguities involves a certain
element of design; this topic is explored further [below](@ref man-method-design-ambiguities).
--><p>曖昧さのないメソッドを最初に定義することが推奨されます。というのも、一時的にせよ、より特化したメソッドが定義されるまで、曖昧さが残るからです。</p><p>より複雑なケースでは、メソッドの曖昧さを解決するには一定の設計要素が必要になります。この話題は[below]（@ ref man-method-design-ambiguities）をさらに詳しく解説しています。</p><p>`<a href="## Parametric Methods"></a></p><h2><a class="nav-anchor" id="パラメータメソッド-1" href="#パラメータメソッド-1">パラメータメソッド</a></h2><!--
Method definitions can optionally have type parameters qualifying the signature:
--><p>メソッド定義で、任意で型パラメータをつけて、シグネチャを細かく指定することができます。</p><pre><code class="language-julia-repl">julia&gt; same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia&gt; same_type(x,y) = false
same_type (generic function with 2 methods)</code></pre><!--
The first method applies whenever both arguments are of the same concrete type, regardless of
what type that is, while the second method acts as a catch-all, covering all other cases. Thus,
overall, this defines a boolean function that checks whether its two arguments are of the same
type:
--><p>第1のメソッドは、両方の引数が同じ具象型であれば、どんな型であれ適用されます。第2のメソッドは他のすべての場合に渡る全捕捉として働きます。 したがって、これは全体として、2つの引数が同じ型であるかどうかを検査するブール関数の定義になっています。</p><pre><code class="language-julia-repl">julia&gt; same_type(1, 2)
true

julia&gt; same_type(1, 2.0)
false

julia&gt; same_type(1.0, 2.0)
true

julia&gt; same_type(&quot;foo&quot;, 2.0)
false

julia&gt; same_type(&quot;foo&quot;, &quot;bar&quot;)
true

julia&gt; same_type(Int32(1), Int64(2))
false</code></pre><!--
Such definitions correspond to methods whose type signatures are `UnionAll` types
(see [UnionAll Types](@ref)).

This kind of definition of function behavior by dispatch is quite common -- idiomatic, even --
in Julia. Method type parameters are not restricted to being used as the types of arguments:
they can be used anywhere a value would be in the signature of the function or body of the function.
Here's an example where the method type parameter `T` is used as the type parameter to the parametric
type `Vector{T}` in the method signature:
--><p>そのような定義はシグネチャがUnionAll型であるメソッドに対応します(<a href="types.html#全合併型-1">全合併型</a> 参照)。</p><p>Juliaでは、このようにディスパッチを使って関数の動作を定義するのは、まったく普通であって、慣用的でさえあります。メソッドの型パラメータは、引数の型として使えるだけでなく、関数の本体または関数のシグネチャの、値がある場所であればどこでも使えます。メソッドの型パラメータ<code>T</code>が、メソッドのシグネチャのパラメトリック型に対する型パラメータ<code>Vector{T}</code>として使用される例を次に示します。</p><pre><code class="language-julia-repl">julia&gt; myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia&gt; myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia&gt; myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia&gt; myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1</code></pre><!--
As you can see, the type of the appended element must match the element type of the vector it
is appended to, or else a [`MethodError`](@ref) is raised. In the following example, the method type parameter
`T` is used as the return value:
--><p>ご覧のように、追加する要素の型は、追加されるベクトルの要素の型と一致しなければなりません。でなければ、<a href="../base/base.html#Core.MethodError"><code>MethodError</code></a> が生成されます。 次の例では、メソッドの型パラメータ <code>T</code>が戻り値として使用されています。</p><pre><code class="language-julia-repl">julia&gt; mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia&gt; mytypeof(1)
Int64

julia&gt; mytypeof(1.0)
Float64</code></pre><!--
Just as you can put subtype constraints on type parameters in type declarations (see [Parametric Types](@ref)),
you can also constrain type parameters of methods:
--><p>型宣言（<a href="manual/@ref">パラメトリック型</a>型を参照）に出てくる型パラメータにサブタイプ制約を付加できるのと同様に、メソッドの型パラメータも制約することができます。</p><pre><code class="language-julia-repl">julia&gt; same_type_numeric(x::T, y::T) where {T&lt;:Number} = true
same_type_numeric (generic function with 1 method)

julia&gt; same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia&gt; same_type_numeric(1, 2)
true

julia&gt; same_type_numeric(1, 2.0)
false

julia&gt; same_type_numeric(1.0, 2.0)
true

julia&gt; same_type_numeric(&quot;foo&quot;, 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T&lt;:Number, ::T&lt;:Number) where T&lt;:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia&gt; same_type_numeric(&quot;foo&quot;, &quot;bar&quot;)
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia&gt; same_type_numeric(Int32(1), Int64(2))
false</code></pre><!--
The `same_type_numeric` function behaves much like the `same_type` function defined above, but
is only defined for pairs of numbers.

Parametric methods allow the same syntax as `where` expressions used to write types
(see [UnionAll Types](@ref)).
If there is only a single parameter, the enclosing curly braces (in `where {T}`) can be omitted,
but are often preferred for clarity.
Multiple parameters can be separated with commas, e.g. `where {T, S<:Real}`, or written using
nested `where`, e.g. `where S<:Real where T`.
--><p>この<code>same_type_numeric</code>関数は、以前に定義した関数<code>same_type</code>と非常によく似た動作をしますが、数値の組に対してのみ定義されています。</p><p>パラメトリックメソッドでは、型の作成に使用される<code>where</code>式と同じ構文を使用できます（<a href="types.html#全合併型-1">全合併型</a>を参照）。パラメータが1つしかない場合は、中括弧（<code>where {T}</code>）を省略することができますが、わかりやくするために、よく好んでつけられます。複数のパラメータは、例えば、カンマで区切ったり(例<code>where {T, S&lt;:Real}</code>)、またはネストされた<code>where</code>を使ったりして記述されます。（例<code>where S&lt;:Real where T</code>）</p><!--
Redefining Methods
------------------
--><h2><a class="nav-anchor" id="メソッドの再定義-1" href="#メソッドの再定義-1">メソッドの再定義</a></h2><!--
When redefining a method or adding new methods,
it is important to realize that these changes don't take effect immediately.
This is key to Julia's ability to statically infer and compile code to run fast,
without the usual JIT tricks and overhead.
Indeed, any new method definition won't be visible to the current runtime environment,
including Tasks and Threads (and any previously defined `@generated` functions).
Let's start with an example to see what this means:
--><p>メソッドの再定義や、新しいメソッドの追加は、その変更が即座に反映されない、という認識は重要です。 これは、Juliaが静的にコードを推論しコンパイルする際に、通常のJITトリックやオーバーヘッドがなくてすむ鍵となります。 実際、新しいメソッド定義は、タスクおよびスレッド（およびそれ以前に定義された@generated関数）を含め、現在の実行時環境ではまったく見えません。 これが何を意味するかを例をあげて見てみましょう。</p><pre><code class="language-julia-repl">julia&gt; function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia&gt; tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia&gt; newfun()
1</code></pre><!--
In this example, observe that the new definition for `newfun` has been created,
but can't be immediately called.
The new global is immediately visible to the `tryeval` function,
so you could write `return newfun` (without parentheses).
But neither you, nor any of your callers, nor the functions they call, or etc.
can call this new method definition!
--><p>メソッドの再定義や、新しいメソッドの追加は、その変更が即座に反映されない、という認識は重要です。 これは、Juliaが静的にコードを推論しコンパイルする際に、通常のJITトリックやオーバーヘッドがなくてすむ鍵となります。 実際、新しいメソッド定義は、タスクおよびスレッド（およびそれ以前に定義された@generated関数）を含め、現在の実行時環境ではまったく見えません。 これが何を意味するかを例をあげて見てみましょう。</p><!--
But there's an exception: future calls to `newfun` *from the REPL* work as expected,
being able to both see and call the new definition of `newfun`.

However, future calls to `tryeval` will continue to see the definition of `newfun` as it was
*at the previous statement at the REPL*, and thus before that call to `tryeval`.

You may want to try this for yourself to see how it works.
--><p>しかし、例外はあります。<code>newfun</code>への <strong>REPLからの</strong>今後の呼び出しは、期待通りに動作し、<code>newfun</code>の新しい定義を参照して呼び出すことができます。</p><p>しかし、<code>tryeval</code>への今後の呼び出しが、参照し続ける<code>newfun</code>の定義は、次回<code>tryeval</code>を呼び出すまでは<strong>REPLで前回行った</strong>ものです。前回の<code>tryeval</code>の呼び出しも同様だったのです。</p><p>これがどのように動作するかを見るために自身で試してみたいと思うかもしれません。</p><!--
The implementation of this behavior is a "world age counter".
This monotonically increasing value tracks each method definition operation.
This allows describing "the set of method definitions visible to a given runtime environment"
as a single number, or "world age".
It also allows comparing the methods available in two worlds just by comparing their ordinal value.
In the example above, we see that the "current world" (in which the method `newfun` exists),
is one greater than the task-local "runtime world" that was fixed when the execution of `tryeval` started.

Sometimes it is necessary to get around this (for example, if you are implementing the above REPL).
Fortunately, there is an easy solution: call the function using [`Base.invokelatest`](@ref):
--><p>この行動の実装は「世界の世代のカウンター」です。 この単調に増加する値は、各メソッド定義の操作を追跡します。 これにより、「実行時環境から見えるメソッド定義の集合」を、単一の数値「世界世代」として記述することができます。 また、世代を比較するだけで、2つの世界で利用できるメソッドを比較することもできます。 上記の例では、メソッド<code>newfun()</code>が存在する「現在の世界」が、<code>tryeval</code>開始時に設定されたタスクローカルの「実行時の世界」よりも１つ大きいことがわかります。</p><p>場合によってはこれを回避する必要があります（たとえば、上記のREPLを実装している場合など）。 幸いにも、簡単な解決策があって、<a href="../base/base.html#Base.invokelatest"><code>Base.invokelatest</code></a>を使って関数を呼び出せば、いいのです。</p><pre><code class="language-julia-repl">julia&gt; function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia&gt; tryeval2()
2</code></pre><!--
Finally, let's take a look at some more complex examples where this rule comes into play.
Define a function `f(x)`, which initially has one method:
--><p>最後に、このルールが適用されるより複雑な例を、いくつか見てみましょう。最初は1つのメソッドを持つ関数<code>f(x)</code>を定義します。</p><pre><code class="language-julia-repl">julia&gt; f(x) = &quot;original definition&quot;
f (generic function with 1 method)</code></pre><!--
Start some other operations that use `f(x)`:
--><p>他の<code>f(x)</code>を使う操作を開始します。</p><pre><code class="language-julia-repl">julia&gt; g(x) = f(x)
g (generic function with 1 method)

julia&gt; t = @async f(wait()); yield();</code></pre><!--
Now we add some new methods to `f(x)`:
--><p>ここでいくつかの新しいメソッドを<code>f(x)</code>に追加します。</p><pre><code class="language-julia-repl">julia&gt; f(x::Int) = &quot;definition for Int&quot;
f (generic function with 2 methods)

julia&gt; f(x::Type{Int}) = &quot;definition for Type{Int}&quot;
f (generic function with 3 methods)</code></pre><!--
Compare how these results differ:
--><p>これらの結果がどのように異なるかを比較します。</p><pre><code class="language-julia-repl">julia&gt; f(1)
&quot;definition for Int&quot;

julia&gt; g(1)
&quot;definition for Int&quot;

julia&gt; fetch(schedule(t, 1))
&quot;original definition&quot;

julia&gt; t = @async f(wait()); yield();

julia&gt; fetch(schedule(t, 1))
&quot;definition for Int&quot;</code></pre><p>`<a href="## Design Patterns with Parametric Methods"></a></p><h2><a class="nav-anchor" id="パラメータメソッドのデザインパターン-1" href="#パラメータメソッドのデザインパターン-1">パラメータメソッドのデザインパターン</a></h2><!--
While complex dispatch logic is not required for performance or usability,
sometimes it can be the best way to express some algorithm.
Here are a few common design patterns that come up sometimes when using dispatch in this way.
--><p>`<a href="### Extracting the type parameter from a super-type"></a></p><h3><a class="nav-anchor" id="スーパータイプからの型パラメータの抽出-1" href="#スーパータイプからの型パラメータの抽出-1">スーパータイプからの型パラメータの抽出</a></h3><!--
Here is the correct code template for returning the element-type `T`
of any arbitrary subtype of `AbstractArray`:
--><pre><code class="language-julia">abstract type AbstractArray{T, N} end
eltype(::Type{&lt;:AbstractArray{T}}) where {T} = T</code></pre><!--
using so-called triangular dispatch.  Note that if `T` is a `UnionAll`
type, as e.g. `eltype(Array{T} where T <: Integer)`, then `Any` is
returned (as does the the version of `eltype` in `Base`).

Another way, which used to be the only correct way before the advent of
triangular dispatch in Julia v0.6, is:
--><pre><code class="language-julia">abstract type AbstractArray{T, N} end
eltype(::Type{AbstractArray}) = Any
eltype(::Type{AbstractArray{T}}) where {T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A&lt;:AbstractArray} = eltype(supertype(A))</code></pre><p>Another possibility is the following, which could useful to adapt to cases where the parameter <code>T</code> would need to be matched more narrowly:</p><pre><code class="language-julia">eltype(::Type{AbstractArray{T, N} where {T&lt;:S, N&lt;:M}}) where {M, S} = Any
eltype(::Type{AbstractArray{T, N} where {T&lt;:S}}) where {N, S} = Any
eltype(::Type{AbstractArray{T, N} where {N&lt;:M}}) where {M, T} = T
eltype(::Type{AbstractArray{T, N}}) where {T, N} = T
eltype(::Type{A}) where {A &lt;: AbstractArray} = eltype(supertype(A))</code></pre><!--
One common mistake is to try and get the element-type by using introspection:
--><pre><code class="language-julia">eltype_wrong(::Type{A}) where {A&lt;:AbstractArray} = A.parameters[1]</code></pre><!--
However, it is not hard to construct cases where this will fail:
--><pre><code class="language-julia">struct BitVector &lt;: AbstractArray{Bool, 1}; end</code></pre><!--
Here we have created a type `BitVector` which has no parameters,
but where the element-type is still fully specified, with `T` equal to `Bool`!
--><p>`<a href="### Building a similar type with a different type parameter"></a></p><h3><a class="nav-anchor" id="別の型パラメータに似た型の構成-1" href="#別の型パラメータに似た型の構成-1">別の型パラメータに似た型の構成</a></h3><!--
When building generic code, there is often a need for constructing a similar
object with some change made to the layout of the type, also
necessitating a change of the type parameters.
For instance, you might have some sort of abstract array with an arbitrary element type
and want to write your computation on it with a specific element type.
We must implement a method for each `AbstractArray{T}` subtype that describes how to compute this type transform.
There is no general transform of one subtype into another subtype with a different parameter.
(Quick review: do you see why this is?)
--><!--
The subtypes of `AbstractArray` typically implement two methods to
achieve this:
A method to convert the input array to a subtype of a specific `AbstractArray{T, N}` abstract type;
and a method to make a new uninitialized array with a specific element type.
Sample implementations of these can be found in Julia Base.
Here is a basic example usage of them, guaranteeing that `input` and
`output` are of the same type:
--><pre><code class="language-julia">input = convert(AbstractArray{Eltype}, input)
output = similar(input, Eltype)</code></pre><!--
As an extension of this, in cases where the algorithm needs a copy of
the input array,
[`convert`](@ref) is insufficient as the return value may alias the original input.
Combining [`similar`](@ref) (to make the output array) and [`copyto!`](@ref) (to fill it with the input data)
is a generic way to express the requirement for a mutable copy of the input argument:
--><pre><code class="language-julia">copy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)</code></pre><p>`<a href="### Iterated dispatch"></a></p><h3><a class="nav-anchor" id="ディスパッチの反復-1" href="#ディスパッチの反復-1">ディスパッチの反復</a></h3><!--
In order to dispatch a multi-level parametric argument list,
often it is best to separate each level of dispatch into distinct functions.
This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.

For example, trying to dispatch on the element-type of an array will often run into ambiguous situations.
Instead, commonly code will dispatch first on the container type,
then recurse down to a more specific method based on eltype.
In most cases, the algorithms lend themselves conveniently to this hierarchical approach,
while in other cases, this rigor must be resolved manually.
This dispatching branching can be observed, for example, in the logic to sum two matrices:
--><pre><code class="language-julia"># First dispatch selects the map algorithm for element-wise summation.
+(a::Matrix, b::Matrix) = map(+, a, b)
# Then dispatch handles each element and selects the appropriate
# common element type for the computation.
+(a, b) = +(promote(a, b)...)
# Once the elements have the same type, they can be added.
# For example, via primitive operations exposed by the processor.
+(a::Float64, b::Float64) = Core.add(a, b)</code></pre><p>`<a href="### Trait-based dispatch"></a></p><h3><a class="nav-anchor" id="トレイトに基づくディスパッチ-1" href="#トレイトに基づくディスパッチ-1">トレイトに基づくディスパッチ</a></h3><!--
A natural extension to the iterated dispatch above is to add a layer to
method selection that allows to dispatch on sets of types which are
independent from the sets defined by the type hierarchy.
We could construct such a set by writing out a `Union` of the types in question,
but then this set would not be extensible as `Union`-types cannot be
altered after creation.
However, such an extensible set can be programmed with a design pattern
often referred to as a
["Holy-trait"](https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633).
--><!--
This pattern is implemented by defining a generic function which
computes a different singleton value (or type) for each trait-set to which the
function arguments may belong to.  If this function is pure there is
no impact on performance compared to normal dispatch.

The example in the previous section glossed over the implementation details of
[`map`](@ref) and [`promote`](@ref), which both operate in terms of these traits.
When iterating over a matrix, such as in the implementation of `map`,
one important question is what order to use to traverse the data.
When `AbstractArray` subtypes implement the [`Base.IndexStyle`](@ref) trait,
other functions such as `map` can dispatch on this information to pick
the best algorithm (see [Abstract Array Interface](@ref man-interface-array)).
This means that each subtype does not need to implement a custom version of `map`,
since the generic definitions + trait classes will enable the system to select the fastest version.
Here a toy implementation of `map` illustrating the trait-based dispatch:
--><pre><code class="language-julia">map(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)
# generic implementation:
map(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...
# linear-indexing implementation (faster)
map(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...</code></pre><!--
This trait-based approach is also present in the [`promote`](@ref)
mechanism employed by the scalar `+`.
It uses [`promote_type`](@ref), which returns the optimal common type to
compute the operation given the two types of the operands.
This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments,
to the much smaller problem of implementing a conversion operation from each type to a common type,
plus a table of preferred pair-wise promotion rules.
--><p>`<a href="### Output-type computation"></a></p><h3><a class="nav-anchor" id="出力型の算出-1" href="#出力型の算出-1">出力型の算出</a></h3><!--
The discussion of trait-based promotion provides a transition into our next design pattern:
computing the output element type for a matrix operation.

For implementing primitive operations, such as addition,
we use the [`promote_type`](@ref) function to compute the desired output type.
(As before, we saw this at work in the `promote` call in the call to `+`).

For more complex functions on matrices, it may be necessary to compute the expected return
type for a more complex sequence of operations.
This is often performed by the following steps:
--><!--
1. Write a small function `op` that expresses the set of operations performed by the kernel of the algorithm.
2. Compute the element type `R` of the result matrix as `promote_op(op, argument_types...)`,
   where `argument_types` is computed from `eltype` applied to each input array.
3. Build the output matrix as `similar(R, dims)`, where `dims` are the desired dimensions of the output array.
--><!--
For a more specific example, a generic square-matrix multiply pseudo-code might look like:
--><pre><code class="language-julia">function matmul(a::AbstractMatrix, b::AbstractMatrix)
    op = (ai, bi) -&gt; ai * bi + ai * bi

    ## this is insufficient because it assumes `one(eltype(a))` is constructable:
    # R = typeof(op(one(eltype(a)), one(eltype(b))))

    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array
    # R = typeof(op(a[1], b[1]))

    ## this is incorrect because it assumes that `+` calls `promote_type`
    ## but this is not true for some types, such as Bool:
    # R = promote_type(ai, bi)

    # this is wrong, since depending on the return value
    # of type-inference is very brittle (as well as not being optimizable):
    # R = Base.return_types(op, (eltype(a), eltype(b)))

    ## but, finally, this works:
    R = promote_op(op, eltype(a), eltype(b))
    ## although sometimes it may give a larger type than desired
    ## it will always give a correct type

    output = similar(b, R, (size(a, 1), size(b, 2)))
    if size(a, 2) &gt; 0
        for j in 1:size(b, 2)
            for i in 1:size(b, 1)
                ## here we don&#39;t use `ab = zero(R)`,
                ## since `R` might be `Any` and `zero(Any)` is not defined
                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,
                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
                ab::R = a[i, 1] * b[1, j]
                for k in 2:size(a, 2)
                    ab += a[i, k] * b[k, j]
                end
                output[i, j] = ab
            end
        end
    end
    return output
end</code></pre><p>`<a href="### Separate convert and kernel logic"></a></p><h3><a class="nav-anchor" id="変換とカーネルロジックの分離-1" href="#変換とカーネルロジックの分離-1">変換とカーネルロジックの分離</a></h3><!--
One way to significantly cut down on compile-times and testing complexity is to isolate
the logic for converting to the desired type and the computation.
This lets the compiler specialize and inline the conversion logic independent
from the rest of the body of the larger kernel.

This is a common pattern seen when converting from a larger class of types
to the one specific argument type that is actually supported by the algorithm:
--><pre><code class="language-julia">complexfunction(arg::Int) = ...
complexfunction(arg::Any) = complexfunction(convert(Int, arg))

matmul(a::T, b::T) = ...
matmul(a, b) = matmul(promote(a, b)...)</code></pre><p>`<a href="## Parametrically-constrained Varargs methods"></a></p><h2><a class="nav-anchor" id="パラメータ制限つきの可変引数メソッド-1" href="#パラメータ制限つきの可変引数メソッド-1">パラメータ制限つきの可変引数メソッド</a></h2><!--
Function parameters can also be used to constrain the number of arguments that may be supplied
to a "varargs" function ([Varargs Functions](@ref)).  The notation `Vararg{T,N}` is used to indicate
such a constraint.  For example:
--><p>関数のパラメータは、 &quot;varargs&quot;関数(<a href="functions.html#可変引数関数-1">可変引数関数</a>)が受け取る引数の数を制限するためにも使用できます。 <code>Vararg{T,N}</code>という記法は、そういう制約のために使用われます。例えば：</p><pre><code class="language-julia-repl">julia&gt; bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia&gt; bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia&gt; bar(1,2,3,4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1</code></pre><!--
More usefully, it is possible to constrain varargs methods by a parameter. For example:
--><p>さらに便利なことに、パラメータで可変引数メソッドを制約することができます。例えば：</p><pre><code class="language-julia">function getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}</code></pre><!--
would be called only when the number of `indices` matches the dimensionality of the array.

When only the type of supplied arguments needs to be constrained `Vararg{T}` can be equivalently
written as `T...`. For instance `f(x::Int...) = x` is a shorthand for `f(x::Vararg{Int}) = x`.
--><p><code>indexes</code>の数が配列の次元の数と一致する場合にのみ呼び出されます。</p><p>`<a href="## Note on Optional and keyword Arguments"></a></p><h2><a class="nav-anchor" id="オプション引数・キーワード引数に関する注記-1" href="#オプション引数・キーワード引数に関する注記-1">オプション引数・キーワード引数に関する注記</a></h2><!--
As mentioned briefly in [Functions](@ref man-functions), optional arguments are implemented as syntax for multiple
method definitions. For example, this definition:
--><p>[関数]（@ ref man-functions）で簡単に述べたように、オプション引数は複数のメソッドを定義する構文として実装されています。例として、この定義を見てみましょう。</p><pre><code class="language-julia">f(a=1,b=2) = a+2b</code></pre><!--
translates to the following three methods:
--><p>これは以下の3つのメソッドに変換されます。</p><pre><code class="language-julia">f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)</code></pre><!--
This means that calling `f()` is equivalent to calling `f(1,2)`. In this case the result is `5`,
because `f(1,2)` invokes the first method of `f` above. However, this need not always be the case.
If you define a fourth method that is more specialized for integers:
--><p>これは、<code>f()</code>の呼び出しと<code>f(1,2)</code>の呼び出しは同等なことを意味します。 この場合、結果は<code>5</code>で、<code>f(1,2)</code>は最初の<code>f</code>メソッドを呼び出すからです。 しかし、必ずこうする必要はなく、整数に特化した4番目のメソッドを定義した場合は、次のようになります。</p><pre><code class="language-julia">f(a::Int,b::Int) = a-2b</code></pre><!--
then the result of both `f()` and `f(1,2)` is `-3`. In other words, optional arguments are tied
to a function, not to any specific method of that function. It depends on the types of the optional
arguments which method is invoked. When optional arguments are defined in terms of a global variable,
the type of the optional argument may even change at run-time.

Keyword arguments behave quite differently from ordinary positional arguments. In particular,
they do not participate in method dispatch. Methods are dispatched based only on positional arguments,
with keyword arguments processed after the matching method is identified.
--><p><code>f()</code>と<code>f(1,2)</code>の結果は両方とも<code>-3</code>です。言い換えれば、オプション引数は、その関数の特定のメソッドではなく、関数自体に結び付けられます。オプション引数の型によって、どのメソッドが呼び出されるかが変わります。オプション引数がグローバル変数で定義されている場合、オプション引数の型は実行時に変更されることさえあります。</p><p>キーワード引数は、通常の位置による引数とはまったく異なった動作をします。特に、メソッドディスパッチには加わりません。メソッドは、位置による引数にだけに基づいてディスパッチされ、一致するメソッドが特定された後にキーワード引数が処理されます。</p><p>`<a href="## Function-like objects"></a></p><h2><a class="nav-anchor" id="関数的なオブジェクト-1" href="#関数的なオブジェクト-1">関数的なオブジェクト</a></h2><!--
Methods are associated with types, so it is possible to make any arbitrary Julia object "callable"
by adding methods to its type. (Such "callable" objects are sometimes called "functors.")

For example, you can define a type that stores the coefficients of a polynomial, but behaves like
a function evaluating the polynomial:
--><p>メソッドは型に関連付けられているので、その型にメソッドを追加することで、任意のJuliaオブジェクトを「呼び出し可能」にすることができます。（このような「呼び出し可能な」オブジェクトは、「ファンクタ」と呼ばれることもあります）</p><p>たとえば、係数を保持する多項式の型を定義できますが、多項式を評価する関数のように動作します。</p><pre><code class="language-julia-repl">julia&gt; struct Polynomial{R}
           coeffs::Vector{R}
       end

julia&gt; function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end

julia&gt; (p::Polynomial)() = p(5)</code></pre><!--
Notice that the function is specified by type instead of by name. As with normal functions
there is a terse syntax form. In the function body, `p` will refer to the object that was
called. A `Polynomial` can be used as follows:
--><p>関数が名前ではなく型によって指定されていることに注意してください。関数本体で<code>p</code>は、呼ばれたオブジェクトを参照しています。<code>Polynomial</code>は以下のように使います。</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia&gt; p(3)
931

julia&gt; p()
2551</code></pre><!--
This mechanism is also the key to how type constructors and closures (inner functions that refer
to their surrounding environment) work in Julia.
--><p>このしくみは、型のコンストラクタとクロージャ（周囲の環境を参照する内部関数）がJuliaでどのように作用するかの鍵でもあります。 <a href="manual/@ref constructors-and-conversion">マニュアルの後の方</a>で検討します。</p><p>`<a href="## Empty generic functions"></a></p><h2><a class="nav-anchor" id="空の汎化関数-1" href="#空の汎化関数-1">空の汎化関数</a></h2><!--
Occasionally it is useful to introduce a generic function without yet adding methods. This can
be used to separate interface definitions from implementations. It might also be done for the
purpose of documentation or code readability. The syntax for this is an empty `function` block
without a tuple of arguments:
--><p>まだなにもメソッドを追加しない状態で、汎化関数を導入すると便利になる時があります。これは、インタフェースの定義を実装から分離するために使えます。また、文書化したり、コードの読みやすくしたりするためにもできます。この構文は、引数のタプルがない空の関数のブロックです。</p><pre><code class="language-julia">function emptyfunc
end</code></pre><p>`<a href="## [Method design and the avoidance of ambiguities](@id man-method-design-ambiguities)"></a></p><h2><a class="nav-anchor" id="man-method-design-ambiguities-1" href="#man-method-design-ambiguities-1">メソッドの設計と曖昧さの回避</a></h2><!--
Julia's method polymorphism is one of its most powerful features, yet
exploiting this power can pose design challenges.  In particular, in
more complex method hierarchies it is not uncommon for
[ambiguities](@ref man-ambiguities) to arise.

Above, it was pointed out that one can resolve ambiguities like
--><p>Juliaのメソッドの多相性は、最も強力な機能の1つですが、この力を利用すると、設計上の困難が生じる可能性があります。 特に、よりメソッドの階層が複雑なときは、<a href="methods.html#man-ambiguities-1">曖昧さ</a> が発生することは珍しくありません。</p><p>以前、以下のように曖昧さを解決できると指摘しましたが</p><pre><code class="language-julia">f(x, y::Int) = 1
f(x::Int, y) = 2</code></pre><!--
by defining a method
--><p>メソッドを定義することによって</p><pre><code class="language-julia">f(x::Int, y::Int) = 3</code></pre><!--
This is often the right strategy; however, there are circumstances
where following this advice blindly can be counterproductive. In
particular, the more methods a generic function has, the more
possibilities there are for ambiguities. When your method hierarchies
get more complicated than this simple example, it can be worth your
while to think carefully about alternative strategies.

Below we discuss particular challenges and some alternative ways to resolve such issues.
--><p>これが正しい戦略となる場合はよくでてきます。しかし、この助言に盲従すると、非生産的になる可能性があります。 特に、汎化関数のメソッドが多くなればなるほど、あいまいになる可能性が増します。 メソッドの階層がこの単純な例よりも複雑ならば、代替となる戦略も注意深く検討する価値があります。</p><p>以下では、特定の課題と、その問題を解決するための代替方法について説明します。</p><p>`<a href="### Tuple and NTuple arguments"></a></p><h3><a class="nav-anchor" id="タプル引数・Nタプル引数-1" href="#タプル引数・Nタプル引数-1">タプル引数・Nタプル引数</a></h3><!--
`Tuple` (and `NTuple`) arguments present special challenges. For example,
--><p><code>Tuple</code>（および<code>NTuple</code>）の引数には、特殊な課題があります。例えば、</p><pre><code class="language-julia">f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2</code></pre><!--
are ambiguous because of the possibility that `N == 0`: there are no
elements to determine whether the `Int` or `Float64` variant should be
called. To resolve the ambiguity, one approach is define a method for
the empty tuple:
--><p><code>N == 0</code>の可能性があるため、曖昧です。<code>Int</code>と<code>Float64</code>のどちらを呼び出すべきか、決める要素がありません。 この曖昧さを解決するには、空のタプルに対してメソッドを定義するという方法があります。</p><pre><code class="language-julia">f(x::Tuple{}) = 3</code></pre><!--
Alternatively, for all methods but one you can insist that there is at
least one element in the tuple:
--><p>あるいは、1つのメソッドを除いた、すべてのメソッドに対して、少なくとも1つの要素がタプルにあるような定義ができます。</p><pre><code class="language-julia">f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64</code></pre><p>`<a href="### [Orthogonalize your design](@id man-methods-orthogonalize)"></a></p><h3><a class="nav-anchor" id="man-methods-orthogonalize-1" href="#man-methods-orthogonalize-1">設計の直交化</a></h3><!--
When you might be tempted to dispatch on two or more arguments,
consider whether a "wrapper" function might make for a simpler
design. For example, instead of writing multiple variants:
--><p>ディスパッチに2つ以上の引数を使いたい場合は、「ラッパー」関数を使うと、単純な設計になるかどうかを検討してください。たとえば、複数のメソッドを記述する代わりに</p><pre><code class="language-julia">f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...</code></pre><!--
you might consider defining
--><p>このように定義するかもしれません。</p><pre><code class="language-julia">f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))</code></pre><!--
where `g` converts the argument to type `A`. This is a very specific
example of the more general principle of
[orthogonal design](https://en.wikipedia.org/wiki/Orthogonality_(programming)),
in which separate concepts are assigned to separate methods. Here, `g`
will most likely need a fallback definition
--><p>この例では、<code>g</code>が引数を型<code>A</code>に変換します。これは、一般的な原理である<a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)">直交設計</a>のとても具体的な例であり、 メソッドごとに別の概念が割り当てられています。ここで<code>g</code>は、おそらくフォールバックの定義が必要です</p><pre><code class="language-julia">g(x::A) = x</code></pre><!--
A related strategy exploits `promote` to bring `x` and `y` to a common
type:
--><p>関連する戦略として、<code>昇格</code>を利用して<code>x</code>と<code>y</code>を共通の型に変換する、というのもあります。</p><pre><code class="language-julia">f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)</code></pre><!--
One risk with this design is the possibility that if there is no
suitable promotion method converting `x` and `y` to the same type, the
second method will recurse on itself infinitely and trigger a stack
overflow. The non-exported function `Base.promote_noncircular` can be
used as an alternative; when promotion fails it will still throw an
error, but one that fails faster with a more specific error message.
--><p>この設計のリスクの1つは、 <code>x</code>と<code>y</code>を同じ型に変換する適切な昇格メソッドがなくて、2番目のメソッドが無限に繰り返し実行され、スタックオーバーフローが発生する可能性があります。 公開されていない関数<code>Base.promote_noncircular</code>を代わりに使用できます。昇格に失敗した場合でもエラーは発生しますが、もっと早く失敗してより具体的なエラーメッセージが表示されます。</p><p>`<a href="### Dispatch on one argument at a time"></a></p><h3><a class="nav-anchor" id="一度に１引数のディスパッチ-1" href="#一度に１引数のディスパッチ-1">一度に１引数のディスパッチ</a></h3><!--
If you need to dispatch on multiple arguments, and there are many
fallbacks with too many combinations to make it practical to define
all possible variants, then consider introducing a "name cascade"
where (for example) you dispatch on the first argument and then call
an internal method:
--><p>複数の引数にディスパッチする必要があり、メソッドの組み合わせが多すぎて、フォールバックを現実的には定義しきれない場合は、「名前のカスケード」（たとえば）最初の引数にディスパッチしてから内部的なメソッドを呼び出す）の導入を検討します。</p><pre><code class="language-julia">f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)</code></pre><!--
Then the internal methods `_fA` and `_fB` can dispatch on `y` without
concern about ambiguities with each other with respect to `x`.

Be aware that this strategy has at least one major disadvantage: in
many cases, it is not possible for users to further customize the
behavior of `f` by defining further specializations of your exported
function `f`. Instead, they have to define specializations for your
internal methods `_fA` and `_fB`, and this blurs the lines between
exported and internal methods.
--><p>そうすれば、内部メソッドの <code>_fA</code>と<code>_fB</code>は、<code>x</code>に関しては曖昧さを気にせずに、<code>y</code>に対してディスパッチできます。</p><p>この戦略には、少なくとも1つの重要な欠点があることに注意してください。 多くの場合、公開した関数<code>f</code>のさらに限定した定義するようなカスタマイズをユーザーがすることはできません。 代わりに、彼らはあなたの内部メソッドの<code>_fA</code>と<code>_fB</code>の特殊化を定義する必要があり、これは、公開した関数と内部メソッドの境界がぼやけます。</p><p>`<a href="### Abstract containers and element types"></a></p><h3><a class="nav-anchor" id="抽象コンテナと要素の型-1" href="#抽象コンテナと要素の型-1">抽象コンテナと要素の型</a></h3><!--
Where possible, try to avoid defining methods that dispatch on
specific element types of abstract containers. For example,
--><p>可能であれば、抽象型コンテナに特定の要素型でディスパッチするようなメソッドを定義しないでください。例えば、</p><pre><code class="language-julia">-(A::AbstractArray{T}, b::Date) where {T&lt;:Date}</code></pre><!--
generates ambiguities for anyone who defines a method
--><pre><code class="language-julia">-(A::MyArrayType{T}, b::T) where {T}</code></pre><!--
The best approach is to avoid defining *either* of these methods:
instead, rely on a generic method `-(A::AbstractArray, b)` and make
sure this method is implemented with generic calls (like `similar` and
`-`) that do the right thing for each container type and element type
*separately*. This is just a more complex variant of the advice to
[orthogonalize](@ref man-methods-orthogonalize) your methods.
--><p>最良の方法は、これらのメソッドの<strong>いずれかを</strong>定義することを避けることです。 代わりに、汎化メソッドの<code>-(A::AbstractArray, b)</code>に依存して、このメソッドが各コンテナ型や要素の型ごとに<strong>別々に</strong>適切なことを行う汎化呼び出し（<code>similar</code>や <code>-</code>など）で 実装されていることを確認します。 これはメソッドを[直交化]（@ ref man-methods-orthogonalize）する助言のちょっと複雑な変種です。</p><!--
When this approach is not possible, it may be worth starting a
discussion with other developers about resolving the ambiguity; just
because one method was defined first does not necessarily mean that it
can't be modified or eliminated.  As a last resort, one developer can
define the "band-aid" method
--><p>このアプローチが不可能な場合、曖昧さを解決するために他の開発者と議論を始める価値があります。 最初に1つのメソッドが定義されているからといって、必ずしもそのメソッドを変更や削除できないわけではないからです。 最後の手段として、1人の開発者が「救済」メソッドを定義するという手があります。</p><pre><code class="language-julia">-(A::MyArrayType{T}, b::Date) where {T&lt;:Date} = ...</code></pre><!--
that resolves the ambiguity by brute force.
--><p>`<a href="### Complex method &quot;cascades&quot; with default arguments"></a></p><h3><a class="nav-anchor" id="複雑なメソッドに&quot;多段的に&quot;デフォルト引数を使う-1" href="#複雑なメソッドに&quot;多段的に&quot;デフォルト引数を使う-1">複雑なメソッドに&quot;多段的に&quot;デフォルト引数を使う</a></h3><!--
If you are defining a method "cascade" that supplies defaults, be
careful about dropping any arguments that correspond to potential
defaults. For example, suppose you're writing a digital filtering
algorithm and you have a method that handles the edges of the signal
by applying padding:
--><p>&quot;多段的に&quot;デフォルト値を設定するメソッドを定義する場合、ありうるデフォルト値に対応する引数を見落とさないように注意してください。たとえば、デジタルフィルタリングアルゴリズムを作成していて、信号のエッジをパディングを適用して処理する方法があるとします。</p><pre><code class="language-julia">function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the &quot;real&quot; computation
end</code></pre><!--
This will run afoul of a method that supplies default padding:
--><p>これは、デフォルトのパディングを行うメソッドと衝突します：</p><pre><code class="language-julia">myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default</code></pre><!--
Together, these two methods generate an infinite recursion with `A` constantly growing bigger.

The better design would be to define your call hierarchy like this:
--><p>これらの2つのメソッドは、一緒になって、常に大きくなる<code>A</code>の無限再帰を生成します。</p><p>より良い設計は、次のように呼び出しの階層を定義することです。</p><pre><code class="language-julia">struct NoPad end  # indicate that no padding is desired, or that it&#39;s already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
    # Here&#39;s the &quot;real&quot; implementation of the core computation
end</code></pre><!--
`NoPad` is supplied in the same argument position as any other kind of
padding, so it keeps the dispatch hierarchy well organized and with
reduced likelihood of ambiguities. Moreover, it extends the "public"
`myfilter` interface: a user who wants to control the padding
explicitly can call the `NoPad` variant directly.
--><p><code>NoPad</code>は、他の種類のパディングと同じ引数の位置で指定されているため、ディスパッチの階層を整理しやすく、曖昧になる可能性が低くなります。さらに、&quot;パブリック&quot;の<code>myfilter</code>インターフェースを拡張します。パディングを明示的にコントロールしたいユーザーは、<code>NoPad</code>のメソッドを直接呼び出すことができます。</p><div class="footnote" id="footnote-Clarke61"><a href="#footnote-Clarke61"><strong>[Clarke61]</strong></a><p>Arthur C. Clarke, <em>Profiles of the Future</em> (1961): Clarke&#39;s Third Law.</p></div><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">型</span></a><a class="next" href="constructors.html"><span class="direction">Next</span><span class="title">Constructors</span></a></footer></article></body></html>
