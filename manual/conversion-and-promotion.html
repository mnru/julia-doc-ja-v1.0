<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>変換と昇格 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125166476-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">始めよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">コンストラクタ</a></li><li class="current"><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a><ul class="internal"><li><a class="toctext" href="#変換-1">変換</a></li><li><a class="toctext" href="#昇格-1">昇格</a></li></ul></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="conversion-and-promotion.html">変換と昇格</a></li></ul><a class="edit-page" href="https://github.com/mnru/julia-doc-ja-v1.0-source/blob/master/src/manual/conversion-and-promotion.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>変換と昇格</span><a class="fa fa-bars" href="#"></a></div></header><p>`<a href="# [Conversion and Promotion](@id conversion-and-promotion)"></a></p><h1><a class="nav-anchor" id="conversion-and-promotion-1" href="#conversion-and-promotion-1">変換と昇格</a></h1><!--
Julia has a system for promoting arguments of mathematical operators to a common type, which has
been mentioned in various other sections, including [Integers and Floating-Point Numbers](@ref),
[Mathematical Operations and Elementary Functions](@ref), [Types](@ref man-types), and [Methods](@ref).
In this section, we explain how this promotion system works, as well as how to extend it to new
types and apply it to functions besides built-in mathematical operators. Traditionally, programming
languages fall into two camps with respect to promotion of arithmetic arguments:
--><p>Juliaには、<a href="integers-and-floating-point-numbers.html#整数と浮動小数点数-1">整数と浮動小数点数</a>、<a href="manual/@ref">算術処理と基本的な関数</a>、<a href="types.html#man-types-1">型</a>、<a href="methods.html#メソッド-1">メソッド</a>、その他のさまざまな章に記述されているように、算術演算子の引数を共通の型に昇格するシステムが備わっています。 この章では、この昇格システムが動作するしくみや、昇格システムを新しい型に拡張して標準装備の算術演算子や関数でも動作させる方法について説明します。通常、プログラミング言語は算術演算の引数がどのように昇格するかによって、2つの陣営に分類されています。</p><!--
  * **Automatic promotion for built-in arithmetic types and operators.** In most languages, built-in
    numeric types, when used as operands to arithmetic operators with infix syntax, such as `+`,
    `-`, `*`, and `/`, are automatically promoted to a common type to produce the expected results.
    C, Java, Perl, and Python, to name a few, all correctly compute the sum `1 + 1.5` as the floating-point
    value `2.5`, even though one of the operands to `+` is an integer. These systems are convenient
    and designed carefully enough that they are generally all-but-invisible to the programmer: hardly
    anyone consciously thinks of this promotion taking place when writing such an expression, but
    compilers and interpreters must perform conversion before addition since integers and floating-point
    values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably
    part of specifications and implementations for such languages.
--><ul><li><strong>標準装備の算術型と演算子の自動昇格</strong> ほとんどの言語では、標準装備の数値型が、<code>+</code>、 <code>-</code>、<code>*</code>、<code>/</code>などの中置記法の算術演算子の被演算子として使われるときは、自動的に共通の型に昇格してから、演算結果が生成されます。少し例を挙げると、 C、Java、Perl、Pythonなどはすべて、<code>1 + 1.5</code>の合計を、浮動小数点値の<code>2.5</code>として正しく計算することができますが、<code>+</code>の被演算子の一方は整数です。こういうシステムは便利であり、通常はプログラマにはまったく見えないように慎重に設計されています。このような式を書くときに昇格が起こっていると意識する人はほとんどいませんが、コンパイラやインタプリタは、足し算を行う前に変換を必ずおこないます。整数と浮動小数点数はそのままでは足せないからです。このような自動変換の複雑な規則は、必然的にこの陣営の言語では仕様や実装の一部となります。</li></ul><!--
  * **No automatic promotion.** This camp includes Ada and ML -- very "strict" statically typed languages.
    In these languages, every conversion must be explicitly specified by the programmer. Thus, the
    example expression `1 + 1.5` would be a compilation error in both Ada and ML. Instead one must
    write `real(1) + 1.5`, explicitly converting the integer `1` to a floating-point value before
    performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada
    has some degree of automatic conversion: integer literals are promoted to the expected integer
    type automatically, and floating-point literals are similarly promoted to appropriate floating-point
    types.
--><ul><li><strong>非自動昇格</strong>この陣営にはAdaとMLなどの非常に「厳密」な静的に型付けされた言語があります。こういった言語では、すべての変換をプログラマが明示的に指定する必要があります。したがって、例に挙げた<code>1 + 1.5</code>という式は、AdaやMLでは共にコンパイルエラーになります。これを避けるには<code>real(1) + 1.5</code>のように書いて、足し算を実行する前に整数<code>1</code>を浮動小数点数に明示的に変換する必要があります。しかし、常に明示的に変換しなければならないのは不便なので、Adaでさえもある程度の自動変換が行われます。整数リテラルは期待されるように整数型に自動的に昇格され、浮動小数点リテラルも同様に適切な浮動小数点型に昇格されます。</li></ul><p>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch – something which Julia&#39;s dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</p><p>Juliaでは、算術演算子は特殊な構文を持つ関数に過ぎず、関数の引数は決して自動的に変換されません。 その意味では、Juliaは「非自動昇格」の陣営に分類されるでしょう。 しかし、様々な型の混合した引数に算術演算を適用することは、多相的な多重ディスパッチの極端な事例に過ぎません。これは型によるディスパッチをおこなうJuliaのシステムに非常に適しています。 算術演算における被演算子の「自動」昇格は、特殊な適用がおきただけです。Juliaには、算術演算子を全捕捉するディスパッチ規則が事前に定義されており、被演算子の型の組み合わせに対して特化した実装が存在しないときに呼び出されます。 この全捕捉規則は、まずユーザーが定義できる昇格規則を利用してすべての被演算子を共通の型に昇格し、こうして同一の型となった演算結果の型に特化した演算子の実装を呼び出します。 ユーザーの定義した型もこの昇格システムに簡単に追加できます。 ユーザー定義型に対して、他の型との変換メソッドを相互に定義し、他の型が混在する場合にどの型に昇格するかを定義する少数の昇格規則を決めてやればいいのです。</p><p>`<a href="## Conversion"></a></p><h2><a class="nav-anchor" id="変換-1" href="#変換-1">変換</a></h2><!--
The standard way to obtain a value of a certain type `T` is to call the type's constructor, `T(x)`.
However, there are cases where it's convenient to convert a value from one type to another
without the programmer asking for it explicitly.
One example is assigning a value into an array: if `A` is a `Vector{Float64}`, the expression
`A[1] = 2` should work by automatically converting the `2` from `Int` to `Float64`, and
storing the result in the array.
This is done via the `convert` function.

The `convert` function generally takes two arguments: the first is a type object and the second is
a value to convert to that type. The returned value is the value converted to an instance of given type.
The simplest way to understand this function is to see it in action:
--><p>値をさまざまな型に変換するのは、<code>convert</code>関数です。 この<code>convert</code>関数は通常、2つの引数をとります。1番目は型オブジェクトで、2番目はその型に変換される値です。 戻り値は指定された型のインスタンスに変換された値です。 この関数を理解する最も簡単な方法は、実際の動作を確認することです。</p><pre><code class="language-julia-repl">julia&gt; x = 12
12

julia&gt; typeof(x)
Int64

julia&gt; convert(UInt8, x)
0x0c

julia&gt; typeof(ans)
UInt8

julia&gt; convert(AbstractFloat, x)
12.0

julia&gt; typeof(ans)
Float64

julia&gt; a = Any[1 2 3; 4 5 6]
2×3 Array{Any,2}:
 1  2  3
 4  5  6

julia&gt; convert(Array{Float64}, a)
2×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0</code></pre><!--
Conversion isn't always possible, in which case a no method error is thrown indicating that `convert`
doesn't know how to perform the requested conversion:
--><p>変換は常に可能であるとは限りません。そんな時は、ノーメソッドエラーが投げられて、<code>convert</code>関数は要求された変換の実行方法を知らないことを通知します。</p><pre><code class="language-julia-repl">julia&gt; convert(AbstractFloat, &quot;foo&quot;)
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
[...]</code></pre><!--
Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions
(many dynamic languages will even perform conversion for you automatically), however Julia does
not: even though some strings can be parsed as numbers, most strings are not valid representations
of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated `parse`
function must be used to perform this operation, making it more explicit.
--><p>言語の中には文字列を解析して数値とみなしたり、書式付きの数値を変換して文字列とみなしたりするものがありますが、（多くの動的言語では自動的に変換が行われます）、Juliaはそうではありません。文字列の中には数値として解析できるものもありますが、ほとんどの文字列は数値としては妥当な表現ではなく、非常に限られた一部のみです。そのため、Juliaでは、こういった操作は、専用の関数<code>parse()</code> を使って明示的に行う必要があります。</p><p><code>[](### When is</code>convert` called?)</p><h3><a class="nav-anchor" id="変換が呼ばれるのはいつ?-1" href="#変換が呼ばれるのはいつ?-1"><code>変換</code>が呼ばれるのはいつ?</a></h3><p>The following language constructs call <code>convert</code>:</p><ul><li>Assigning to an array converts to the array&#39;s element type.</li><li>Assigning to a field of an object converts to the declared type of the field.</li><li>Constructing an object with <code>new</code> converts to the object&#39;s declared field types.</li><li>Assigning to a variable with a declared type (e.g. <code>local x::T</code>) converts to that type.</li><li>A function with a declared return type converts its return value to that type.</li><li>Passing a value to <code>ccall</code> converts it to the corresponding argument type.</li></ul><p>`<a href="### Conversion vs. Construction"></a></p><h3><a class="nav-anchor" id="変換-vs.-生成-1" href="#変換-vs.-生成-1">変換 vs. 生成</a></h3><p>Note that the behavior of <code>convert(T, x)</code> appears to be nearly identical to <code>T(x)</code>. Indeed, it usually is. However, there is a key semantic difference: since <code>convert</code> can be called implicitly, its methods are restricted to cases that are considered &quot;safe&quot; or &quot;unsurprising&quot;. <code>convert</code> will only convert between types that represent the same basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually lossless; converting a value to a different type and back again should result in the exact same value.</p><p>There are four general kinds of cases where constructors differ from <code>convert</code>:</p><p>`<a href="#### Constructors for types unrelated to their arguments"></a></p><h4><a class="nav-anchor" id="引数と無関係な型のコンストラクタ-1" href="#引数と無関係な型のコンストラクタ-1">引数と無関係な型のコンストラクタ</a></h4><p>Some constructors don&#39;t implement the concept of &quot;conversion&quot;. For example, <code>Timer(2)</code> creates a 2-second timer, which is not really a &quot;conversion&quot; from an integer to a timer.</p><p>`<a href="#### Mutable collections"></a></p><h4><a class="nav-anchor" id="可変コレクション-1" href="#可変コレクション-1">可変コレクション</a></h4><p><code>convert(T, x)</code> is expected to return the original <code>x</code> if <code>x</code> is already of type <code>T</code>. In contrast, if <code>T</code> is a mutable collection type then <code>T(x)</code> should always make a new collection (copying elements from <code>x</code>).</p><p>`<a href="#### Wrapper types"></a></p><h4><a class="nav-anchor" id="ラッパー型-1" href="#ラッパー型-1">ラッパー型</a></h4><p>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example <code>Some(x)</code> wraps <code>x</code> to indicate that a value is present (in a context where the result might be a <code>Some</code> or <code>nothing</code>). However, <code>x</code> itself might be the object <code>Some(y)</code>, in which case the result is <code>Some(Some(y))</code>, with two levels of wrapping. <code>convert(Some, x)</code>, on the other hand, would just return <code>x</code> since it is already a <code>Some</code>.</p><p>`<a href="#### Constructors that don&#39;t return instances of their own type"></a></p><h4><a class="nav-anchor" id="自身と同じ型のインスタンスを返さないコンストラクタ-1" href="#自身と同じ型のインスタンスを返さないコンストラクタ-1">自身と同じ型のインスタンスを返さないコンストラクタ</a></h4><p>In <em>very rare</em> cases it might make sense for the constructor <code>T(x)</code> to return an object not of type <code>T</code>. This could happen if a wrapper type is its own inverse (e.g. <code>Flip(Flip(x)) === x</code>), or to support an old calling syntax for backwards compatibility when a library is restructured. But <code>convert(T, x)</code> should always return a value of type <code>T</code>.</p><p>`<a href="### Defining New Conversions"></a></p><h3><a class="nav-anchor" id="新しい変換の定義-1" href="#新しい変換の定義-1">新しい変換の定義</a></h3><!--
When defining a new type, initially all ways of creating it should be defined as
constructors.
If it becomes clear that implicit conversion would be useful, and that some
constructors meet the above "safety" criteria, then `convert` methods can be added.
These methods are typically quite simple, as they only need to call the appropriate
constructor.
Such a definition might look like this:
--><p>新しく変換を定義するには、<code>convert()</code>に新たなメソッドを加えるだけです。それがすべてです。たとえば、実数をブール値に変換するメソッドは次のとおりです。</p><pre><code class="language-julia">convert(::Type{MyType}, x) = MyType(x)</code></pre><!--
The type of the first argument of this method is a [singleton type](@ref man-singleton-types),
`Type{MyType}`, the only instance of which is `MyType`. Thus, this method is only invoked
when the first argument is the type value `MyType`. Notice the syntax used for the first
argument: the argument name is omitted prior to the `::` symbol, and only the type is given.
This is the syntax in Julia for a function argument whose type is specified but whose value
does not need to be referenced by name. In this example, since the type is a singleton, we
already know its value without referring to an argument name.
--><p>このメソッドの1番目の引数の型は[シングルトン型]（@ ref man-singleton-types）の<code>Type{MyType}</code>で、この型のインスタンスは<code>MyType</code>だけです。 したがって、このメソッドは、最初の引数が型の値を示す<code>MyType</code>である場合にのみ呼び出されます。 最初の引数の構文に注目してください。 <code>::</code>という記号の前にあるはずの引数名は省略され、型だけが指定されています。 これはJuliaの関数の構文で、引数の型は指定するけれども、引数の値は関数本体でまったく使わない時に用います。 この例では、型はシングルトンであるため、その値を関数本体内で使う理由がありません。 このメソッドを呼び出すと、数値を1や0と比較して、真偽値を決定します。</p><!--
All instances of some abstract types are by default considered "sufficiently similar"
that a universal `convert` definition is provided in Julia Base.
For example, this definition states that it's valid to `convert` any `Number` type to
any other by calling a 1-argument constructor:
--><pre><code class="language-julia">convert(::Type{T}, x::Number) where {T&lt;:Number} = T(x)</code></pre><p>This means that new <code>Number</code> types only need to define constructors, since this definition will handle <code>convert</code> for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</p><pre><code class="language-julia">convert(::Type{T}, x::T) where {T&lt;:Number} = x</code></pre><p>Similar definitions exist for <code>AbstractString</code>, <code>AbstractArray</code>, and <code>AbstractDict</code>.</p><p>`<a href="## Promotion"></a></p><h2><a class="nav-anchor" id="昇格-1" href="#昇格-1">昇格</a></h2><!--
Promotion refers to converting values of mixed types to a single common type. Although it is not
strictly necessary, it is generally implied that the common type to which the values are converted
can faithfully represent all of the original values. In this sense, the term "promotion" is appropriate
since the values are converted to a "greater" type -- i.e. one which can represent all of the
input values in a single common type. It is important, however, not to confuse this with object-oriented
(structural) super-typing, or Julia's notion of abstract super-types: promotion has nothing to
do with the type hierarchy, and everything to do with converting between alternate representations.
For instance, although every [`Int32`](@ref) value can also be represented as a [`Float64`](@ref) value,
`Int32` is not a subtype of `Float64`.
--><p>昇格とは、型の混在した複数の値を単一の共通の型に変換することを指します。 値の変換される共通の型は元の値をすべて忠実に表現できるという条件は、必須ではありませんが、通常は満たすことが想定されています。 この意味では、「昇格」という用語は適切で、値は「より大きな」型に変換されます。 そして、すべての入力値を単一の共通型で表すことができます。 しかし重要なことですが、昇格をオブジェクト指向の（構造的）スーパータイプやJuliaの抽象型のスーパータイプという概念と混同しないでください。 昇格は型の階層とは関連がなく、代替的な表現どうしの変換のみに関連する概念です。 たとえば、すべての <a href="../base/numbers.html#Core.Int32"><code>Int32</code></a> の値は<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>の値として表現できますが、 <code>Int32</code>は<code>Float64</code>のサブタイプではありません。</p><!--
Promotion to a common "greater" type is performed in Julia by the `promote` function, which takes
any number of arguments, and returns a tuple of the same number of values, converted to a common
type, or throws an exception if promotion is not possible. The most common use case for promotion
is to convert numeric arguments to a common type:
--><p>共通の「より大きな」型に昇格するには、Juliaでは<code>promote</code>関数を使います。 この関数は、任意の数の引数をとって、同じ数の共通の型に変換された値のタプルを返し、また昇格が不可能な場合は例外を投げます。昇格の一番よくある使い方は、数値の引数を共通の型に変換することです。</p><pre><code class="language-julia-repl">julia&gt; promote(1, 2.5)
(1.0, 2.5)

julia&gt; promote(1, 2.5, 3)
(1.0, 2.5, 3.0)

julia&gt; promote(2, 3//4)
(2//1, 3//4)

julia&gt; promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)

julia&gt; promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)

julia&gt; promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)</code></pre><!--
Floating-point values are promoted to the largest of the floating-point argument types. Integer
values are promoted to the larger of either the native machine word size or the largest integer
argument type. Mixtures of integers and floating-point values are promoted to a floating-point
type big enough to hold all the values. Integers mixed with rationals are promoted to rationals.
Rationals mixed with floats are promoted to floats. Complex values mixed with real values are
promoted to the appropriate kind of complex value.
--><p>浮動小数点数は、浮動小数点数の引数の型の中で最大のものに昇格されます。 整数値は、ネイティブマシンのワードサイズと整数の引数の型の最大のものとのどちらか大きい方に昇格されます。 整数と浮動小数点数の混合した場合は、すべての値を保持するのに十分な大きさの浮動小数点型に昇格されます。 整数と有理数の混合した場合は有理数に昇格されます。 有理数と浮動小数点数の混合した場合は、浮動小数点数に昇格されます。 複素数と実数の混合した場合は、複素数の適切な型に昇格されます。</p><!--
That is really all there is to using promotions. The rest is just a matter of clever application,
the most typical "clever" application being the definition of catch-all methods for numeric operations
like the arithmetic operators `+`, `-`, `*` and `/`. Here are some of the catch-all method definitions
given in [`promotion.jl`](https://github.com/JuliaLang/julia/blob/master/base/promotion.jl):
--><p>昇格の使用法についてはこれがすべてです。あとはうまい適用の話だけです。 最も「うまい」適用は、 <code>+</code>、 <code>-</code>、 <code>*</code> 、<code>/</code>のような算術演算子用の全捕捉メソッドの定義です。 ここで <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>で定義された 全捕捉メソッドの一部を見てみましょう。</p><pre><code class="language-julia">+(x::Number, y::Number) = +(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)</code></pre><!--
These method definitions say that in the absence of more specific rules for adding, subtracting,
multiplying and dividing pairs of numeric values, promote the values to a common type and then
try again. That's all there is to it: nowhere else does one ever need to worry about promotion
to a common numeric type for arithmetic operations -- it just happens automatically. There are
definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions
in [`promotion.jl`](https://github.com/JuliaLang/julia/blob/master/base/promotion.jl), but beyond
that, there are hardly any calls to `promote` required in Julia Base. The most
common usages of `promote` occur in outer constructors methods, provided for convenience, to allow
constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate
common type. For example, recall that [`rational.jl`](https://github.com/JuliaLang/julia/blob/master/base/rational.jl)
provides the following outer constructor method:
--><p>これらのメソッド定義では、数値のペアに対して、例えば、加算、減算、乗算、除算を行う、より特化した規則がない場合、値を共通型に昇格してから演算を行います。 昇格を行うのはこれらだけです。他の場所で算術演算の共通の数値型への昇格を心配する必要はありません。 自動的に処理されます。 他にいくつもの算術関数や数学関数の全捕捉昇格メソッドの定義が<a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>にありますが、 それら以外で、Juliaの標準ライブラリで必要となる<code>promote</code>の呼び出しはほとんどありません。 外部コンストラクターメソッドで一番よく見かける<code>promote</code>の使い方は、利便性をあげるため、異なる型が混ざったコンストラクター呼び出しを可能にすることでしょう。 これば、引数を適切な共通型に昇格し、その型をフィールドに持つ内部型に、コンストラクター呼び出しを委譲して実現します。 たとえば <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl"><code>rational.jl</code></a>では、以下のような外部コンストラクタメソッドが利用可能なことを思い出してください。</p><pre><code class="language-julia">Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)</code></pre><!--
This allows calls like the following to work:
--><p>これにより、次のような呼び出しが可能になります。</p><pre><code class="language-julia-repl">julia&gt; Rational(Int8(15),Int32(-5))
-3//1

julia&gt; typeof(ans)
Rational{Int32}</code></pre><!--
For most user-defined types, it is better practice to require programmers to supply the expected
types to constructor functions explicitly, but sometimes, especially for numeric problems, it
can be convenient to do promotion automatically.
--><p>大抵のユーザー定義型では、プログラマーがコンストラクター関数に想定される型を明示的に指定するのがよいと思いますが、時には自動昇格を使うと、特に数値問題の場合は、便利なものです。</p><p>`<a href="### Defining Promotion Rules"></a></p><h3><a class="nav-anchor" id="昇格規則の定義-1" href="#昇格規則の定義-1">昇格規則の定義</a></h3><!--
Although one could, in principle, define methods for the `promote` function directly, this would
require many redundant definitions for all possible permutations of argument types. Instead, the
behavior of `promote` is defined in terms of an auxiliary function called `promote_rule`, which
one can provide methods for. The `promote_rule` function takes a pair of type objects and returns
another type object, such that instances of the argument types will be promoted to the returned
type. Thus, by defining the rule:
--><p>原理的には<code>promote</code>関数のメソッドを直接定義することができますが、そのためには、すべてのおこりうる引数の型の置換に対して多くの冗長な定義が必要になります。 その代わりに、<code>promote</code>関数の挙動の定義を、<code>promote_rule</code>という補助的な関数のメソッドを定義して行うことができます。 この<code>promote_rule</code>関数は、型オブジェクトのペアを引数に取って、別の型オブジェクトを返しますが、 これは引数の型のインスタンスが戻り値の型に昇格されることを意味しているので、そうなるように規則を定義します。</p><pre><code class="language-julia">promote_rule(::Type{Float64}, ::Type{Float32}) = Float64</code></pre><!--
one declares that when 64-bit and 32-bit floating-point values are promoted together, they should
be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument
types, however; the following promotion rules both occur in Julia Base:
--><p>64ビット浮動小数点数と32ビット浮動小数点数を一緒に昇格するときは、64ビット浮動小数点数に昇格する必要があります。 しかし昇格後の型は引数の型の1つである必要はありません。 次の昇格規則は共にJuliaの標準ライブラリにあるものです。</p><pre><code class="language-julia">promote_rule(::Type{UInt8}, ::Type{Int8}) = Int
promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt</code></pre><!--
In the latter case, the result type is [`BigInt`](@ref) since `BigInt` is the only type
large enough to hold integers for arbitrary-precision integer arithmetic. Also note that
one does not need to define both `promote_rule(::Type{A}, ::Type{B})` and
`promote_rule(::Type{B}, ::Type{A})` -- the symmetry is implied by the way `promote_rule`
is used in the promotion process.
--><p>後者の場合、昇格後の型は<a href="../base/numbers.html#Base.GMP.BigInt"><code>BigInt</code></a>になります。 というのも<code>BigInt</code>だけが、任意の精度の整数演算に対して整数を保持する大きさを持つの唯一の型だからです。 <code>promote_rule(::Type{A}, ::Type{B})</code>と <code>promote_rule(::Type{B}, ::Type{A})</code>の両方を定義する必要はない点に注意してください。<code>promote_rule</code>は、昇格の処理の際に、対称性を前提として使われます。</p><!--
The `promote_rule` function is used as a building block to define a second function called `promote_type`,
which, given any number of type objects, returns the common type to which those values, as arguments
to `promote` should be promoted. Thus, if one wants to know, in absence of actual values, what
type a collection of values of certain types would promote to, one can use `promote_type`:
--><p><code>promote_rule</code>関数を構成要素として使って、<code>promote_type</code>という二次的な関数を定義します。 <code>promote_type</code>関数は、任意の数の型オブジェクトを引数にとり、これらの値の共通の型を返します。 この型が<code>promote</code>関数が引数を昇格後にとるべき型となります。 したがって、実際の値が存在しなくても、<code>promote_type</code>を使えば、型の値の集合が昇格するとどんな型になるかを調べることができます。</p><pre><code class="language-julia-repl">julia&gt; promote_type(Int8, Int64)
Int64</code></pre><!--
Internally, `promote_type` is used inside of `promote` to determine what type argument values
should be converted to for promotion. It can, however, be useful in its own right. The curious
reader can read the code in [`promotion.jl`](https://github.com/JuliaLang/julia/blob/master/base/promotion.jl),
which defines the complete promotion mechanism in about 35 lines.
--><p>内部的には、<code>promote_type</code>は<code>promote</code>の内部で、引数値を昇格してどんな型に変換するかを決定するために使用されますが、<code>promote_type</code>単体でも有用なことがあります。 興味のある読者は約35行で完全な昇格の仕組みを定義するコードを <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl"><code>promotion.jl</code></a>で読むことができます。</p><p>`<a href="### Case Study: Rational Promotions"></a></p><h3><a class="nav-anchor" id="事例研究:-有理数-1" href="#事例研究:-有理数-1">事例研究: 有理数</a></h3><!--
Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively
sophisticated use of the promotion mechanism with the following promotion rules:
--><p>とうとう、ここまで進めてきたJuliaの有理数型の事例研究が完成します。ここでは、以下の昇格規則による昇格メカニズムを比較的洗練された手法で利用しています。</p><pre><code class="language-julia">promote_rule(::Type{Rational{T}}, ::Type{S}) where {T&lt;:Integer,S&lt;:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T&lt;:Integer,S&lt;:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T&lt;:Integer,S&lt;:AbstractFloat} = promote_type(T,S)</code></pre><!--
The first rule says that promoting a rational number with any other integer type promotes to a
rational type whose numerator/denominator type is the result of promotion of its numerator/denominator
type with the other integer type. The second rule applies the same logic to two different types
of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator
types. The third and final rule dictates that promoting a rational with a float results in the
same type as promoting the numerator/denominator type with the float.
--><p>第1の規則は、有理数型と整数型を昇格すると、有理数型に昇格し、その分子/分母の型は元の有理数の分子/分母の型と整数型を昇格した型になることを示しています。 第2の規則は、2つの異なる有理数型を昇格すると、同様の論理を適用して、各有理数型の分子/分母の型を昇格した型を分子/分母の型とするような有理数型に昇格することを示しています。 最後の3つ目の規則は、有理数型と浮動小数点型を昇格すると、浮動小数点型に昇格し、その型は有理数型の分子/分母の型と浮動小数点数型を昇格した結果と同じ型になることを示しています。</p><!--
This small handful of promotion rules, together with the type's constructors and the default
`convert` method for numbers, are sufficient to make rational numbers interoperate completely
naturally with all of Julia's other numeric types -- integers, floating-point numbers, and complex
numbers. By providing appropriate conversion methods and promotion rules in the same manner, any
user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.
--><p>この少数の昇格規則と、[前述の変換メソッド]だけで十分、有理数型をとても自然にJuliaの他の数値型、つまり 整数、浮動小数点数、複素数と一緒に使うことができます。 同様に、適切な変換メソッドと昇格規則を定義すれば、どんなユーザー定義の数値型でも自然に、Juliaで事前定義されている数値型と一緒に使うことができます。</p><footer><hr/><a class="previous" href="constructors.html"><span class="direction">Previous</span><span class="title">コンストラクタ</span></a><a class="next" href="interfaces.html"><span class="direction">Next</span><span class="title">Interfaces</span></a></footer></article></body></html>
