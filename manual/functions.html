<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>関数 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125166476-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">始めよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li class="current"><a class="toctext" href="functions.html">関数</a><ul class="internal"><li><a class="toctext" href="#引数引き渡しの挙動-1">引数引き渡しの挙動</a></li><li><a class="toctext" href="#return-キーワード-1"><code>return</code> キーワード</a></li><li><a class="toctext" href="#演算子は関数-1">演算子は関数</a></li><li><a class="toctext" href="#特殊な名前の演算子-1">特殊な名前の演算子</a></li><li><a class="toctext" href="#man-anonymous-functions-1">無名関数</a></li><li><a class="toctext" href="#タプル-1">タプル</a></li><li><a class="toctext" href="#名前付きタプル-1">名前付きタプル</a></li><li><a class="toctext" href="#複数の戻り値-1">複数の戻り値</a></li><li><a class="toctext" href="#引数分割-1">引数分割</a></li><li><a class="toctext" href="#可変引数関数-1">可変引数関数</a></li><li><a class="toctext" href="#オプション引数-1">オプション引数</a></li><li><a class="toctext" href="#キーワード引数-1">キーワード引数</a></li><li><a class="toctext" href="#デフォルト値の評価スコープ-1">デフォルト値の評価スコープ</a></li><li><a class="toctext" href="#関数の引数に対するDoブロック構文-1">関数の引数に対するDoブロック構文</a></li><li><a class="toctext" href="#man-vectorized-1">関数をベクトル化するDot構文</a></li><li><a class="toctext" href="#関連項目-1">関連項目</a></li></ul></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">コンストラクタ</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="functions.html">関数</a></li></ul><a class="edit-page" href="https://github.com/mnru/julia-doc-ja-v1.0-source/blob/master/src/manual/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>関数</span><a class="fa fa-bars" href="#"></a></div></header><p>`<a href="# [Functions](@id man-functions)"></a></p><h1><a class="nav-anchor" id="man-functions-1" href="#man-functions-1">関数</a></h1><!--
In Julia, a function is an object that maps a tuple of argument values to a return value. Julia
functions are not pure mathematical functions, in the sense that functions can alter and be affected
by the global state of the program. The basic syntax for defining functions in Julia is:
--><p>Juliaでは、関数とは引数の値のタプルに対して戻り値を返すオブジェクトです。 Juliaの関数は純粋に数学的な関数では、ありません。 これは、プログラムのグローバルな状態によって変更されたり、影響を受けたりするという意味です。 Juliaで関数を定義する基本構文は以下の様になります。</p><pre><code class="language-julia-repl">julia&gt; function f(x,y)
           x + y
       end
f (generic function with 1 method)</code></pre><!--
There is a second, more terse syntax for defining a function in Julia. The traditional function
declaration syntax demonstrated above is equivalent to the following compact "assignment form":
--><p>Juliaには、第二の簡潔な関数定義の構文があります。 上記の従来の関数宣言の構文と下記のコンパクトな&quot;代入形式&quot;は同等です。</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)</code></pre><!--
In the assignment form, the body of the function must be a single expression, although it can
be a compound expression (see [Compound Expressions](@ref man-compound-expressions)). Short, simple function definitions
are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing
both typing and visual noise.

A function is called using the traditional parenthesis syntax:
--><p>代入形式では、関数の本体は単一の式でなければなりませんが、複合式<a href="control-flow.html#man-compound-expressions-1">複合式</a>)でも構いません。 短くて単純な定義はJuliaでよく使われます。 短い関数構文は慣用的によく使われ、打鍵数や見た目のわずらわしさをかなり減らしてくれます。</p><p>関数の呼び出しには、従来通り、括弧を使います。</p><pre><code class="language-julia-repl">julia&gt; f(2,3)
5</code></pre><!--
Without parentheses, the expression `f` refers to the function object, and can be passed around
like any value:
--><p>括弧がない場合は、式<code>f</code>は関数オブジェクトを参照し、他の値と同じように受け渡しができます。</p><pre><code class="language-julia-repl">julia&gt; g = f;

julia&gt; g(2,3)
5</code></pre><!--
As with variables, Unicode can also be used for function names:
--><p>変数と同じように関数名にはユニコードを利用可能です。</p><pre><code class="language-julia-repl">julia&gt; ∑(x,y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</code></pre><p>`<a href="## Argument Passing Behavior"></a></p><h2><a class="nav-anchor" id="引数引き渡しの挙動-1" href="#引数引き渡しの挙動-1">引数引き渡しの挙動</a></h2><!--
Julia function arguments follow a convention sometimes called "pass-by-sharing", which means that
values are not copied when they are passed to functions. Function arguments themselves act as
new variable *bindings* (new locations that can refer to values), but the values they refer to
are identical to the passed values. Modifications to mutable values (such as `Array`s) made within
a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps,
Python, Ruby and Perl, among other dynamic languages.
--><p>Juliaの引数は&quot;共有渡し&quot;と呼ばれる慣例に従ています。 これは、関数に渡すときに複写をしないという意味です。 関数の引数自体は新しい変数 <strong>束縛</strong> のように振る舞いますが、値は受け取る値と同じものを参照しています。 （配列のような）可変な値を関数内で変更すると、呼び出し側からも見えます。 こうした挙動は、Scheme、ほとんどのLisp、Python、Ruby、Perlその他の動的言語でみられるものと同じです。</p><p><code>[](## The</code>return` Keyword)</p><h2><a class="nav-anchor" id="return-キーワード-1" href="#return-キーワード-1"><code>return</code> キーワード</a></h2><!--
The value returned by a function is the value of the last expression evaluated, which, by default,
is the last expression in the body of the function definition. In the example function, `f`, from
the previous section this is the value of the expression `x + y`. As in C and most other imperative
or functional languages, the `return` keyword causes a function to return immediately, providing
an expression whose value is returned:
--><p>関数の戻り値は最後に評価された式の値で、デフォルトでは関数定義本体の最後の式です。 前セクションで例示した関数<code>f</code>の場合、式<code>x + y</code>の値がこれに当たります。 C言語その他の命令型・関数型言語の大部分が、<code>return</code>キーワードによって、即時終了し、指定した式の値を戻り値とします。</p><pre><code class="language-julia">function g(x,y)
    return x * y
    x + y
end</code></pre><!--
Since function definitions can be entered into interactive sessions, it is easy to compare these
definitions:
--><p>関数定義を対話セッションで入力できるので、これらの定義を比較するのは簡単です。</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)

julia&gt; function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2,3)
5

julia&gt; g(2,3)
6</code></pre><!--
Of course, in a purely linear function body like `g`, the usage of `return` is pointless since
the expression `x + y` is never evaluated and we could simply make `x * y` the last expression
in the function and omit the `return`. In conjunction with other control flow, however, `return`
is of real use. Here, for example, is a function that computes the hypotenuse length of a right
triangle with sides of length `x` and `y`, avoiding overflow:
--><p>当然、<code>g</code>のように順次処理だけを行う関数の本体で、<code>ruturn</code>という用法をつかっても意味がありません。 というのも、式<code>x + y</code> は決して評価されず、単に<code>x * y</code>を関数内の最後の式にして<code>return</code>を省いてもいいからです。 しかし他の制御フローとつなぎ合わせる場合、<code>return</code>は実用的です。 直角を挟む２辺が<code>x</code>、<code>y</code>の三角形の斜辺をオーバーフローを避けながら計算する関数を書いてみると、</p><pre><code class="language-julia-repl">julia&gt; function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</code></pre><!--
There are three possible points of return from this function, returning the values of three different
expressions, depending on the values of `x` and `y`. The `return` on the last line could be omitted
since it is the last expression.

A return type can also be specified in the function declaration using the `::` operator. This converts
the return value to the specified type.
--><p>この関数には３箇所、終了しうる場所があり、３つの異なる式の値を返しますが、<code>x</code>と<code>y</code>の値に依存します。 最終行の<code>return</code>は最後の式なので省略可能です。</p><p>関数の戻り値の型は、関数宣言の中で、<code>::</code>演算子を使って指定できます。 これによって、戻り値を指定した型に変換します。</p><pre><code class="language-julia-repl">julia&gt; function g(x, y)::Int8
           return x * y
       end;

julia&gt; typeof(g(1, 2))
Int8</code></pre><!--
This function will always return an `Int8` regardless of the types of `x` and `y`.
See [Type Declarations](@ref) for more on return types.
--><p>この関数は<code>x</code>や<code>y</code>の型にかかわらず<code>Int8</code>を返します。 戻り値の型の詳細については、<a href="types.html#型宣言-1">型宣言</a>を参照してください。</p><p>`<a href="## Operators Are Functions"></a></p><h2><a class="nav-anchor" id="演算子は関数-1" href="#演算子は関数-1">演算子は関数</a></h2><!--
In Julia, most operators are just functions with support for special syntax. (The exceptions are
operators with special evaluation semantics like `&&` and `||`. These operators cannot be functions
since [Short-Circuit Evaluation](@ref) requires that their operands are not evaluated before evaluation
of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just
as you would any other function:
--><p>Juliaではほとんどの演算子が特殊な構文を利用できる単なる関数です。 （例外は特殊な評価セマンティックを持つ<code>&amp;&amp;</code>や<code>||</code>などの演算子です。 これらは、関数とはなりえません。 というのも、<a href="control-flow.html#短絡評価-1">短絡評価</a>では、演算子の評価の前に被演算子の評価はされないからです。） したがって、演算子を、他の関数と同じように、パラメータ付きの引数リストに適用することができます。</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; +(1,2,3)
6</code></pre><!--
The infix form is exactly equivalent to the function application form -- in fact the former is
parsed to produce the function call internally. This also means that you can assign and pass around
operators such as [`+`](@ref) and [`*`](@ref) just like you would with other function values:
--><p>中置形式は関数適用形式と全く同等です。 実のところ前者は内部で関数呼び出しを行っています。 これは、<a href="../base/math.html#Base.:+"><code>+</code></a> や <a href="../base/math.html#Base.:*-Tuple{Any,Vararg{Any,N} where N}"><code>*</code></a>といった演算子に対して、他の関数とおなじように、代入や受け渡しが可能だと言うことです。</p><pre><code class="language-julia-repl">julia&gt; f = +;

julia&gt; f(1,2,3)
6</code></pre><!--
Under the name `f`, the function does not support infix notation, however.
--><p>しかし、<code>f</code>という名前では、関数は中置記法を利用できません。</p><p>`<a href="## Operators With Special Names"></a></p><h2><a class="nav-anchor" id="特殊な名前の演算子-1" href="#特殊な名前の演算子-1">特殊な名前の演算子</a></h2><!--
A few special expressions correspond to calls to functions with non-obvious names. These are:

| Expression        | Calls                   |
|:----------------- |:----------------------- |
| `[A B C ...]`     | [`hcat`](@ref)          |
| `[A; B; C; ...]`  | [`vcat`](@ref)          |
| `[A B; C D; ...]` | [`hvcat`](@ref)         |
| `A'`              | [`adjoint`](@ref)       |
| `A[i]`            | [`getindex`](@ref)      |
| `A[i] = x`        | [`setindex!`](@ref)     |
| `A.n`             | [`getproperty`](@ref Base.getproperty) |
| `A.n = x`         | [`setproperty!`](@ref Base.setproperty!) |
--><p>見た目からはわからない名前で関数呼び出しできる特殊な式がいくつかあります。それらは</p><table><tr><th>式</th><th>呼び出し名</th></tr><tr><td><code>[A B C ...]</code></td><td><a href="../base/arrays.html#Base.hcat"><code>hcat</code></a></td></tr><tr><td><code>[A; B; C; ...]</code></td><td><a href="../base/arrays.html#Base.vcat"><code>vcat</code></a></td></tr><tr><td><code>[A B; C D; ...]</code></td><td><a href="../base/arrays.html#Base.hvcat"><code>hvcat</code></a></td></tr><tr><td><code>A&#39;</code></td><td><a href="../stdlib/LinearAlgebra.html#Base.adjoint"><code>adjoint</code></a></td></tr><tr><td><code>A[i]</code></td><td><a href="../base/collections.html#Base.getindex"><code>getindex</code></a></td></tr><tr><td><code>A[i] = x</code></td><td><a href="../base/collections.html#Base.setindex!"><code>setindex!</code></a></td></tr><tr><td><code>A.n</code></td><td><a href="../base/base.html#Base.getproperty"><code>getproperty</code></a></td></tr><tr><td><code>A.n = x</code></td><td><a href="../base/base.html#Base.setproperty!"><code>setproperty!</code></a></td></tr></table><p>`<a href="## [Anonymous Functions](@id man-anonymous-functions)"></a></p><h2><a class="nav-anchor" id="man-anonymous-functions-1" href="#man-anonymous-functions-1">無名関数</a></h2><!--
Functions in Julia are [first-class objects](https://en.wikipedia.org/wiki/First-class_citizen):
they can be assigned to variables, and called using the standard function call syntax from the
variable they have been assigned to. They can be used as arguments, and they can be returned as
values. They can also be created anonymously, without being given a name, using either of these
syntaxes:
--><p>Juliaにおいて関数は <a href="https://en.wikipedia.org/wiki/First-class_citizen">第一級オブジェクトです</a>。 関数を変数に代入し、標準的な関数を呼び出す構文で、束縛されている変数から呼び出すことができます。 また関数は、引数としても戻り値としても利用することができます。 また無名のまま、つまり名前をつけないで生成することができ、下記の構文のうちのどれかで作成できます。</p><pre><code class="language-julia-repl">julia&gt; x -&gt; x^2 + 2x - 1
#1 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</code></pre><!--
This creates a function taking one argument `x` and returning the value of the polynomial `x^2 +
2x - 1` at that value. Notice that the result is a generic function, but with a compiler-generated
name based on consecutive numbering.

The primary use for anonymous functions is passing them to functions which take other functions
as arguments. A classic example is [`map`](@ref), which applies a function to each value of
an array and returns a new array containing the resulting values:
--><p>この構文から、引数が<code>x</code>で、戻り値が その値に対する多項式<code>x^2 +2x - 1</code>の値となる関数が生成されます、。 ここで生成される関数は、汎化関数ですが、コンパイラの生成した通し番号が名付けられている点に注意してください。</p><p>無名関数の主な用途は、他の関数を引数にとる関数に渡すことです。 典型的な例は <a href="../base/collections.html#Base.map"><code>map</code></a>で、この関数は、配列の各値に対して関数を適用し、その結果を新しい配列として返します。</p><pre><code class="language-julia-repl">julia&gt; map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0</code></pre><!--
This is fine if a named function effecting the transform already exists to pass as the first argument
to [`map`](@ref). Often, however, a ready-to-use, named function does not exist. In these
situations, the anonymous function construct allows easy creation of a single-use function object
without needing a name:
--><p>これは、変換を行う名前付き関数がすでに存在し、 <a href="../base/collections.html#Base.map"><code>map</code></a>の第1引数に渡せる場合は申し分ありません。 しかし、すぐに使える既存の関数がないことは、よくあります。 そんな時は、無名関数の構文で、名前を必要としない使い捨ての関数オブジェクトを簡単に作ることができます。</p><pre><code class="language-julia-repl">julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</code></pre><!--
An anonymous function accepting multiple arguments can be written using the syntax `(x,y,z)->2x+y-z`.
A zero-argument anonymous function is written as `()->3`. The idea of a function with no arguments
may seem strange, but is useful for "delaying" a computation. In this usage, a block of code is
wrapped in a zero-argument function, which is later invoked by calling it as `f`.
--><p>複数の引数をとる無名関数は、 <code>(x,y,z)-&gt;2x+y-z</code>といった構文で書くことができます。 引数のない関数の場合は、<code>()-&gt;3</code>のように書けます。</p><p>引数のない関数という考えは奇妙に思えるかもしれませんが、計算を”遅らせる”時に役立ちます。 この記法で、コードの塊を引数のない関数で囲って、&#39;f&#39;のように後で呼び出します。</p><p>`<a href="## Tuples"></a></p><h2><a class="nav-anchor" id="タプル-1" href="#タプル-1">タプル</a></h2><!--
Julia has a built-in data structure called a *tuple* that is closely related to function
arguments and return values.
A tuple is a fixed-length container that can hold any values, but cannot be modified
(it is *immutable*).
Tuples are constructed with commas and parentheses, and can be accessed via indexing:
--><p>Juliaには、組込みの <strong>タプル</strong> と呼ばれるデータ型があり、関数の引数や戻り値と密接に関係しています。 タプルは長さの決まったコンテナで、任意の値を保持しますが、変更はできません。（つまり <strong>不変</strong> です）。 タプルはコンマと括弧で構成され、インデックスを使ってアクセスできます。</p><pre><code class="language-julia-repl">julia&gt; (1, 1+1)
(1, 2)

julia&gt; (1,)
(1,)

julia&gt; x = (0.0, &quot;hello&quot;, 6*7)
(0.0, &quot;hello&quot;, 42)

julia&gt; x[2]
&quot;hello&quot;</code></pre><!--
Notice that a length-1 tuple must be written with a comma, `(1,)`, since `(1)` would just
be a parenthesized value.
`()` represents the empty (length-0) tuple.
--><p>長さ１のタプルは、コンマをつけて<code>(1,)</code>のように書く必要がある点に気をつけてください。 <code>(1)</code>は括弧をつけた単なる値です。 <code>()</code>だと空の（長さ０）のタプルを表します。</p><p>`<a href="## Named Tuples"></a></p><h2><a class="nav-anchor" id="名前付きタプル-1" href="#名前付きタプル-1">名前付きタプル</a></h2><!--
The components of tuples can optionally be named, in which case a *named tuple* is
constructed:
--><p>タプルの要素には、必要に応じて名前をつけることができます。 この場合 <strong>名前付きタプル</strong>が生成されます。</p><pre><code class="language-julia-repl">julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)

julia&gt; x.a
1</code></pre><!--
Named tuples are very similar to tuples, except that fields can additionally be accessed by name
using dot syntax (`x.a`).
--><p>名前付きタプルはタプルと非常に似ていますが、そのフィールドに対しては更に、ドット構文(<code>x.a</code>)を使って名前でアクセスできます。</p><p>`<a href="## Multiple Return Values"></a></p><h2><a class="nav-anchor" id="複数の戻り値-1" href="#複数の戻り値-1">複数の戻り値</a></h2><!--
In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples
can be created and destructured without needing parentheses, thereby providing an illusion that
multiple values are being returned, rather than a single tuple value. For example, the following
function returns a pair of values:
--><p>Juliaでは値をタプルを使って、擬似的に複数の値を返すことができますが、 タプルは括弧をつかわなくても、生成・分割ができるので、単一のタプルの値ではなく複数の値を返しているような錯覚を与えるでしょう。 下記の関数では値の組を返しています。</p><pre><code class="language-julia-repl">julia&gt; function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)</code></pre><!--
If you call it in an interactive session without assigning the return value anywhere, you will
see the tuple returned:
--><p>この関数を対話セッションで戻り値をどこにも代入しない場合は、タプルが返ってくるのを確認できます。</p><pre><code class="language-julia-repl">julia&gt; foo(2,3)
(5, 6)</code></pre><!--
A typical usage of such a pair of return values, however, extracts each value into a variable.
Julia supports simple tuple "destructuring" that facilitates this:
--><p>しかし、こういった戻り値を組みにして返す用法をよく使うのは、それぞれの値を取り出して変数に代入する場合でしょう。 Juliaでは、これを簡単にするタプルの&quot;分割&quot;に対応しています。</p><pre><code class="language-julia-repl">julia&gt; x, y = foo(2,3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</code></pre><!--
You can also return multiple values via an explicit usage of the `return` keyword:
--><p>Juliaでは<code>return</code>キーワードを明示した用法で、複数の値を返すこともできます。</p><pre><code class="language-julia">function foo(a,b)
    return a+b, a*b
end</code></pre><!--
This has the exact same effect as the previous definition of `foo`.
--><p>これは既出の<code>foo</code>の定義と全く同じ効果があります。</p><p>`<a href="## Argument destructuring"></a></p><h2><a class="nav-anchor" id="引数分割-1" href="#引数分割-1">引数分割</a></h2><!--
The destructuring feature can also be used within a function argument.
If a function argument name is written as a tuple (e.g. `(x, y)`) instead of just
a symbol, then an assignment `(x, y) = argument` will be inserted for you:
--><p>分割の機能は、関数の引数の中でも利用できます。 関数の引数の位置にそれぞれの記号(例えば <code>(x, y)</code>)ではなくタプルを書くと、 <code>(x, y) = 引数のタプル</code>という代入が実行されます。</p><pre><code class="language-julia">julia&gt; minmax(x, y) = (y &lt; x) ? (y, x) : (x, y)

julia&gt; range((min, max)) = max - min

julia&gt; range(minmax(10, 2))
8</code></pre><!--
Notice the extra set of parentheses in the definition of `range`.
Without those, `range` would be a two-argument function, and this example would
not work.
--><p><code>range</code>の定義で余計な括弧があるのに注意してください。  これがなければ、<code>range</code>は引数が２個の関数となり、この例はうまく動作しません。</p><p>`<a href="## Varargs Functions"></a></p><h2><a class="nav-anchor" id="可変引数関数-1" href="#可変引数関数-1">可変引数関数</a></h2><!--
It is often convenient to be able to write functions taking an arbitrary number of arguments.
Such functions are traditionally known as "varargs" functions, which is short for "variable number
of arguments". You can define a varargs function by following the last argument with an ellipsis:
--><p>引数の数が任意個の関数が書けると便利なことがよくあります。 そういった関数は従来、”可変引数”関数として知られ、これは”可変個の引数”の略です。 可変引数関数は、最後の引数のあとに省略記号をつけると定義できます。</p><pre><code class="language-julia-repl">julia&gt; bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)</code></pre><!--
The variables `a` and `b` are bound to the first two argument values as usual, and the variable
`x` is bound to an iterable collection of the zero or more values passed to `bar` after its first
two arguments:
--><p>変数<code>a</code>と<code>b</code>は、通常通り、最初の２つの変数に束縛されています。 変数<code>x</code>は、最初の２つの引数に続いて<code>bar</code>に渡された引数からなる、０個以上のイテラブルコレクションが束縛される。 </p><pre><code class="language-julia-repl">julia&gt; bar(1,2)
(1, 2, ())

julia&gt; bar(1,2,3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))</code></pre><!--
In all these cases, `x` is bound to a tuple of the trailing values passed to `bar`.

It is possible to constrain the number of values passed as a variable argument; this will be discussed
later in [Parametrically-constrained Varargs methods](@ref).

On the flip side, it is often handy to "splat" the values contained in an iterable collection
into a function call as individual arguments. To do this, one also uses `...` but in the function
call instead:
--><p>すべての場合で、<code>x</code>は<code>bar</code>に渡された後続の値からなるタプルに束縛されます。</p><p>可変引数として渡される値の個数を制限することも可能ます。 これは後述の<a href="methods.html#パラメータ制限つきの可変引数メソッド-1">パラメータ制限つきの可変引数メソッド</a>で議論します。</p><p>また、イテラブルコレクションに含まれる値と、関数呼び出しの各引数とは、簡単に&quot;接合&quot;できるので、よく使われます。</p><pre><code class="language-julia-repl">julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))</code></pre><!--
In this case a tuple of values is spliced into a varargs call precisely where the variable number
of arguments go. This need not be the case, however:
--><p>この接合は、引数の個数とタプルの要素数がちょう等しいので、する必要はありません。</p><pre><code class="language-julia-repl">julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1,x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><!--
Furthermore, the iterable object splatted into a function call need not be a tuple:
--><p>さらに、関数呼び出しと接合するイテラブルオブジェクトはタプルである必要はありません。</p><pre><code class="language-julia-repl">julia&gt; x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><!--
Also, the function that arguments are splatted into need not be a varargs function (although it
often is):
--><p>引数を接合する関数は可変引数関数でなくてもかまいません（可変引数関数である方が多いですが）。</p><pre><code class="language-julia-repl">julia&gt; baz(a,b) = a + b;

julia&gt; args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1</code></pre><!--
As you can see, if the wrong number of elements are in the splatted container, then the function
call will fail, just as it would if too many arguments were given explicitly.
--><p>接合するコンテナの要素の数が適切ではない場合は、関数呼び出しは失敗します。 明示的に与える引数が多すぎる場合と同じです。</p><p>`<a href="## Optional Arguments"></a></p><h2><a class="nav-anchor" id="オプション引数-1" href="#オプション引数-1">オプション引数</a></h2><!--
In many cases, function arguments have sensible default values and therefore might not need to
be passed explicitly in every call. For example, the function [`Date(y, [m, d])`](@ref)
from `Dates` module constructs a `Date` type for a given year `y`, month `m` and day `d`.
However, `m` and `d` arguments are optional and their default value is `1`.
This behavior can be expressed concisely as:
--><p>多くの場合、関数の引数には適切なデフォルト値があり、すべての呼び出しでわざわざ値を渡す必要はないかもしれません。 例えば、<code>Dates</code>モジュールにある<a href="../stdlib/Dates.html#Dates.Date"><code>Date(y, [m, d])</code></a>関数は、年<code>y</code>・月<code>m</code>・日<code>d</code>から<code>Date</code>型を構成します。 しかし、<code>m</code>と<code>d</code>は省略可能で、デフォルト値は<code>1</code>です。 この挙動は簡単にこう表現できます。</p><pre><code class="language-julia">function Date(y::Int64, m::Int64=1, d::Int64=1)
    err = validargs(Date, y, m, d)
    err === nothing || throw(err)
    return Date(UTD(totaldays(y, m, d)))
end</code></pre><!--
Observe, that this definition calls another method of `Date` function that takes one argument
of `UTInstant{Day}` type.

With this definition, the function can be called with either one, two or three arguments, and
`1` is automatically passed when any of the arguments is not specified:
--><p>見ての通り、この定義では<code>Date</code>関数の別メソッドで、<code>UTInstant{Day}</code>型の1個引数にとるものを呼び出しています。 この定義によって、関数は１個または２個または３個の引数を取り、指定しなかった引数には、自動的に<code>1</code>を渡します。</p><pre><code class="language-julia-repl">julia&gt; using Dates

julia&gt; Date(2000, 12, 12)
2000-12-12

julia&gt; Date(2000, 12)
2000-12-01

julia&gt; Date(2000)
2000-01-01</code></pre><!--
Optional arguments are actually just a convenient syntax for writing multiple method definitions
with different numbers of arguments (see [Note on Optional and keyword Arguments](@ref)).
This can be checked for our `Date` function example by calling `methods` function.
--><p>省略可能な引数は実際には引数の異なる複数のメソッドを定義する、簡便な記法です。 (<a href="methods.html#オプション引数・キーワード引数に関する注記-1">オプション引数・キーワード引数に関する注記</a>を参照) これは<code>methods</code>関数から、例に挙げた<code>Date</code>関数呼び出して、確認することができます。</p><p>`<a href="## Keyword Arguments"></a></p><h2><a class="nav-anchor" id="キーワード引数-1" href="#キーワード引数-1">キーワード引数</a></h2><!--
Some functions need a large number of arguments, or have a large number of behaviors. Remembering
how to call such functions can be difficult. Keyword arguments can make these complex interfaces
easier to use and extend by allowing arguments to be identified by name instead of only by position.

For example, consider a function `plot` that plots a line. This function might have many options,
for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible
call might look like `plot(x, y, width=2)`, where we have chosen to specify only line width. Notice
that this serves two purposes. The call is easier to read, since we can label an argument with
its meaning. It also becomes possible to pass any subset of a large number of arguments, in any
order.

Functions with keyword arguments are defined using a semicolon in the signature:
--><p>関数の中には引数の数が多いものや、挙動の数が多いものがあります。 そういった関数の呼び出し方を覚えるのは難しくなることがあります。 キーワード引数を使うと、位置ではなく名前で引数を指定できるので、使用や拡張が簡単になります。</p><p>例えば線を引く<code>plot</code>関数を考えてみます。 おそらく、この関数には、線の形状、幅、色など、たくさんのオプションがあるでしょう。 キーワード引数を使えば、線の幅だけを指定するような<code>plot(x, y, width=2)</code>といった呼び出し方が可能でしょう。 これには2つの役割がある点に注意してください。 まずは、関数呼び出しが読みやすくなります。 というのも、引数に何を意味するかラベル付けできるからです。 次に、多数の引数のなかから、任意の部分集合を任意の順序で受け渡しできます。</p><p>キーワード引数を持つ関数は、シグネチャの中でセミコロンを使って定義します。</p><pre><code class="language-julia">function plot(x, y; style=&quot;solid&quot;, width=1, color=&quot;black&quot;)
    ###
end</code></pre><!--
When the function is called, the semicolon is optional: one can either call `plot(x, y, width=2)`
or `plot(x, y; width=2)`, but the former style is more common. An explicit semicolon is required
only for passing varargs or computed keywords as described below.

Keyword argument default values are evaluated only when necessary (when a corresponding keyword
argument is not passed), and in left-to-right order. Therefore default expressions may refer to
prior keyword arguments.

The types of keyword arguments can be made explicit as follows:
--><p>関数を呼び出す時に、セミコロンは省略できます。 呼び出し方は<code>plot(x, y, width=2)</code>か<code>plot(x, y; width=2)</code>ですが、前者のほうがよく使われます。 明示的にセミコロンを使う必要があるのは、下記のような、可変引数を渡す場合か計算結果のキーワードを渡すときです。</p><p>キーワード引数のデフォルト値は必要な時だけ左から右へ評価されます（対応するキーワード引数が渡されないときです）。 そのため、デフォルト式は先にでたのキーワード参照可能です。</p><pre><code class="language-julia">function f(;x::Int=1)
    ###
end</code></pre><!--
Extra keyword arguments can be collected using `...`, as in varargs functions:
--><p>余分のキーワード引数は、可変引数関数を同じように<code>...</code>を使ってひとまとめにすることができます。</p><pre><code class="language-julia">function f(x; y=0, kwargs...)
    ###
end</code></pre><!--
If a keyword argument is not assigned a default value in the method definition,
then it is *required*: an [`UndefKeywordError`](@ref) exception will be thrown
if the caller does not assign it a value:
--><p>キーワード引数がメソッドの定義でデフォルト値を設定されていない場合は、 <strong>入力必須</strong> となります。 呼び出し側が値を代入しない時には、 <a href="../base/base.html#Core.UndefKeywordError"><code>UndefKeywordError</code></a>が投げられます。</p><pre><code class="language-julia">function f(x; y)
    ###
end
f(3, y=5) # ok, y is assigned
f(3)      # throws UndefKeywordError(:y)</code></pre><!--
Inside `f`, `kwargs` will be a named tuple. Named tuples (as well as dictionaries) can be passed as
keyword arguments using a semicolon in a call, e.g. `f(x, z=1; kwargs...)`.

One can also pass `key => value` expressions after a semicolon. For example, `plot(x, y; :width => 2)`
is equivalent to `plot(x, y, width=2)`. This is useful in situations where the keyword name is computed
at runtime.
--><p><code>f</code>の内部で<code>kwargs</code>は名前付きタプルになります。 名前付きタプルは（辞書と同じように）、キーワード引数として関数に渡すことができて、呼び出す時にセミコロンを使います。 <code>f(x, z=1; kwargs...)</code>のように。  <code>key =&gt; value</code>といった式もセミコロンのあとに続けて、渡すこともできます。  例えば、<code>plot(x, y; :width =&gt; 2)</code>は<code>plot(x, y, width=2)</code>と同等です。  これは、キーワードが実行時に算出される状況で便利です。</p><!--
The nature of keyword arguments makes it possible to specify the same argument more than once.
For example, in the call `plot(x, y; options..., width=2)` it is possible that the `options` structure
also contains a value for `width`. In such a case the rightmost occurrence takes precedence; in
this example, `width` is certain to have the value `2`. However, explicitly specifying the same keyword
argument multiple times, for example `plot(x, y, width=2, width=3)`, is not allowed and results in
a syntax error.
--><p>キーワード変数の特質から、同一の引数に対して、複数回指定をすることが可能です。 例えば、<code>plot(x, y; options..., width=2)</code>のように関数を呼び出すとき、<code>options</code>の中にも<code>width</code>の値が含まれます。 こういう場合は、一番右側の出現が優先されます。この例では、<code>width</code>は必ず２になります。 しかし、例えば<code>plot(x, y, width=2, width=3)</code>のように、同一のキーワード引数を明示的に複数回指定することは、禁止されており 構文エラーとなります。</p><p>`<a href="## Evaluation Scope of Default Values"></a></p><h2><a class="nav-anchor" id="デフォルト値の評価スコープ-1" href="#デフォルト値の評価スコープ-1">デフォルト値の評価スコープ</a></h2><!--
When optional and keyword argument default expressions are evaluated, only *previous* arguments are in
scope.
For example, given this definition:
--><p>オプション引数やキーワード引数のデフォルトの式が評価される時、スコープに入るのは <strong>既出の</strong> 引数だけです。 例えば、この式の場合</p><pre><code class="language-julia">function f(x, a=b, b=1)
    ###
end</code></pre><!--
the `b` in `a=b` refers to a `b` in an outer scope, not the subsequent argument `b`.
--><p><code>a=b</code> の<code>b</code>は外側のスコープの<code>b</code>を参照して、後続の引数<code>b</code>は参照しません。</p><p>`<a href="## Do-Block Syntax for Function Arguments"></a></p><h2><a class="nav-anchor" id="関数の引数に対するDoブロック構文-1" href="#関数の引数に対するDoブロック構文-1">関数の引数に対するDoブロック構文</a></h2><!--
Passing functions as arguments to other functions is a powerful technique, but the syntax for
it is not always convenient. Such calls are especially awkward to write when the function argument
requires multiple lines. As an example, consider calling [`map`](@ref) on a function with several
cases:
--><p>他の関数に対して関数を引数として渡すことは、強力な技法ですが、その構文は必ずしも便利ではありません。 関数の引数が何行にも渡る場合、特に不格好になります。 例として、 <a href="../base/collections.html#Base.map"><code>map</code></a>関数が、場合分けがいくつかある関数を呼び出す場合を考えてみると、</p><pre><code class="language-julia">map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</code></pre><!--
Julia provides a reserved word `do` for rewriting this code more clearly:
--><p>Juliaにある予約語<code>do</code>を使ってこのコードをもっと明快に書き直すことができます。</p><pre><code class="language-julia">map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</code></pre><!--
The `do x` syntax creates an anonymous function with argument `x` and passes it as the first argument
to [`map`](@ref). Similarly, `do a,b` would create a two-argument anonymous function, and a
plain `do` would declare that what follows is an anonymous function of the form `() -> ...`.

How these arguments are initialized depends on the "outer" function; here, [`map`](@ref) will
sequentially set `x` to `A`, `B`, `C`, calling the anonymous function on each, just as would happen
in the syntax `map(func, [A, B, C])`.

This syntax makes it easier to use functions to effectively extend the language, since calls look
like normal code blocks. There are many possible uses quite different from [`map`](@ref), such
as managing system state. For example, there is a version of [`open`](@ref) that runs code ensuring
that the opened file is eventually closed:
--><p><code>do x</code>構文は、引数が<code>x</code>である無名関数を生成して、<a href="../base/collections.html#Base.map"><code>map</code></a>に1番目の引数として渡します。 同様に、<code>do a,b</code>では、引数が２個の無名関数を生成します。 また、単に<code>do</code>と書いた場合、<code>do</code>に続く記述を <code>...</code>とすると、 その記述が<code>() -&gt; ...</code>という形の無名関数だという宣言になります。</p><p>これらの引数がどのように初期化されるかは、&quot;外側&quot;の関数に依存します。 ここでは、<a href="../base/collections.html#Base.map"><code>map</code></a>は、<code>x</code> に <code>A</code>、<code>B</code>、<code>C</code>を順に代入しから、無名関数を呼び出して、<code>map(func, [A, B, C])</code> の構文とおなじような結果になります。</p><p>この構文を使うと、簡単に、関数を使ってげんごを効率的に拡張できます。というのも、関数呼び出しが通常のコードブロックのような 外見をしているからです。  <a href="../base/collections.html#Base.map"><code>map</code></a>とはかなり違う使い方も多数ありえます。、例えばシステムの状態の管理などです。 例えば、開いたファイルは最後に閉じることを保証する<a href="../base/io-network.html#Base.open"><code>open</code></a>のバージョンがあります。</p><pre><code class="language-julia">open(&quot;outfile&quot;, &quot;w&quot;) do io
    write(io, data)
end</code></pre><!--
This is accomplished by the following definition:
--><p>これは、以下の定義で達成できます。</p><pre><code class="language-julia">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre><!--
Here, [`open`](@ref) first opens the file for writing and then passes the resulting output stream
to the anonymous function you defined in the `do ... end` block. After your function exits, [`open`](@ref)
will make sure that the stream is properly closed, regardless of whether your function exited
normally or threw an exception. (The `try/finally` construct will be described in [Control Flow](@ref).)

With the `do` block syntax, it helps to check the documentation or implementation to know how
the arguments of the user function are initialized.

A `do` block, like any other inner function, can "capture" variables from its
enclosing scope. For example, the variable `data` in the above example of
`open...do` is captured from the outer scope. Captured variables
can create performance challenges as discussed in [performance tips](@ref man-performance-tips).
--><p>ここでは、<a href="../base/io-network.html#Base.open"><code>open</code></a>はまず書き込み用にファイルを開き、<code>do ... end</code>で定義した無名関数の演算結果を出力ストリームに渡します。 関数を終了したあとは、ストリームが適切に終了したかを確認します。 これは、正常終了の場合も、例外を投げた場合も同様です。 (<code>try/finally</code>構文については、<a href="control-flow.html#制御フロー-1">制御フロー</a>で記述します)</p><p><code>do</code> ブロック構文に関しては、ユーザー関数の引数が同初期化されるのかを知るには、ドキュメントや実装を確認すると役に立ちます。</p><p><code>do</code> ブロックは、他の内部関数と同様に、取り囲むスコープの変数を&quot;捕捉&quot;することができます。 例えば、上述の<code>open...do</code>の中の変数<code>data</code>は、外側のスコープから補足しています。 変数を捕捉すると、 <a href="performance-tips.html#man-performance-tips-1">パフォーマンス・ティップス</a>で議論するように、パフォーマンス上の困難が生じる可能性があります。</p><p>`<a href="## [Dot Syntax for Vectorizing Functions](@id man-vectorized)"></a></p><h2><a class="nav-anchor" id="man-vectorized-1" href="#man-vectorized-1">関数をベクトル化するDot構文</a></h2><!--
In technical-computing languages, it is common to have "vectorized" versions of functions, which
simply apply a given function `f(x)` to each element of an array `A` to yield a new array via
`f(A)`. This kind of syntax is convenient for data processing, but in other languages vectorization
is also often required for performance: if loops are slow, the "vectorized" version of a function
can call fast library code written in a low-level language. In Julia, vectorized functions are
*not* required for performance, and indeed it is often beneficial to write your own loops (see
[Performance Tips](@ref man-performance-tips)), but they can still be convenient. Therefore, *any* Julia function
`f` can be applied elementwise to any array (or other collection) with the syntax `f.(A)`.
For example `sin` can be applied to all elements in the vector `A`, like so:
--><p>技術計算向けのプログラム言語では、関数の&quot;ベクトル化&quot;版があることが多く、これは所与の<code>f(x)</code>を、配列<code>A</code>の各要素に適用して、<code>f(A)</code>と書かれる新しい配列を生成するものです。</p><p>この種の構文は、データ処理に便利ですが、他の言語では、パフォーマンスのためによく必要になります。 ループが遅い場合に、&quot;ベクトル化&quot;版の関数を、低級言語で書かれた速いライブラリから呼びます。 Juliaでは、パフォーマンスのためには、”ベクトル化”版の関数は必要なく、それどころか、自分でループ書いた方がいいことがよくありますが （<a href="performance-tips.html#man-performance-tips-1">パフォーマンス・ティップス</a>参照）、それでも便利です。 そのため、<strong>すべての</strong> Juliaの関数 <code>f</code>は、<code>f.(A)</code>という構文を使って、任意の配列（やその他のコレクション）に対して要素ごとの適用が可能です。 例えば、<code>sin</code>は、以下のように、ベクトル<code>A</code>のすべての要素に適用できます。</p><pre><code class="language-julia-repl">julia&gt; A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Array{Float64,1}:
 0.8414709848078965
 0.9092974268256817
 0.1411200080598672</code></pre><!--
Of course, you can omit the dot if you write a specialized "vector" method of `f`, e.g. via `f(A::AbstractArray) = map(f, A)`,
and this is just as efficient as `f.(A)`. But that approach requires you to decide in advance
which functions you want to vectorize.

More generally, `f.(args...)` is actually equivalent to `broadcast(f, args...)`, which allows
you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see
[Broadcasting](@ref)). For example, if you have `f(x,y) = 3x + 4y`, then `f.(pi,A)` will return
a new array consisting of `f(pi,a)` for each `a` in `A`, and `f.(vector1,vector2)` will return
a new vector consisting of `f(vector1[i],vector2[i])` for each index `i` (throwing an exception
if the vectors have different length).
--><p>もちろん、ドットを省略して、&quot;ベクトル&quot;に特化した<code>f</code>のメソッドを 、<code>f(A::AbstractArray) = map(f, A)</code>のように書くこともできて、 この場合<code>f.(A)</code>と全く同じ効率になります。しかし、この方法だと前もってどの関数をベクトル化したいかを決めておく必要があります。</p><p>さらに一般的には、<code>f.(args...)</code>は<code>broadcast(f, args...)</code>と実質的に同等で、これは、複数の配列(形さえ違っていてもかまわない)や、 さらに配列とスカラーの混合に対して操作するものです（<a href="manual/@ref">ブロードキャスティング</a>参照）。 たとえば、<code>f(x,y) = 3x + 4y</code>に対して、<code>f.(pi,A)</code>の場合は、 <code>A</code>の各要素<code>a</code>に対する<code>f(pi,a)</code>からなる新しい配列を返し、  <code>f.(vector1,vector2)</code>の場合は、各インデックス <code>f(vector1[i],vector2[i])</code>からなる新しいベクトルを返します。  （ベクトルの長さが異なる時は、例外を投げます）</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Array{Float64,1}:
 13.42477796076938
 17.42477796076938
 21.42477796076938

julia&gt; f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0</code></pre><!--
Moreover, *nested* `f.(args...)` calls are *fused* into a single `broadcast` loop. For example,
`sin.(cos.(X))` is equivalent to `broadcast(x -> sin(cos(x)), X)`, similar to `[sin(cos(x)) for x in X]`:
there is only a single loop over `X`, and a single array is allocated for the result. [In contrast,
`sin(cos(X))` in a typical "vectorized" language would first allocate one temporary array for
`tmp=cos(X)`, and then compute `sin(tmp)` in a separate loop, allocating a second array.] This
loop fusion is not a compiler optimization that may or may not occur, it is a *syntactic guarantee*
whenever nested `f.(args...)` calls are encountered. Technically, the fusion stops as soon as
a "non-dot" function call is encountered; for example, in `sin.(sort(cos.(X)))` the `sin` and `cos`
loops cannot be merged because of the intervening `sort` function.

--><p>さらに、<strong>ネストした</strong> <code>f.(args...)</code>の呼び出しは単一の <code>ブロードキャスト</code>のループに <strong>融合</strong>　します。 例えば、<code>sin.(cos.(X))</code>は<code>broadcast(x -&gt; sin(cos(x)), X)</code>と同等で、<code>[sin(cos(x)) for x in X]</code>に似ています。 これは<code>x</code>に関する一重のループで、配列１個を結果に割り当てます。 [対照的に、<code>sin(cos(X))</code>は通常の&quot;ベクトル化した&quot;言語では、まず一時的な配列を<code>tmp=cos(X)</code>に割り当て、次に<code>sin(tmp)</code> を別のループで計算して第２の配列を割り当てます] このループ融合は、コンパイラの最適化（おこる場合もおこらない場合もある）ではなく、ネストした<code>f.(args...)</code>呼び出しがある時に <strong>構文的に保証されている</strong>ものです。 技術的には、融合は&quot;ドットをつかわない&quot;関数呼び出しに出会うと直ちに停止します。 例えば、<code>sin.(sort(cos.(X)))</code> では<code>sin</code>と <code>cos</code>のループは、<code>sort</code>関数を挟んでいるために、融合できません。</p><!--
Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation
is *pre-allocated*, so that repeated calls do not allocate new arrays over and over again for
the results (see [Pre-allocating outputs](@ref)). A convenient syntax for this is `X .= ...`, which
is equivalent to `broadcast!(identity, X, ...)` except that, as above, the `broadcast!` loop is
fused with any nested "dot" calls. For example, `X .= sin.(Y)` is equivalent to `broadcast!(sin, X, Y)`,
overwriting `X` with `sin.(Y)` in-place. If the left-hand side is an array-indexing expression,
e.g. `X[2:end] .= sin.(Y)`, then it translates to `broadcast!` on a `view`, e.g.
`broadcast!(sin, view(X, 2:lastindex(X)), Y)`,
so that the left-hand side is updated in-place.

--><p>最後に、効率が最大となるのは、通常、ベクトル化した操作の出力が <strong>事前に割り当てられている</strong>ときで、関数を何度も呼び出すたびに、新しい配列の割り当てが何度もおこるのを防ぐためです。（<a href="manual/@ref">出力の事前割り当て</a>を参照） このための簡単な構文は、<code>X .= ...</code>で、これは <code>broadcast!(identity, X, ...)</code>とほぼ同等ですが、上記のように  <code>broadcast!</code>ループは、どんなにネストした&quot;ドット&quot;呼び出しとも融合する点が違います。  例えば、<code>X .= sin.(Y)</code> は<code>broadcast!(sin, X, Y)</code>と同等で、<code>X</code>を<code>sin.(Y)</code>で上書きします。  もし左辺が配列インデックスの式、例えば<code>X[2:end] .= sin.(Y)</code>であれば、<code>view</code>にたいする<code>broadcast!</code>、つまり、<code>broadcast!(sin, view(X, 2:lastindex(X)), Y)</code>に変換され、左辺が上書き更新されるようにします。</p><!--
Since adding dots to many operations and function calls in an expression
can be tedious and lead to code that is difficult to read, the macro
[`@.`](@ref @__dot__) is provided to convert *every* function call,
operation, and assignment in an expression into the "dotted" version.

--><p>多数の演算子や関数の呼び出しにドットをつけると式が長々しくなり、コードが読みづらくなりがちです。 マクロの<a href="../base/arrays.html#Base.Broadcast.@__dot__"><code>@.</code></a>を使うと、式の中にある <strong>すべての</strong> 関数呼び出し・演算子・代入を、&quot;ドット付き&quot;バージョンに変換します。</p><pre><code class="language-julia-repl">julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); # pre-allocate output array

julia&gt; @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.5143952585235492
 -0.4042391538522658
 -0.8360218615377305
 -0.6080830096407656</code></pre><!--
Binary (or unary) operators like `.+` are handled with the same mechanism:
they are equivalent to `broadcast` calls and are fused with other nested "dot" calls.
 `X .+= Y` etcetera is equivalent to `X .= X .+ Y` and results in a fused in-place assignment;
 see also [dot operators](@ref man-dot-operators).

You can also combine dot operations with function chaining using [`|>`](@ref), as in this example:
--><p><code>.+</code>のような二項（や単項）演算子は同じしくみで扱われます。 これは<code>broadcast</code>呼び出しと同等で、他のネストした&quot;ドット&quot;呼び出しと融合します。  <code>X .+= Y</code>などは<code>X .= X .+ Y</code>と同等で、融合した上書き代入を行います。 <a href="mathematical-operations.html#man-dot-operators-1">ドット演算子</a>も参照してください。</p><pre><code class="language-julia-repl">julia&gt; [1:5;] .|&gt; [x-&gt;x^2, inv, x-&gt;2*x, -, isodd]
5-element Array{Real,1}:
    1
    0.5
    6
   -4
 true</code></pre><p>`<a href="## Further Reading"></a></p><h2><a class="nav-anchor" id="関連項目-1" href="#関連項目-1">関連項目</a></h2><!--
We should mention here that this is far from a complete picture of defining functions. Julia has
a sophisticated type system and allows multiple dispatch on argument types. None of the examples
given here provide any type annotations on their arguments, meaning that they are applicable to
all types of arguments. The type system is described in [Types](@ref man-types) and defining a function
in terms of methods chosen by multiple dispatch on run-time argument types is described in [Methods](@ref).
--><p>ここでの関数定義は全体像から程遠いことを、言わねばなりません。 Juliaには洗練された型システムがあり、引数の型に対する多重ディスパッチが利用可能です。 このセクションでの例には引数に全く型注釈をつけていません。 これは、すべての型を適用可能だということを意味します。 型システムの記述は<a href="types.html#man-types-1">型</a>にあり、 関数の定義にメソッドを使い、実行時の引数の型に多重ディスパッチで選択する記述は<a href="manual/@ref">Methods</a>にあります。</p><footer><hr/><a class="previous" href="strings.html"><span class="direction">Previous</span><span class="title">文字列</span></a><a class="next" href="control-flow.html"><span class="direction">Next</span><span class="title">制御フロー</span></a></footer></article></body></html>
