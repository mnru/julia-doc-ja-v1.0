<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>型 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125166476-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">始めよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li class="current"><a class="toctext" href="types.html">型</a><ul class="internal"><li><a class="toctext" href="#型宣言-1">型宣言</a></li><li><a class="toctext" href="#抽象型-1">抽象型</a></li><li><a class="toctext" href="#プリミティブ型-1">プリミティブ型</a></li><li><a class="toctext" href="#複合型-1">複合型</a></li><li><a class="toctext" href="#可変複合型-1">可変複合型</a></li><li><a class="toctext" href="#宣言型-1">宣言型</a></li><li><a class="toctext" href="#合併型-1">合併型</a></li><li><a class="toctext" href="#パラメータ型-1">パラメータ型</a></li><li><a class="toctext" href="#全合併型-1">全合併型</a></li><li><a class="toctext" href="#型エイリアス-1">型エイリアス</a></li><li><a class="toctext" href="#型に対する演算-1">型に対する演算</a></li><li><a class="toctext" href="#man-custom-pretty-printing-1">独自の整形表示</a></li><li><a class="toctext" href="#&quot;値型&quot;-1">&quot;値型&quot;</a></li></ul></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">コンストラクタ</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">インターフェイス</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">多次元配列</a></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="types.html">型</a></li></ul><a class="edit-page" href="https://github.com/mnru/julia-doc-ja-v1.0-source/blob/master/src/manual/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>型</span><a class="fa fa-bars" href="#"></a></div></header><p>`<a href="# [Types](@id man-types)"></a></p><h1><a class="nav-anchor" id="man-types-1" href="#man-types-1">型</a></h1><!--
Type systems have traditionally fallen into two quite different camps: static type systems, where
every program expression must have a type computable before the execution of the program, and
dynamic type systems, where nothing is known about types until run time, when the actual values
manipulated by the program are available. Object orientation allows some flexibility in statically
typed languages by letting code be written without the precise types of values being known at
compile time. The ability to write code that can operate on different types is called polymorphism.
All code in classic dynamically typed languages is polymorphic: only by explicitly checking types,
or when objects fail to support operations at run-time, are the types of any values ever restricted.
--><p>型システムは従来全く異なる２つの陣営に分類されてきました。 静的型システムと動的型システムです。 静的型システムでは、プログラムのすべての式は、実行前に算出可能な型でなければなりません。 動的型システムでは、型に関する情報は、実行時、すなわち、プログラムが処理する実際の値が利用可能になる時まで 何もわかりません。 オブジェクト指向では、静的型言語でもある程度柔軟性があり、コンパイル時に判明する値の正確な型をコードに書かなくても構いません。 異なる型に対して操作可能なコードを書ける能力は多相性と呼ばれます。 古典的な動的型システムのすべてのコードは多相的です。 わざわざ型を検査したり、実行時にオブジェクトが操作に対応し損なわない限り、どんな値の型でも制限を受けません。</p><!--
Julia's type system is dynamic, but gains some of the advantages of static type systems by making
it possible to indicate that certain values are of specific types. This can be of great assistance
in generating efficient code, but even more significantly, it allows method dispatch on the types
of function arguments to be deeply integrated with the language. Method dispatch is explored in
detail in [Methods](@ref), but is rooted in the type system presented here.
--><p>Juliaの型システムは動的ですが、値に対して型を指定できるようにすることで、静的型システムの利点を幾分か取り入れています。 これは、効率的なコードを生成するための大きな手助けとなりますが。より重要なのは、関数の引数の型に対してメソッド・ディスパッチ が可能となり、言語に深く統合されていることです。メソッド・ディスパッチについては<a href="methods.html#メソッド-1">メソッド</a>で詳細に探索していますが、 ここに書いている型システムに根差しています。</p><!--
The default behavior in Julia when types are omitted is to allow values to be of any type. Thus,
one can write many useful Julia functions without ever explicitly using types. When additional
expressiveness is needed, however, it is easy to gradually introduce explicit type annotations
into previously "untyped" code. Adding annotations serves three primary purposes: to take advantage
of Julia's powerful multiple-dispatch mechanism,  to improve human readability, and to catch
programmer errors.
--><p>Juliaのデフォルトの挙動では、型を省略した場合は、値に対して任意の型が許容されます。 このため、多くの役に立つ関数を、わざわざ型の指定をしなくても、Juliaでは書くことができます。 しかし、必要に応じて、もとの&quot;型のない&quot;コードに徐々に明示的な型注釈をつけていくのは簡単です。 型注釈をつけるのは３つの目的があります。 Juliaの強力な多重ディスパッチのしくみを使うため、人間が読みやすくするため、プログラマーのエラーを捕捉するためです。</p><!--
Describing Julia in the lingo of [type systems](https://en.wikipedia.org/wiki/Type_system), it
is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical
relationships between types are [explicitly declared](https://en.wikipedia.org/wiki/Nominal_type_system),
rather than [implied by compatible structure](https://en.wikipedia.org/wiki/Structural_type_system).
One particularly distinctive feature of Julia's type system is that concrete types may not subtype
each other: all concrete types are final and may only have abstract types as their supertypes.
While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly
few drawbacks. It turns out that being able to inherit behavior is much more important than being
able to inherit structure, and inheriting both causes significant difficulties in traditional
object-oriented languages. Other high-level aspects of Julia's type system that should be mentioned
up front are:
--><p>Juliaのことを<a href="https://en.wikipedia.org/wiki/Type_system">型システム</a>の言葉で記述すると、 動的で、公称的で、パラメータ化可能です。 汎化型は、パラメータづけが可能で、型同士の階層的な関係は、<a href="https://en.wikipedia.org/wiki/Nominal_type_system">明示的に宣言し</a>、<a href="https://en.wikipedia.org/wiki/Structural_type_system">互換構造から推論する</a>のではありません。 特にJuliaに固有の型システムの特徴は、具象型は互いに互いのサブタイプとはならないことです。 具象型はすべてファイナルで、そのスーパータイプとなるのは抽象型のみです。 はじめは、この制約が不当に厳しく思えるかも知れませんが、多くの利点があり、欠点はほとんどありません。 挙動を継承できるほうが、構造を継承できるよりも重要であり、共に継承しようとすると、 従来のオブジェクト指向言語では、深刻な困難が生じることがわかっています。  他に、前もって言及すべきJuliaの型システムの高水準な特徴をあげると、</p><!--
  * There is no division between object and non-object values: all values in Julia are true objects
    having a type that belongs to a single, fully connected type graph, all nodes of which are equally
    first-class as types.
  * There is no meaningful concept of a "compile-time type": the only type a value has is its actual
    type when the program is running. This is called a "run-time type" in object-oriented languages
    where the combination of static compilation with polymorphism makes this distinction significant.
  * Only values, not variables, have types -- variables are simply names bound to values.
  * Both abstract and concrete types can be parameterized by other types. They can also be parameterized
    by symbols, by values of any type for which [`isbits`](@ref) returns true (essentially, things
    like numbers and bools that are stored like C types or `struct`s with no pointers to other objects),
    and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced
    or restricted.
--><ul><li>値にオブジェクトと非オブジェクトの区別はありません。 Juliaではすべて値は真のオブジェクトであり、オブジェクトはたった一つの型に属し、型どうしはすべてグラフの中で繋がっていて、 どのノードも等しく型として第一級です。</li><li>「コンパイル時の型」という考え方に意味はありません。値は唯一実行時の実際の型を持つのみです。 これは、オブジェクト指向言語では「実行時の型」と呼ばれ、静的コンパイルで多相性を実現するためにこの型の違いは重要です。</li><li>型を持つのは変数ではなく値のみです。 変数は値に束縛された単なる名前です。</li><li>抽象型と具象型は共に他の型によってパラメータ化可能です。 また他にも、記号・<a href="../base/base.html#Base.isbits"><code>isbits</code></a>が真になる型(本質的に、数やブール値など、他のオブジェクトへのポインタ持たないC言語の型や構造体に格納されるもの)やそれらのタプルによってもパラメータ化が可能です。 型のパラメータは参照や制限が必要ない時は省略可能です。</li></ul><!--
Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive.
Many Julia programmers may never feel the need to write code that explicitly uses types. Some
kinds of programming, however, become clearer, simpler, faster and more robust with declared types.
--><p>Juliaの型システムは、強力かつ表現力豊かでありながら、明快かつ直観的で目立たぬよう設計されています。 多くのJuliaのプログラマは、わざわざ型を使ってコードを書く必要性をまったく感じないかもしれません。 しかし、ある種のプログラムでは、型を宣言すると、より明快で、単純で、速く、堅牢になります。</p><p>`<a href="## Type Declarations"></a></p><h2><a class="nav-anchor" id="型宣言-1" href="#型宣言-1">型宣言</a></h2><!--
The `::` operator can be used to attach type annotations to expressions and variables in programs.
There are two primary reasons to do this:
--><p><code>::</code>演算子はプログラム中の式や変数に型注釈をつけるために使われます。 これには、２つの理由があります。</p><!--
1. As an assertion to help confirm that your program works the way you expect,
2. To provide extra type information to the compiler, which can then improve performance in some
   cases
--><ol><li>プログラムが想定通りに動いているかを確かめる、アサーションとして役立てる</li><li>コンパイラに付加的な情報を伝えて、状況によってはパフォーマンスが上がるようする</li></ol><!--
When appended to an expression computing a value, the `::` operator is read as "is an instance
of". It can be used anywhere to assert that the value of the expression on the left is an instance
of the type on the right. When the type on the right is concrete, the value on the left must have
that type as its implementation -- recall that all concrete types are final, so no implementation
is a subtype of any other. When the type is abstract, it suffices for the value to be implemented
by a concrete type that is a subtype of the abstract type. If the type assertion is not true,
an exception is thrown, otherwise, the left-hand value is returned:
--><p><code>::</code>演算子が値を計算する式についている場合は、&quot;is instance of&quot;とよみます。 左側の式の値は右側の型のインスタンスであると主張するためにどこでも使えます。 右側の方が具象型の場合、左側の値はその具象型となる実装でなければなりません。 すべての具象型は、ファイナルであり、実装はの他の具象型のサブタイプとはならないことを思い出してください。 型が抽象型の場合、実装した値の型はその抽象型のサブタイプで構いません。 型がアサーションと異なる場合、例外が投げられ、合致する場合は左側の値を返します。</p><pre><code class="language-julia-repl">julia&gt; (1+2)::AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got Int64

julia&gt; (1+2)::Int
3</code></pre><!--
This allows a type assertion to be attached to any expression in-place.

When appended to a variable on the left-hand side of an assignment, or as part of a `local` declaration,
the `::` operator means something a bit different: it declares the variable to always have the
specified type, like a type declaration in a statically-typed language such as C. Every value
assigned to the variable will be converted to the declared type using [`convert`](@ref):
--><p>このため、型アサーションを任意の式にその場でつけることができます。</p><p>代入の左辺の変数に付け加える時や、<code>local</code>宣言の一部である時、<code>::</code>演算子の意味は少し違います。 これは、変数は常に指定した型であるという宣言となり、C言語のような静的型付き言語と同様です。 この変数に代入した値は,宣言した型に <a href="../base/base.html#Base.convert"><code>convert</code></a>を利用して変換されます。</p><pre><code class="language-julia-repl">julia&gt; function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia&gt; foo()
100

julia&gt; typeof(ans)
Int8</code></pre><!--
This feature is useful for avoiding performance "gotchas" that could occur if one of the assignments
to a variable changed its type unexpectedly.

This "declaration" behavior only occurs in specific contexts:
--><p>この機能は、代入によって変数の型が図らずも変更された時におこりうる、パフォーマンスの「落とし穴」を避けるために役立ちます。</p><p>この「宣言」の挙動は、特定のコンテキストでのみ発生します。</p><pre><code class="language-julia">local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment</code></pre><!--
and applies to the whole current scope, even before the declaration. Currently, type declarations
cannot be used in global scope, e.g. in the REPL, since Julia does not yet have constant-type
globals.

Declarations can also be attached to function definitions:
--><p>そして、現在のスコープ全体に適用されます。宣言の前の部分にまでです。 今のところ、型宣言は、REPLなどのグローバルスコープでは使えません。 というのも、Juliaにはグローバルな定数型がまだ存在しないからです。</p><p>この宣言は、関数の定義にもつけることができます。</p><pre><code class="language-julia">function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end</code></pre><!--
Returning from this function behaves just like an assignment to a variable with a declared type:
the value is always converted to `Float64`.
--><p>この関数が終了すると、宣言した型で変数に代入するだけのようにふるまいます。 この値は常に<code>Float64</code>に変換されます。</p><p>`<a href="## Abstract Types"></a></p><h2><a class="nav-anchor" id="抽象型-1" href="#抽象型-1">抽象型</a></h2><!--
Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing
sets of related concrete types: those concrete types which are their descendants. We begin with
abstract types even though they have no instantiation because they are the backbone of the type
system: they form the conceptual hierarchy which makes Julia's type system more than just a collection
of object implementations.
--><p>抽象型はインスタンス化できません。 型のグラフの中ではノードの役割を果たすだけですが、だからこそ関連する具象型の集合をその抽象型の子孫として記述することができます。 まず抽象型の話から始めることにします。というのも、インスタンス化はできないですが、型システムの骨格となるからです。 抽象型が概念的な階層を形成し、Juliaの型システムを単なるオブジェクトの寄せ集め以上のものにしているのです。</p><!--
Recall that in [Integers and Floating-Point Numbers](@ref), we introduced a variety of concrete
types of numeric values: [`Int8`](@ref), [`UInt8`](@ref), [`Int16`](@ref), [`UInt16`](@ref),
[`Int32`](@ref), [`UInt32`](@ref), [`Int64`](@ref), [`UInt64`](@ref), [`Int128`](@ref),
[`UInt128`](@ref), [`Float16`](@ref), [`Float32`](@ref), and [`Float64`](@ref). Although
they have different representation sizes, `Int8`, `Int16`, `Int32`, `Int64` and `Int128`
all have in common that they are signed integer types. Likewise `UInt8`, `UInt16`, `UInt32`,
`UInt64` and `UInt128` are all unsigned integer types, while `Float16`, `Float32` and
`Float64` are distinct in being floating-point types rather than integers. It is common for
a piece of code to make sense, for example, only if its arguments are some kind of integer,
but not really depend on what particular *kind* of integer. For example, the greatest common
denominator algorithm works for all kinds of integers, but will not work for floating-point
numbers. Abstract types allow the construction of a hierarchy of types, providing a context
into which concrete types can fit. This allows you, for example, to easily program to any type
that is an integer, without restricting an algorithm to a specific type of integer.
--><p><a href="integers-and-floating-point-numbers.html#整数と浮動小数点数-1">整数と浮動小数点数</a>で様々な数値の具象型を導入したのを思い出してください。 <a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>, <a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>, <a href="../base/numbers.html#Core.Int16"><code>Int16</code></a>, <a href="../base/numbers.html#Core.UInt16"><code>UInt16</code></a>, <a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>, <a href="../base/numbers.html#Core.UInt32"><code>UInt32</code></a>, <a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>, <a href="../base/numbers.html#Core.UInt64"><code>UInt64</code></a>, <a href="../base/numbers.html#Core.Int128"><code>Int128</code></a>, <a href="../base/numbers.html#Core.UInt128"><code>UInt128</code></a>, <a href="../base/numbers.html#Core.Float16"><code>Float16</code></a>, <a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>, <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>などです。 表現のサイズは異なりますが、<code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code>,<code>Int128</code>はすべて符号付き整数型で、 <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>,<code>UInt64</code>,<code>UInt128</code>はすべて符号なし整数型であり、 <code>Float16</code>, <code>Float32</code>,<code>Float64</code>は整数とは別の浮動小数点数型です。 コードは例えば、引数を整数の種類を限定して定義した場合、実はその <strong>種類</strong> にかかわらず動作することがよくあります。 最大公約数を求めるアルゴリズムは、すべての整数に対して動作しますが、浮動小数点数では、動作しません。 抽象型を使うと、型の階層を形成して、具象型の適合する文脈を作ることができます。 これによって、例えば、任意の整数型でに対するプログラムを簡単に、アルゴリズムを特定の整数型に制限することなく、作成することができます。</p><!--
Abstract types are declared using the [`abstract type`](@ref) keyword. The general syntaxes for declaring an
abstract type are:
--><p>抽象型は <a href="../base/base.html#abstract type"><code>abstract type</code></a>キーワードを使って宣言することができます。 抽象型を宣言する一般的な構文は、</p><pre><code class="language-none">abstract type «name» end
abstract type «name» &lt;: «supertype» end</code></pre><!--
The `abstract type` keyword introduces a new abstract type, whose name is given by `«name»`. This
name can be optionally followed by [`<:`](@ref) and an already-existing type, indicating that the newly
declared abstract type is a subtype of this "parent" type.
--><p><code>abstract type</code>キーワードによって、新しい抽象型が<code>«name»</code>という名前で導入されます。 必要に応じて、この名前と<a href="../base/base.html#Core.:&lt;:"><code>&lt;:</code></a>と既存の型を続けると、新しく宣言した型はその型を&quot;親&quot;とするサブタイプであることを指定できます。</p><!--
When no supertype is given, the default supertype is `Any` -- a predefined abstract type that
all objects are instances of and all types are subtypes of. In type theory, `Any` is commonly
called "top" because it is at the apex of the type graph. Julia also has a predefined abstract
"bottom" type, at the nadir of the type graph, which is written as `Union{}`. It is the exact
opposite of `Any`: no object is an instance of `Union{}` and all types are supertypes of `Union{}`.

Let's consider some of the abstract types that make up Julia's numerical hierarchy:
--><p>スーパータイプを書かない場合、デフォルトのスーパータイプは<code>Any</code>になります。 <code>Any</code>は事前に定義された型で、すべてのオブジェクトは<code>Any</code>のインスタンスであり、すべての型は<code>Any</code>のサブタイプとなります。  <code>Any</code>は、型理論では、型のグラフの頂点にあるため、通常「トップ」と呼ばれます。   またJuliaには、<code>Union{}</code>と書かれる、事前に定義された「ボトム」の抽象型があり、型のグラフの最下位となります。   これは&#39;Any&#39;のちょうど逆で、<code>Union{}</code>のインスタンスとなるオブジェクトは存在せず、すべての型が<code>Union{}</code>のスーパータイプです。</p><p>Juliaにおいて数の階層を形成する抽象型をいくつか考察しましょう。</p><pre><code class="language-julia">abstract type Number end
abstract type Real     &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer  &lt;: Real end
abstract type Signed   &lt;: Integer end
abstract type Unsigned &lt;: Integer end</code></pre><!--
The [`Number`](@ref) type is a direct child type of `Any`, and [`Real`](@ref) is its child.
In turn, `Real` has two children (it has more, but only two are shown here; we'll get to
the others later): [`Integer`](@ref) and [`AbstractFloat`](@ref), separating the world into
representations of integers and representations of real numbers. Representations of real
numbers include, of course, floating-point types, but also include other types, such as
rationals. Hence, `AbstractFloat` is a proper subtype of `Real`, including only
floating-point representations of real numbers. Integers are further subdivided into
[`Signed`](@ref) and [`Unsigned`](@ref) varieties.
--><p><a href="../base/numbers.html#Core.Number"><code>Number</code></a>は<code>Any</code>の直下の子の型です。<a href="../base/numbers.html#Core.Real"><code>Real</code></a>はその子です。 次に<code>Real</code>には２つの子があります(もっとあありますがここでは２つのみを示します、他のものは後述します)。 <a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>と<a href="../base/numbers.html#Core.AbstractFloat"><code>AbstractFloat</code></a>は、数の世界を整数の表現と実数の表現に分離します。  実数の表現には、浮動小数点型が当然ありますが、有理数などの他の型もあります。  したがって、<code>AbstractFloat</code>は<code>Real</code>の真のサブタイプで、実数の中の浮動小数点数の表現しかありません。  整数はさらに<a href="../base/numbers.html#Core.Signed"><code>Signed</code></a>と<a href="../base/numbers.html#Core.Unsigned"><code>Unsigned</code></a>に細分されます。</p><!--
The `<:` operator in general means "is a subtype of", and, used in declarations like this, declares
the right-hand type to be an immediate supertype of the newly declared type. It can also be used
in expressions as a subtype operator which returns `true` when its left operand is a subtype of
its right operand:
--><p><code>&lt;:</code>演算子は通常「のサブタイプである」という意味の言葉で、このように宣言で利用します。 右側の型が新しく宣言した型の直接のスーパータイプであるという宣言になります。 また、式の中でサブタイプ演算子としても利用可能で、左の被演算子が右の被演算子のサブタイプの時に<code>true</code>を返します。</p><pre><code class="language-julia-repl">julia&gt; Integer &lt;: Number
true

julia&gt; Integer &lt;: AbstractFloat
false</code></pre><!--
An important use of abstract types is to provide default implementations for concrete types. To
give a simple example, consider:
--><p>抽象型の重要な用途に、具象型のデフォルトの実装を与えることがあります。 簡単な例を考えてみると、</p><pre><code class="language-julia">function myplus(x,y)
    x+y
end</code></pre><!--
The first thing to note is that the above argument declarations are equivalent to `x::Any` and
`y::Any`. When this function is invoked, say as `myplus(2,5)`, the dispatcher chooses the most
specific method named `myplus` that matches the given arguments. (See [Methods](@ref) for more
information on multiple dispatch.)
--><p>まず注意したい点は、上記の引数の宣言は<code>x::Any</code>や<code>y::Any</code>と同等である点です。 この関数が<code>myplus(2,5)</code>のように呼び出されると、<code>myplus</code>という名前で引数の合うメソッドから最も特化したメソッドが選択されます。 (多重ディスパッチに関するさらなる情報は<a href="methods.html#メソッド-1">メソッド</a>を参照のこと)。</p><!--
Assuming no method more specific than the above is found, Julia next internally defines and compiles
a method called `myplus` specifically for two `Int` arguments based on the generic function given
above, i.e., it implicitly defines and compiles:
--><p>上記のメソッドより特化したメソッドが見当たらない場合、次にJuliaは内部で<code>myplus</code>という名前のメソッドを定義しコンパイルします。 このメソッドは汎化関数に対して、引数2個が<code>Int</code>型のメソッドに特化したものです。 つまり、暗黙裡に定義とコンパイルが行われます。</p><pre><code class="language-julia">function myplus(x::Int,y::Int)
    x+y
end</code></pre><!--
and finally, it invokes this specific method.

Thus, abstract types allow programmers to write generic functions that can later be used as the
default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer
has full control over whether the default or more specific method is used.
--><p>そして、最終的にこの特化したメソッドが呼び出されます。</p><p>このように、抽象型を使うと、あとで多くの具象型と組み合わせた時にデフォルトのメソッドとなる汎化関数を書くことができます。 多重ディスパッチのおかげで、プログラマーはメソッドをデフォルトと特化したものとどちらを使うかを、完全に制御することができます。</p><!--
An important point to note is that there is no loss in performance if the programmer relies on
a function whose arguments are abstract types, because it is recompiled for each tuple of argument
concrete types with which it is invoked. (There may be a performance issue, however, in the case
of function arguments that are containers of abstract types; see [Performance Tips](@ref man-performance-tips).)
--><p>特記すべき重要な点は、引数が抽象型の関数を使っても、パフォーマンスの劣ることは全くない点です。 これは、関数が呼び出される毎に、具象型の引数のタプルそれぞれに対してリコンパイルを行うからです。 （しかし関数の引数が抽象型のコンテナの場合は、パフォーマンス上の問題が起こるかもしれません。 <a href="performance-tips.html#man-performance-tips-1">パフォーマンス・ティップス</a>を参照のこと。）</p><p>`<a href="## Primitive Types"></a></p><h2><a class="nav-anchor" id="プリミティブ型-1" href="#プリミティブ型-1">プリミティブ型</a></h2><!--
A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive
types are integers and floating-point values. Unlike most languages, Julia lets you declare your
own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard
primitive types are all defined in the language itself:
--><p>プリミティブ型は、データが普通のビットで構成される具象型です。 プリミティブ型の定番の例は、整数と浮動小数点数です。 ほとんどの言語とは異なり、Juliaでは組込みの決まったプリミティブ型が利用可能なだけではなく、 独自のプリミティブ型を宣言することができます。 実際、組込みのプリミティブ型はすべてJulia自体で定義されています。</p><pre><code class="language-julia">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</code></pre><!--
The general syntaxes for declaring a primitive type are:
--><p>プリミティブ型を宣言する一般的な構文は、</p><pre><code class="language-none">primitive type «name» «bits» end
primitive type «name» &lt;: «supertype» «bits» end</code></pre><!--
The number of bits indicates how much storage the type requires and the name gives the new type
a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype
is omitted, then the type defaults to having `Any` as its immediate supertype. The declaration
of [`Bool`](@ref) above therefore means that a boolean value takes eight bits to store, and has
[`Integer`](@ref) as its immediate supertype. Currently, only sizes that are multiples of
8 bits are supported. Therefore, boolean values, although they really need just a single bit,
cannot be declared to be any smaller than eight bits.
--><p>ビット数は、その型が格納に何ビット必要とするかを示し、新しい型の名前に使われます。  プリミティブ型は、必要に応じてどのスーパータイプのサブタイプなのかを宣言することができます。 スーパータイプを省略すると、デフォルトでは、Anyがその型の直接のスーパータイプになります。 したがって、上記のBool 宣言は、ブール値の格納に8ビットを要し、Integer が直接のスーパータイプであることを意味しています 。 現在は、8ビットの倍数であるサイズのみが利用可能です。  したがって、ブール値に本当に必要なのは1ビットだけですが、8ビットより小さい宣言にはできません。</p><!--
The types [`Bool`](@ref), [`Int8`](@ref) and [`UInt8`](@ref) all have identical representations:
they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they
are not interchangeable despite having identical structure. A fundamental difference between
them is that they have different supertypes: [`Bool`](@ref)'s direct supertype is [`Integer`](@ref),
[`Int8`](@ref)'s is [`Signed`](@ref), and [`UInt8`](@ref)'s is [`Unsigned`](@ref). All other
differences between [`Bool`](@ref), [`Int8`](@ref), and [`UInt8`](@ref) are matters of
behavior -- the way functions are defined to act when given objects of these types as
arguments. This is why a nominative type system is necessary: if structure determined type,
which in turn dictates behavior, then it would be impossible to make [`Bool`](@ref) behave
any differently than [`Int8`](@ref) or [`UInt8`](@ref).
--><p><a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>、<a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>、<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>の型はすべて同一の表現です。 これらは8ビットのメモリの塊です。  しかし、Juliaの型システムは公称的であるため、同一の構造であっても互換性はありません。  これらの基本的な違いは、スーパータイプが異なることです。 <a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>の直接のスーパータイプは <a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>、<a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>は<a href="../base/numbers.html#Core.Signed"><code>Signed</code></a>、Unsigned<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>は<a href="../base/numbers.html#Core.Unsigned"><code>Unsigned</code></a>です。  その他すべての<a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>、<a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>、<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>の違いは、挙動に関することです。  挙動とは結局、引数として与えられたオブジェクトの型に対して、関数がどのように動作するように定義されているかということです。  これが公称的な型システムが必要な理由です。 もしも構造によって型が決定するならば、型の構造から挙動がそのまま決まってしまうので、<a href="../base/numbers.html#Core.Bool"><code>Bool</code></a>を<a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>や<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>と異なる挙動をとらせることは不可能になるでしょう。</p><p>`<a href="## Composite Types"></a></p><h2><a class="nav-anchor" id="複合型-1" href="#複合型-1">複合型</a></h2><!--
[Composite types](https://en.wikipedia.org/wiki/Composite_data_type) are called records, structs,
or objects in various languages. A composite type is a collection of named fields,
an instance of which can be treated as a single value. In many languages, composite types are
the only kind of user-definable type, and they are by far the most commonly used user-defined
type in Julia as well.
--><p><a href="https://en.wikipedia.org/wiki/Composite_data_type">複合型</a> は、レコード、構造体、オブジェクトなど、 言語によって様々な呼ばれ方をします。  複合型は、名前付きフィールドの集合体であり、そのインスタンスは単一の値のように扱うことができます。  多くの言語では、複合型はユーザーが定義できる唯一の型の種類であり、Juliaでも最も一般的に使われるユーザ定義型です。</p><!--
In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also
have named functions associated with them, and the combination is called an "object". In purer
object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are
composites or not. In less pure object oriented languages, including C++ and Java, some values,
such as integers and floating-point values, are not objects, while instances of user-defined composite
types are true objects with associated methods. In Julia, all values are objects, but functions
are not bundled with the objects they operate on. This is necessary since Julia chooses which
method of a function to use by multiple dispatch, meaning that the types of *all* of a function's
arguments are considered when selecting a method, rather than just the first one (see [Methods](@ref)
for more information on methods and dispatch). Thus, it would be inappropriate for functions to
"belong" to only their first argument. Organizing methods into function objects rather than having
named bags of methods "inside" each object ends up being a highly beneficial aspect of the language
design.
--><p>C++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型に名前付き関数が関連づけられて、 その組み合わせは「オブジェクト」と呼ばれます。  RubyやSmalltalkのような、より純粋なオブジェクト指向言語では、すべての値は複合型であろうとなかろうとオブジェクトです。  少し不純なオブジェクト指向言語には、C++やJavaなどがあり、整数や浮動小数点数などの一部の値はオブジェクトではないですが、 ユーザーの定義する複合型のインスタンスは、真のオブジェクトで、関連づけられたメソッドを持ちます。  Juliaでは、すべての値がオブジェクトですが、関数は操作対象のオブジェクトとは関連づけられていません。 この仕様が必要なのは、Juliaでは、関数に対して使われるメソッドは、多重ディスパッチによって選択されるからです。  つまり、メソッドを選択するときには、<strong>すべての</strong> 関数の引数の型が考慮され、最初の引数のみではないからです（メソッドとディスパッチの詳細については、<a href="methods.html#メソッド-1">メソッド</a>を参照してください）。  したがって、関数が最初の引数だけに「属する」のは不適切です。  各オブジェクトの &quot;内側&quot;にたくさんの名前付きのメソッドをいれるより、メソッド群を編成して関数オブジェクトにする方が、言語設計上、非常に有益です。</p><!--
Composite types are introduced with the [`struct`](@ref) keyword followed by a block of field names, optionally
annotated with types using the `::` operator:
--><p>複合型は<a href="../base/base.html#struct"><code>struct</code></a>キーワードに続けて、フィールド名のブロックをおき、必要に応じて<code>::</code>を使って型注釈をつけて導入します。</p><pre><code class="language-julia-repl">julia&gt; struct Foo
           bar
           baz::Int
           qux::Float64
       end</code></pre><!--
Fields with no type annotation default to `Any`, and can accordingly hold any type of value.

New objects of type `Foo` are created by applying the `Foo` type object like a function
to values for its fields:
--><p>型注釈のないフィールドは、デフォルトの<code>Any</code>型となり、従ってどんな型の値でも保持することができます。</p><p>型が<code>Foo</code>の新しいオブジェクトは、型オブジェクト<code>Foo</code>を、そのフィールド値に対して、関数を適用するようにして作成します。</p><pre><code class="language-julia-repl">julia&gt; foo = Foo(&quot;Hello, world.&quot;, 23, 1.5)
Foo(&quot;Hello, world.&quot;, 23, 1.5)

julia&gt; typeof(foo)
Foo</code></pre><!--
When a type is applied like a function it is called a *constructor*. Two constructors are generated
automatically (these are called *default constructors*). One accepts any arguments and calls
[`convert`](@ref) to convert them to the types of the fields, and the other accepts arguments
that match the field types exactly. The reason both of these are generated is that this makes
it easier to add new definitions without inadvertently replacing a default constructor.

Since the `bar` field is unconstrained in type, any value will do. However, the value for `baz`
must be convertible to `Int`:
--><p>型は関数のように適用する時には、 <strong>コンストラクタ</strong> と呼ばれます。 2つのコンストラクタが自動的に生成されます（これらは <strong>デフォルトコンストラクタ</strong> と呼ばれます）。 1つはどんな引数でも許容し、<a href="../base/base.html#Base.convert"><code>convert</code></a> を呼び出してフィールドの型に変換します。 もう1つはフィールドの型と完全に一致する引数だけを許容します。 2つのコンストラクタが生成されるのは、新しい定義を追加を簡単に、不注意でデフォルトのコンストラクタを置き換えることなく、 できるようにするためです。</p><p><code>bar</code>フィールドには型の制約はないので、値は何でも構いません。ただし、<code>baz</code>の値は<code>Int</code>に変換できる必要があります。</p><pre><code class="language-julia-repl">julia&gt; Foo((), 23.5, 1)
ERROR: InexactError: Int64(Int64, 23.5)
Stacktrace:
[...]</code></pre><!--
You may find a list of field names using the [`fieldnames`](@ref) function.
--><p><a href="../base/base.html#Base.fieldnames"><code>fieldnames</code></a>関数を使うと、フィールド名のリストが表示されます。</p><pre><code class="language-julia-repl">julia&gt; fieldnames(Foo)
(:bar, :baz, :qux)</code></pre><!--
You can access the field values of a composite object using the traditional `foo.bar` notation:
--><p>従来のfoo.bar表記法を使用して、複合型のオブジェクトのフィールド値にアクセスできます。</p><pre><code class="language-julia-repl">julia&gt; foo.bar
&quot;Hello, world.&quot;

julia&gt; foo.baz
23

julia&gt; foo.qux
1.5</code></pre><!--
Composite objects declared with `struct` are *immutable*; they cannot be modified
after construction. This may seem odd at first, but it has several advantages:

  * It can be more efficient. Some structs can be packed efficiently into arrays, and
    in some cases the compiler is able to avoid allocating immutable objects entirely.
  * It is not possible to violate the invariants provided by the type's constructors.
  * Code using immutable objects can be easier to reason about.
--><p><code>struct</code>で宣言された複合型オブジェクトは <strong>不変</strong> です。 生成後に変更することはできません。 これは最初は奇妙に思えるかもしれませんが、いくつかの利点があります：</p><ul><li><p>より効率的になる場合があります。 構造体の中には効率的に配列にパックできるものもあり、 場合によっては、コンパイラが、不変オブジェクト全体を別のメモリに割り当てることを避けることができます。</p></li><li><p>型コンストラクタで規定される不変性を破ることはできません。</p></li><li><p>不変オブジェクトを使ったコードは、理解しやすくなる場合があります。</p></li></ul><!--
An immutable object might contain mutable objects, such as arrays, as fields. Those contained
objects will remain mutable; only the fields of the immutable object itself cannot be changed
to point to different objects.

Where required, mutable composite objects can be declared with the keyword [`mutable struct`](@ref), to be
discussed in the next section.

Immutable composite types with no fields are singletons; there can be only one instance of such types:
--><p>不変オブジェクトは、配列などの可変なオブジェクトをフィールドとして含んでも構いません。  含まれているオブジェクトは可変のままです。  不変オブジェクトのフィールド自体が、別のオブジェクトを参照するように変更できなくなるだけです。</p><p>必要に応じて、可変な複合オブジェクトをキーワード<a href="../base/base.html#mutable struct"><code>mutable struct</code></a>で宣言することができます （次のセクションで検討します）。</p><p>フィールドのない複合型はシングルトンです。そのような型のインスタンスは1つしか作れません。</p><pre><code class="language-julia-repl">julia&gt; struct NoFields
       end

julia&gt; NoFields() === NoFields()
true</code></pre><!--
The [`===`](@ref) function confirms that the "two" constructed instances of `NoFields` are actually one
and the same. Singleton types are described in further detail [below](@ref man-singleton-types).

There is much more to say about how instances of composite types are created, but that discussion
depends on both [Parametric Types](@ref) and on [Methods](@ref), and is sufficiently important
to be addressed in its own section: [Constructors](@ref man-constructors).
--><p><a href="../base/base.html#Core.:==="><code>===</code></a>によって、NoFieldsの「2つの」生成されたインスタンスが、実際には同一であることを確認できます。  シングルトン型については、<a href="types.html#man-singleton-types-1">あとで</a> で詳しく説明します。</p><p>複合型のインスタンスがどのように作成されるかについては、もっと多くの言うべきことがありますが、その議論は<a href="types.html#パラメータ型-1">パラメータ型</a>と<a href="methods.html#メソッド-1">メソッド</a>の両方もかかわり、十分重要なので、独自の章<a href="constructors.html#man-constructors-1">コンストラクタ</a>で解説します。</p><p>`<a href="## Mutable Composite Types"></a></p><h2><a class="nav-anchor" id="可変複合型-1" href="#可変複合型-1">可変複合型</a></h2><!--
If a composite type is declared with `mutable struct` instead of `struct`, then instances of
it can be modified:
--><p><code>struct</code>の代わりに<code>mutable struct</code>で複合型を宣言すると、インスタンスは変更可能になります。</p><pre><code class="language-julia-repl">julia&gt; mutable struct Bar
           baz
           qux::Float64
       end

julia&gt; bar = Bar(&quot;Hello&quot;, 1.5);

julia&gt; bar.qux = 2.0
2.0

julia&gt; bar.baz = 1//2
1//2</code></pre><!--
In order to support mutation, such objects are generally allocated on the heap, and have
stable memory addresses.
A mutable object is like a little container that might hold different values over time,
and so can only be reliably identified with its address.
In contrast, an instance of an immutable type is associated with specific field values ---
the field values alone tell you everything about the object.
In deciding whether to make a type mutable, ask whether two instances
with the same field values would be considered identical, or if they might need to change independently
over time. If they would be considered identical, the type should probably be immutable.
--><p>変更に対応できるように、このようなオブジェクトは、通常、ヒープ上に配置し、メモリアドレスは固定しています。  可変オブジェクトは、時間とともに値の変わりうる小さなコンテナと似ていて、アドレスだけで確実に識別できます。  対照的に、不変型のインスタンスは、特定のフィールド値に関連づけられています。 フィールド値だけで、オブジェクトに関するすべてがわかります。  型を可変にするかどうかを決めるには以下の問いを考えればいいでしょう。 同じフィールド値を持つ2つのインスタンスは同一だとみなせるか、あるいは時間とともに別々に変更する必要があるかと。  同一であると考えてもよいなら、おそらくその型は不変にすべきでしょう。</p><!--
To recap, two essential properties define immutability in Julia:

  * It is not permitted to modify the value of an immutable type.
    * For bits types this means that the bit pattern of a value once set will never change
      and that value is the identity of a bits type.
    * For composite  types, this means that the identity of the values of its fields will
      never change. When the fields are bits types, that means their bits will never change,
      for fields whose values are mutable types like arrays, that means the fields will
      always refer to the same mutable value even though that mutable value's content may
      itself be modified.
  * An object with an immutable type may be copied freely by the compiler since its
    immutability makes it impossible to programmatically distinguish between the original
    object and a copy.
    * In particular, this means that small enough immutable values like integers and floats
      are typically passed to functions in registers (or stack allocated).
    * Mutable values, on the other hand are heap-allocated and passed to
      functions as pointers to heap-allocated values except in cases where the compiler
      is sure that there's no way to tell that this is not what is happening.
--><p>要約すると、2つの重要な特性がJuliaにおける普遍性を決定づけています。</p><ul><li>不変型の値を変更することは、許可されていません。<ul><li>プリミティブ型では、一度設定された値のビットパターンは決して変わらず、その値はそのプリミティブ型で恒等的であることを意味します。</li><li>複合型では、そのフィールドの値の恒等性は決して変わらないことを意味します。 フィールドが、プリミティブ型の場合は、そのビットは決して変わらず、配列のような可変型の場合は、常に同じ可変の値を参照することを意味します。 可変な値の中身自体が変わった場合であってもです。</li></ul></li><li>不変型のオブジェクトはコンパイラが自由にコピーすることができます。 というのも、不変性によって、元のオブジェクトとコピーしたものを見分けることができないからです。<ul><li>このため、特に十分小さな整数や浮動小数点数などの不変型は、通常レジスタ（やスタック）にある関数には そのまま渡されます。</li><li>一方、可変な値は、ヒープに配置され、その配置された値へのポインタとして関数に渡されます。  except in cases where the compiler is sure that there&#39;s no way to tell that this is not what is happening.</li></ul></li></ul><p>`<a href="## Declared Types"></a></p><h2><a class="nav-anchor" id="宣言型-1" href="#宣言型-1">宣言型</a></h2><!--
The three kinds of types (abstract, primitive, composite) discussed in the previous
sections are actually all closely related. They share the same key properties:

  * They are explicitly declared.
  * They have names.
  * They have explicitly declared supertypes.
  * They may have parameters.
--><p>上記のセクションで説明した3種の型（抽象型、プリミティブ型、複合型）は、実のところ、すべて密接に関連しています。  これらは重要な特徴が共通しています。</p><ul><li>明示的に宣言している。</li><li>名前がある。</li><li>スーパータイプを明示的に宣言している。</li><li>パラメータをつけてもよい。</li></ul><!--
Because of these shared properties, these types are internally represented as instances of the
same concept, `DataType`, which is the type of any of these types:
--><p>特徴が共通しているため、これらの型は内部的に同じ概念の<code>DataType</code>のインスタンスとして表現されます。 <code>DataType</code>はこれらの型のいずれかのことです。</p><pre><code class="language-julia-repl">julia&gt; typeof(Real)
DataType

julia&gt; typeof(Int)
DataType</code></pre><!--
A `DataType` may be abstract or concrete. If it is concrete, it has a specified size, storage
layout, and (optionally) field names. Thus a primitive type is a `DataType` with nonzero size, but
no field names. A composite type is a `DataType` that has field names or is empty (zero size).

Every concrete value in the system is an instance of some `DataType`.
--><p><code>DataType</code>は抽象型でも具象型でもかまいません。 具象型であれば、特定のサイズ、 格納領域の配置 があり、（場合によっては）フィールド名もあります。  そして、プリミティブ型は、サイズが0ではない<code>DataType</code>で、フィールド名を持ちません。  複合型は、フィールド名があるか、空（サイズ0）の<code>DataType</code>です。</p><p>システムのすべての具体的な値は、なんらかの<code>DataType</code>のインスタンスです。</p><p>`<a href="## Type Unions"></a></p><h2><a class="nav-anchor" id="合併型-1" href="#合併型-1">合併型</a></h2><!--
A type union is a special abstract type which includes as objects all instances of any of its
argument types, constructed using the special [`Union`](@ref) keyword:
--><p>合併型は特殊な抽象型で、この型にオブジェクトとして含まれるのは、引数のいずれかの型のインスタンスすべてであり、 特殊なキーワード<a href="../base/base.html#Core.Union"><code>Union</code></a>を使って構築します。</p><pre><code class="language-julia-repl">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 :: IntOrString
1

julia&gt; &quot;Hello!&quot; :: IntOrString
&quot;Hello!&quot;

julia&gt; 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got Float64</code></pre><!--
The compilers for many languages have an internal union construct for reasoning about types; Julia
simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the
presence of `Union` types with a small number of types [^1], by generating specialized code
in separate branches for each possible type.
--><p>多くの言語のコンパイラには、型推論のための内部でつかう合併構文があります。 Juliaは単にそれをプログラマにも公開しています。 型の数が少ない場合に <code>合併型</code> を使うと、Juliaのコンパイラは効率的なコードを生成します<a href="#footnote-1">[1]</a>。 なりうる型すべてに個別に特化したコードを生成します。</p><!--
A particularly useful case of a `Union` type is `Union{T, Nothing}`, where `T` can be any type and
[`Nothing`](@ref) is the singleton type whose only instance is the object [`nothing`](@ref). This pattern
is the Julia equivalent of [`Nullable`, `Option` or `Maybe`](https://en.wikipedia.org/wiki/Nullable_type)
types in other languages. Declaring a function argument or a field as `Union{T, Nothing}` allows
setting it either to a value of type `T`, or to `nothing` to indicate that there is no value.
See [this FAQ entry](@ref faq-nothing) for more information.
--><p>特に有益な<code>合併型</code>は<code>Union{T, Nothing}</code>です。 ここで<code>T</code>は任意の型、<a href="../base/base.html#Core.Nothing"><code>Nothing</code></a>は唯一のインスタンスがオブジェクト<a href="../base/constants.html#Core.nothing"><code>nothing</code></a>だけのシングルトン型です。 Juliaのこのパターンは、他の言語の<a href="https://en.wikipedia.org/wiki/Nullable_type"><code>Nullable</code>,<code>Option</code>,<code>Maybe</code></a>型と同等です。 関数の引数やフィールドを<code>Union{T, Nothing}</code>として宣言すると、型<code>T</code>の値か、値がないことを示す<code>nothing</code>のどちらかに設定することができます。 詳細な情報は<a href="manual/@ref faq-nothing">FAQのこの項目</a>を参照してください。</p><p>`<a href="## Parametric Types"></a></p><h2><a class="nav-anchor" id="パラメータ型-1" href="#パラメータ型-1">パラメータ型</a></h2><!--
An important and powerful feature of Julia's type system is that it is parametric: types can take
parameters, so that type declarations actually introduce a whole family of new types -- one for
each possible combination of parameter values. There are many languages that support some version
of [generic programming](https://en.wikipedia.org/wiki/Generic_programming), wherein data structures
and algorithms to manipulate them may be specified without specifying the exact types involved.
For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#,
F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism
(e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming
(e.g. C++, Java). With so many different varieties of generic programming and parametric types
in various languages, we won't even attempt to compare Julia's parametric types to other languages,
but will instead focus on explaining Julia's system in its own right. We will note, however, that
because Julia is a dynamically typed language and doesn't need to make all type decisions at compile
time, many traditional difficulties encountered in static parametric type systems can be relatively
easily handled.
--><p>Juliaの型システムには、パラメータ化可能という重要かつ強力な特徴があります。  型にパラメータをつけると、型宣言は実質的に、とりうるパラメータ組み合わせに対応する、新しい型の種族全体を導入することになります。  多くの言語が<a href="https://en.wikipedia.org/wiki/Generic_programming">汎化プログラミング</a>に何らかの形で対応しています。 これは、必要な型を正確に指定しなくても、処理すべきデータ構造やアルゴリズムを特定することができます。  たとえば少し挙げるだけでも、ML、Haskell、Ada、Eiffel、C++、Java、C＃、F＃、およびScalaなどが、何らかの形で汎化プログラミングを取り入れています。  これらの言語の中には真のパラメータ多相（ML、Haskell、Scalaなど）に対応するものもあれば、テンプレートベースの汎化プログラミング（C ++、Javaなど）の形で対応するものもあります。  言語によって汎化プログラミングやパラメータ型は多種多様であるため、Juliaのパラメータ型を他の言語と比較することはせず、Julia自体のシステムについて説明することに専念します。   しかし、Juliaは動的型付け言語で、コンパイル時にすべての型を決定する必要はないため、静的パラメータ型付け言語の多くで生じる従来の困難が、比較的簡単に扱えることを注記しておきます。</p><!--
All declared types (the `DataType` variety) can be parameterized, with the same syntax in each
case. We will discuss them in the following order: first, parametric composite types, then parametric
abstract types, and finally parametric primitive types.
--><p>すべての宣言型（<code>DataType</code>の仲間）は、それぞれ同じ構文でパラメータ化できます。  まず、パラメータ複合型、次にパラメータ抽象型、最後にパラメータプリミティブ型という順番で説明します。</p><p>`<a href="### Parametric Composite Types"></a></p><h3><a class="nav-anchor" id="パラメータ複合型-1" href="#パラメータ複合型-1">パラメータ複合型</a></h3><!--
Type parameters are introduced immediately after the type name, surrounded by curly braces:
--><p>型パラメータを導入するには、型名の直後に、中括弧で囲んで挿入します。</p><pre><code class="language-julia-repl">julia&gt; struct Point{T}
           x::T
           y::T
       end</code></pre><!--
This declaration defines a new parametric type, `Point{T}`, holding two "coordinates" of type
`T`. What, one may ask, is `T`? Well, that's precisely the point of parametric types: it can be
any type at all (or a value of any bits type, actually, although here it's clearly used as a type).
`Point{Float64}` is a concrete type equivalent to the type defined by replacing `T` in the definition
of `Point` with [`Float64`](@ref). Thus, this single declaration actually declares an unlimited
number of types: `Point{Float64}`, `Point{AbstractString}`, `Point{Int64}`, etc. Each of these
is now a usable concrete type:
--><p>この宣言では、型が<code>T</code>の２つの「座標」を保持している新しいパラメータ型<code>Point{T}</code>を定義しています。  <code>T</code>とはなんだ、と誰かが尋ねるかもしれません。これがまさしくパラメータ型のポイントです。  どんな型（実際にはプリミティブ型の値でも構いませんが、ここでは明らかに型が使われています）でもかまいません。  <code>Point{Float64}</code>は、<code>Point</code> の定義で<code>T</code>を <code>Float64</code>と置き換えたものと同等な具象型です。  よって、一つの宣言が実質的には、<code>Point{Float64}</code>、<code>Point{AbstractString}</code>、<code>Point{Int64}</code>などの無限の宣言に相当します。  そして、それぞれが、具象型として利用可能です。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64}
Point{Float64}

julia&gt; Point{AbstractString}
Point{AbstractString}</code></pre><!--
The type `Point{Float64}` is a point whose coordinates are 64-bit floating-point values, while
the type `Point{AbstractString}` is a "point" whose "coordinates" are string objects (see [Strings](@ref)).

`Point` itself is also a valid type object, containing all instances `Point{Float64}`, `Point{AbstractString}`,
etc. as subtypes:
--><p><code>Point{Float64}</code>という型は、座標が64ビット浮動小数点数の点であり、<code>Point{AbstractString}</code>は、その「座標」が文字列オブジェクトの「点」です（<a href="manual/@ref">文字列</a>を参照）。</p><p>Pointは自身が有効な型オブジェクトで、<code>Point{Float64}</code>、<code>Point{AbstractString}</code>などすべてのインスタンスをサブタイプとして含んでいます。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point
true

julia&gt; Point{AbstractString} &lt;: Point
true</code></pre><!--
Other types, of course, are not subtypes of it:
--><p>他の型は当然このサブタイプではありません。</p><pre><code class="language-julia-repl">julia&gt; Float64 &lt;: Point
false

julia&gt; AbstractString &lt;: Point
false</code></pre><!--
Concrete `Point` types with different values of `T` are never subtypes of each other:
--><p>異なる<code>T</code>の値がついた具象型<code>Point</code>は決して互いにサブタイプとなることはありません。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Point{Int64}
false

julia&gt; Point{Float64} &lt;: Point{Real}
false</code></pre><!--
!!! warning
    This last point is *very* important: even though `Float64 <: Real` we **DO NOT** have `Point{Float64} <: Point{Real}`.
--><div class="admonition warning"><div class="admonition-title">警告</div><div class="admonition-text"><p>この最後の点は <strong>非常に</strong> 重要です。<code>Float64 &lt;: Real</code>は成り立つにもかかわらず、<code>Point{Float64} &lt;: Point{Real}</code>は　<strong>成り立ちません</strong>。</p></div></div><!--
In other words, in the parlance of type theory, Julia's type parameters are *invariant*, rather
than being [covariant (or even contravariant)](https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29). This is for practical reasons: while any instance
of `Point{Float64}` may conceptually be like an instance of `Point{Real}` as well, the two types
have different representations in memory:
--><p>型理論の術語で言い換えると、Juliaの型パラメータは <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29">covariant (or even contravariant)</a>ではなく、<strong>不変</strong> です。 これは現実的の理由によります。 <code>{Float64}</code>のインスタンスは<code>Point{Real}</code> のインスタンスと概念的には似ているかもしれませんが、２つ型のメモリ内の表現は異なります。</p><!--
  * An instance of `Point{Float64}` can be represented compactly and efficiently as an immediate pair
    of 64-bit values;
  * An instance of `Point{Real}` must be able to hold any pair of instances of [`Real`](@ref).
    Since objects that are instances of `Real` can be of arbitrary size and structure, in
    practice an instance of `Point{Real}` must be represented as a pair of pointers to
    individually allocated `Real` objects.
--><ul><li><p><code>Point{Float64}</code>のインスタンスは、64ビット値の隣接する組としてコンパクトで効率的に表現できます。</p></li><li><p><code>Point{Real}</code> のインスタンスは、どんな<a href="../base/numbers.html#Core.Real"><code>Real</code></a>の組でも保持できる必要があります。</p></li></ul><p><code>Real</code>のインスタンスとなるオブジェクトは任意のサイズや構造になりうるので、現実的には、<code>Point{Real}</code>のインスタンスは、個別に配置された<code>Real</code>オブジェクトへのポインタの組として表現する必要があります。</p><!--
The efficiency gained by being able to store `Point{Float64}` objects with immediate values is
magnified enormously in the case of arrays: an `Array{Float64}` can be stored as a contiguous
memory block of 64-bit floating-point values, whereas an `Array{Real}` must be an array of pointers
to individually allocated [`Real`](@ref) objects -- which may well be
[boxed](https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing)
64-bit floating-point values, but also might be arbitrarily large, complex objects, which are
declared to be implementations of the `Real` abstract type.
--><p><code>Point{Float64}</code>オブジェクトに、値を直接を格納できると、得られる効率は、配列の場合、非常に大きくなります。  <code>Array{Float64}</code>は、64ビットの浮動小数点数の連続したメモリブロックとして格納されますが、<code>Array{Real}</code>はそれぞれ別々に配置された<code>Real</code>オブジェクトへのポインタの配列でなければなりません。  抽象型<code>Real</code>に宣言されたオブジェクトの実装は、64ビットの浮動小数点数が<a href="https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing">ボックス化</a>されていても構わないし、任意の大きさの複雑なオブジェクトでもかまいません。</p><!--
Since `Point{Float64}` is not a subtype of `Point{Real}`, the following method can't be applied
to arguments of type `Point{Float64}`:
--><p><code>Point{Float64}</code>は、<code>Point{Real}</code>のサブタイプではないので、 以下のメソッドを型<code>Point{Float64}</code>の引数に適用することはできません。</p><pre><code class="language-julia">function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><!--
A correct way to define a method that accepts all arguments of type `Point{T}` where `T` is
a subtype of [`Real`](@ref) is:
--><p><code>T</code>が<a href="../base/numbers.html#Core.Real"><code>Real</code></a>のサブタイプとなる<code>Point{T}</code>の型すべてを、 引数として許容するメソッドを正しく定義する方法は次のとおりです。</p><pre><code class="language-julia">function norm(p::Point{&lt;:Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><!--
(Equivalently, one could define `function norm(p::Point{T} where T<:Real)` or
`function norm(p::Point{T}) where T<:Real`; see [UnionAll Types](@ref).)

More examples will be discussed later in [Methods](@ref).

How does one construct a `Point` object? It is possible to define custom constructors for composite
types, which will be discussed in detail in [Constructors](@ref man-constructors), but in the absence of any special
constructor declarations, there are two default ways of creating new composite objects, one in
which the type parameters are explicitly given and the other in which they are implied by the
arguments to the object constructor.

Since the type `Point{Float64}` is a concrete type equivalent to `Point` declared with [`Float64`](@ref)
in place of `T`, it can be applied as a constructor accordingly:
--><p>（同等の定義として、<code>function norm{T&lt;:Real}(p::Point{T})</code>や、<code>function norm(p::Point{T} where T&lt;:Real)</code>があります。（<a href="types.html#全合併型-1">全合併型</a> を参照。）</p><p>より多くの例については、後の <a href="methods.html#メソッド-1">メソッド</a> で説明します。</p><p><code>Point</code>オブジェクトはどのように構成するのでしょうか。 [コンストラクタ]（@ ref man-constructor）で詳しく説明しますが、複合型にに対して独自のコンストラクタを定義することは可能ですが、特別にコンストラクタの宣言をしなくても、デフォルトで新しい複合型オブジェクトを作成する方法が2通りあります。1つは型パラメータを明示的に与えるもの、もう1つはオブジェクトコンストラクタへの引数から暗黙裡に推定されるものです。</p><p>型<code>Point{Float64}</code>は、<code>T</code>の代わりに<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> を使って宣言した<code>Point</code>と同等の具象型なので、<code>Point</code>と同じようなコンストラクタとしてそのまま適用できます。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}</code></pre><!--
For the default constructor, exactly one argument must be supplied for each field:
--><p>デフォルトのコンストラクタには、各フィールドに対してちょうど1つ引数を指定する必要があります。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64}(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]

julia&gt; Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]</code></pre><!--
Only one default constructor is generated for parametric types, since overriding it is not possible.
This constructor accepts any arguments and converts them to the field types.

In many cases, it is redundant to provide the type of `Point` object one wants to construct, since
the types of arguments to the constructor call already implicitly provide type information. For
that reason, you can also apply `Point` itself as a constructor, provided that the implied value
of the parameter type `T` is unambiguous:
--><p>パラメータ型に対しては、デフォルトのコンストラクタは1つしか生成されません。 オーバーライドできないためです。 このコンストラクタは任意の引数を受け取って、フィールドの型に変換します。</p><p>多くの場合、生成したい<code>Point</code>オブジェクトの型を指定するのは冗長です。  <code>Point</code>コンストラクタを呼び出す際の引数に、すでに型情報が隠れているからです。  そのため、<code>Point</code>のパラメータの型<code>T</code>が推定可能で曖昧さがない場合は、<code>Point</code>自体をコンストラクタとして適用することも可能です。</p><pre><code class="language-julia-repl">julia&gt; Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia&gt; typeof(ans)
Point{Float64}

julia&gt; Point(1,2)
Point{Int64}(1, 2)

julia&gt; typeof(ans)
Point{Int64}</code></pre><!--
In the case of `Point`, the type of `T` is unambiguously implied if and only if the two arguments
to `Point` have the same type. When this isn't the case, the constructor will fail with a [`MethodError`](@ref):
--><p><code>Point</code>の場合、2つの引数が同じ型を持つ場合にのみ、型<code>T</code>は明確に推定されます。 これ以外の場合、コンストラクタは失敗して、 <a href="../base/base.html#Core.MethodError"><code>MethodError</code></a> が発生します。</p><pre><code class="language-julia-repl">julia&gt; Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2</code></pre><!--
Constructor methods to appropriately handle such mixed cases can be defined, but that will not
be discussed until later on in [Constructors](@ref man-constructors).
--><p>このような型の混ざった場合でも適切に処理するコンストラクタメソッドは定義可能ですが、後述の[コンストラクタ]（@ ref man-constructors）まで議論を保留します。</p><p>`<a href="### Parametric Abstract Types"></a></p><h3><a class="nav-anchor" id="パラメータ抽象型-1" href="#パラメータ抽象型-1">パラメータ抽象型</a></h3><!--
Parametric abstract type declarations declare a collection of abstract types, in much the same
way:
--><p>パラメータ抽象型に対しても、ほぼ同じ方法で、一群の抽象型に対して型宣言を行います。</p><pre><code class="language-julia-repl">julia&gt; abstract type Pointy{T} end</code></pre><!--
With this declaration, `Pointy{T}` is a distinct abstract type for each type or integer value
of `T`. As with parametric composite types, each such instance is a subtype of `Pointy`:
--><p>この宣言では、<code>T</code>は型や整数値を表し、<code>Pointy{T}</code>は、それぞれの<code>T</code>に対して別の抽象型になります。 パラメータ複合型と同様に、各インスタンスは<code>Pointy</code>のサブタイプです。</p><pre><code class="language-julia-repl">julia&gt; Pointy{Int64} &lt;: Pointy
true

julia&gt; Pointy{1} &lt;: Pointy
true</code></pre><!--
Parametric abstract types are invariant, much as parametric composite types are:
--><p>パラメータ抽象型は、パラメータ複合型と同じように不変です。</p><pre><code class="language-julia-repl">julia&gt; Pointy{Float64} &lt;: Pointy{Real}
false

julia&gt; Pointy{Real} &lt;: Pointy{Float64}
false</code></pre><!--
The notation `Pointy{<:Real}` can be used to express the Julia analogue of a
*covariant* type, while `Pointy{>:Int}` the analogue of a *contravariant* type,
but technically these represent *sets* of types (see [UnionAll Types](@ref)).
--><p>Juliaでは、<code>Pointy{&lt;:Real}</code>という表記で <strong>共変型*** のようなもの、<code>Pointy{&gt;:Int}</code>で **反変型</strong> のようなものを表現できます。 しかし、技術的には、これらは型の集合を表しています。(<a href="types.html#全合併型-1">全合併型</a> 参照)</p><pre><code class="language-julia-repl">julia&gt; Pointy{Float64} &lt;: Pointy{&lt;:Real}
true

julia&gt; Pointy{Real} &lt;: Pointy{&gt;:Int}
true</code></pre><!--
Much as plain old abstract types serve to create a useful hierarchy of types over concrete types,
parametric abstract types serve the same purpose with respect to parametric composite types. We
could, for example, have declared `Point{T}` to be a subtype of `Pointy{T}` as follows:
--><p>通常の抽象型は、具象型に対する有益な型の階層の作成に使いますが、パラメータ抽象型はパラメータ複合型と同じような目的で使います。 たとえば、<code>Point{T}</code>を<code>Pointy{T}</code>のサブタイプとする宣言は次のようにできます。</p><pre><code class="language-julia-repl">julia&gt; struct Point{T} &lt;: Pointy{T}
           x::T
           y::T
       end</code></pre><!--
Given such a declaration, for each choice of `T`, we have `Point{T}` as a subtype of `Pointy{T}`:
--><p>この宣言で、それぞれの選んた<code>T</code>に対して、<code>Point{T}</code>は<code>Pointy{T}</code>のサブタイプとなります。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Pointy{Float64}
true

julia&gt; Point{Real} &lt;: Pointy{Real}
true

julia&gt; Point{AbstractString} &lt;: Pointy{AbstractString}
true</code></pre><!--
This relationship is also invariant:
--><p>この関係も不変です。</p><pre><code class="language-julia-repl">julia&gt; Point{Float64} &lt;: Pointy{Real}
false

julia&gt; Point{Float64} &lt;: Pointy{&lt;:Real}
true</code></pre><!--
What purpose do parametric abstract types like `Pointy` serve? Consider if we create a point-like
implementation that only requires a single coordinate because the point is on the diagonal line
*x = y*:
--><p><code>Pointy</code>のようなパラメータ抽象型はなんの役に立つのでしょうか。 対角線　<strong>x = y</strong>　上にあるため、座標1つのみを必要とする点状のものを実装する場合を考えましょう。</p><pre><code class="language-julia-repl">julia&gt; struct DiagPoint{T} &lt;: Pointy{T}
           x::T
       end</code></pre><!--
Now both `Point{Float64}` and `DiagPoint{Float64}` are implementations of the `Pointy{Float64}`
abstraction, and similarly for every other possible choice of type `T`. This allows programming
to a common interface shared by all `Pointy` objects, implemented for both `Point` and `DiagPoint`.
This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the
next section, [Methods](@ref).

There are situations where it may not make sense for type parameters to range freely over all
possible types. In such situations, one can constrain the range of `T` like so:
--><p>ここで<code>Point{Float64}</code>と<code>DiagPoint{Float64}</code>は共に、抽象型<code>Pointy{Float64}</code>の実装で、これは<code>T</code>に他のとりうる型を選んでも同じです。 これにより<code>Point</code>と<code>DiagPoint</code>のどちらを実装するにも、<code>Pointy</code>オブジェクトを共通のインタフェースにするようなプログラミングが可能になります。 しかし、完全な解説は、メソッドとディスパッチを導入する次の章<a href="methods.html#メソッド-1">メソッド</a> に持ち越します。</p><p>型のパラメータのとりうる型を自由にしてしまうと、意味を成さない場合があります。 そのような状況では、次のように、<code>T</code>の範囲を制限することができます。</p><pre><code class="language-julia-repl">julia&gt; abstract type Pointy{T&lt;:Real} end</code></pre><!--
With such a declaration, it is acceptable to use any type that is a subtype of
[`Real`](@ref) in place of `T`, but not types that are not subtypes of `Real`:
--><p>この宣言では、<code>T</code>が任意の<a href="../base/numbers.html#Core.Real"><code>Real</code></a>のサブタイプの場合で許容されますが、 <code>Real</code>のサブタイプでなければ許容されません。</p><pre><code class="language-julia-repl">julia&gt; Pointy{Float64}
Pointy{Float64}

julia&gt; Pointy{Real}
Pointy{Real}

julia&gt; Pointy{AbstractString}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Type{AbstractString}

julia&gt; Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T&lt;:Real, got Int64</code></pre><!--
Type parameters for parametric composite types can be restricted in the same manner:
--><p>パラメータ複合型の型パラメータも、同じ方法で制限できます。</p><pre><code class="language-julia">struct Point{T&lt;:Real} &lt;: Pointy{T}
    x::T
    y::T
end</code></pre><!--
To give a real-world example of how all this parametric type machinery can be useful, here is
the actual definition of Julia's [`Rational`](@ref) immutable type (except that we omit the
constructor here for simplicity), representing an exact ratio of integers:
--><p>実世界でパラメータ型という仕組みがどれほど役立つかという例として、 ここでは整数の比を表す<a href="../base/numbers.html#Base.Rational"><code>Rational</code></a> という不変型を、Juliaで実際にどう定義するかを示します。 （単純化のため、ここではコンストラクタを省略します）</p><pre><code class="language-julia">struct Rational{T&lt;:Integer} &lt;: Real
    num::T
    den::T
end</code></pre><!--
It only makes sense to take ratios of integer values, so the parameter type `T` is restricted
to being a subtype of [`Integer`](@ref), and a ratio of integers represents a value on the
real number line, so any [`Rational`](@ref) is an instance of the [`Real`](@ref) abstraction.
--><p>整数値の比率になる時だけ、意味をなすので、パラメータの型<code>T</code>は、<a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>のサブタイプに限定されています。 整数の比は数直線上の値を表現するので、任意の<a href="../base/numbers.html#Base.Rational"><code>Rational</code></a> は、抽象型 <a href="../base/numbers.html#Core.Real"><code>Real</code></a> のインスタンスです。</p><p>`<a href="### Tuple Types"></a></p><h3><a class="nav-anchor" id="タプル型-1" href="#タプル型-1">タプル型</a></h3><!--
Tuples are an abstraction of the arguments of a function -- without the function itself. The salient
aspects of a function's arguments are their order and their types. Therefore a tuple type is similar
to a parameterized immutable type where each parameter is the type of one field. For example,
a 2-element tuple type resembles the following immutable type:
--><p>タプルとは関数本体からその引数だけを抜き出したものです。 関数の引数の目立った特徴は、順序と型です。 そのため、タプル型は、不変なパラメータ複合型で各パラメータがフィールドの型に対応しているものと似ています。 たとえば、2要素のタプル型は、次の複合型に似ています。</p><pre><code class="language-julia">struct Tuple2{A,B}
    a::A
    b::B
end</code></pre><!--
However, there are three key differences:

  * Tuple types may have any number of parameters.
  * Tuple types are *covariant* in their parameters: `Tuple{Int}` is a subtype of `Tuple{Any}`. Therefore
    `Tuple{Any}` is considered an abstract type, and tuple types are only concrete if their parameters
    are.
  * Tuples do not have field names; fields are only accessed by index.
--><p>ただし、3つの重要な違いがあります。 </p><ul><li>タプル型は、任意の数のパラメータを持つことができます。</li><li>タプル型は、そのパラメータと <strong>共変</strong> です。<code>Tuple{Int}</code>は<code>Tuple{Any}</code>のサブタイプです。したがって <code>Tuple{Any}</code>は、抽象型と見なされます。タプル型は、そのパラメータが具象型の場合にのみ具象型です。</li><li>タプルにはフィールド名はありません。フィールドにはインデックスによってのみアクセスできます。</li></ul><!--
Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate
tuple type is generated on demand:
--><p>タプルの値は、括弧とカンマをつかって書きます。タプルが生成されると、必要に応じて適切なタプル型が生成されます。</p><pre><code class="language-julia-repl">julia&gt; typeof((1,&quot;foo&quot;,2.5))
Tuple{Int64,String,Float64}</code></pre><!--
Note the implications of covariance:
--><p>暗黙的に共変となる点に注目してください。</p><pre><code class="language-julia-repl">julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Any}
true

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,Real}
false

julia&gt; Tuple{Int,AbstractString} &lt;: Tuple{Real,}
false</code></pre><!--
Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's
signature (when the signature matches).
--><p>直観的には、これは、関数の引数の型が関数のシグネチャのサブタイプであることに相当します（シグネチャが適合する場合）。</p><p>`<a href="### Vararg Tuple Types"></a></p><h3><a class="nav-anchor" id="可変引数タプル型-1" href="#可変引数タプル型-1">可変引数タプル型</a></h3><!--
The last parameter of a tuple type can be the special type [`Vararg`](@ref), which denotes any number
of trailing elements:
--><p>タプル型の最後のパラメータは、特殊な型である<a href="manual/@ref"><code>可変引数</code></a>にすることが可能で、任意個数の後続の要素を表します。</p><pre><code class="language-julia-repl">julia&gt; mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia&gt; isa((&quot;1&quot;,), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2), mytupletype)
true

julia&gt; isa((&quot;1&quot;,1,2,3.0), mytupletype)
false</code></pre><!--
Notice that `Vararg{T}` corresponds to zero or more elements of type `T`. Vararg tuple types are
used to represent the arguments accepted by varargs methods (see [Varargs Functions](@ref)).

The type `Vararg{T,N}` corresponds to exactly `N` elements of type `T`.  `NTuple{N,T}` is a convenient
alias for `Tuple{Vararg{T,N}}`, i.e. a tuple type containing exactly `N` elements of type `T`.
--><p><code>Vararg{T}</code>は、0個以上の型<code>T</code>に対応することに注意してください。 可変引数タプル型は、可変引数メソッドによって受け入れられる引数を表すために使用されます（<a href="functions.html#可変引数関数-1">可変引数関数</a>を参照）。</p><p>型<code>Vararg{T,N}</code>は、ちょうど<code>N</code>個の型<code>T</code>に対応します。 <code>NTuple{N,T}</code>は<code>Tuple{Vararg{T,N}}</code>の便利なエイリアスです。 つまり、型<code>T</code>の要素をちょうど<code>N</code>個含むタプル型です。</p><p>`<a href="### Named Tuple Types"></a></p><h3><a class="nav-anchor" id="名前付きタプル型-1" href="#名前付きタプル型-1">名前付きタプル型</a></h3><!--
Named tuples are instances of the [`NamedTuple`](@ref) type, which has two parameters: a tuple of
symbols giving the field names, and a tuple type giving the field types.
--><p>名前付きタプル型は、 <a href="../base/base.html#Core.NamedTuple"><code>NamedTuple</code></a> 型のインスタンスで、2つのパラメータを取ります。 シンボルのタプルはフィールド名を与え、型のタプルはフィールドの型を与えます。</p><pre><code class="language-julia-repl">julia&gt; typeof((a=1,b=&quot;hello&quot;))
NamedTuple{(:a, :b),Tuple{Int64,String}}</code></pre><!--
A `NamedTuple` type can be used as a constructor, accepting a single tuple argument.
The constructed `NamedTuple` type can be either a concrete type, with both parameters specified,
or a type that specifies only field names:
--><p><code>NamedTuple</code>型はコンストラクタとしても利用可能で、１個のタプルを引数としてとります。 生成された<code>NamedTuple</code>の型は、両方のパラメータの指定された具象型か、フィールド名だけがしていされた型になります。</p><pre><code class="language-julia-repl">julia&gt; NamedTuple{(:a, :b),Tuple{Float32, String}}((1,&quot;&quot;))
(a = 1.0f0, b = &quot;&quot;)

julia&gt; NamedTuple{(:a, :b)}((1,&quot;&quot;))
(a = 1, b = &quot;&quot;)</code></pre><!--
If field types are specified, the arguments are converted. Otherwise the types of the arguments
are used directly.
--><p>フィールドの型を指定した時は、引数は変換されます。 そうでない場合は、引数の型がそのまま使われます。</p><p>`<a href="#### [Singleton Types](@id man-singleton-types)"></a></p><h4><a class="nav-anchor" id="man-singleton-types-1" href="#man-singleton-types-1">シングルトン型</a></h4><!--
There is a special kind of abstract parametric type that must be mentioned here: singleton types.
For each type, `T`, the "singleton type" `Type{T}` is an abstract type whose only instance is
the object `T`. Since the definition is a little difficult to parse, let's look at some examples:
--><p>ここで、特殊なパラメータ抽象型であるシングルトン型について触れておくべきでしょう。 型<code>T</code>それぞれに対して、 「シングルトン型」 <code>Type{T}</code>は、インスタンスが<code>T</code>唯一つだけの抽象型です。 定義を構文的に説明するのは少し難しいので、例をいくつか見てみましょう。</p><pre><code class="language-julia-repl">julia&gt; isa(Float64, Type{Float64})
true

julia&gt; isa(Real, Type{Float64})
false

julia&gt; isa(Real, Type{Real})
true

julia&gt; isa(Float64, Type{Real})
false</code></pre><!--
In other words, [`isa(A,Type{B})`](@ref) is true if and only if `A` and `B` are the same object
and that object is a type. Without the parameter, `Type` is simply an abstract type which has
all type objects as its instances, including, of course, singleton types:
--><p>換言すると、<a href="../base/base.html#Core.isa"><code>isa(A,Type{B})</code></a> は、<code>A</code>と<code>B</code>が同じオブジェクトであり、そのオブジェクトとは型であるのみ真になります。 パラメータをつけない<code>Type</code>は、単なる抽象型であり、すべての型オブジェクトは<code>Type</code>のインスタンスです（もちろん、シングルトン型も含みます）。</p><pre><code class="language-julia-repl">julia&gt; isa(Type{Float64}, Type)
true

julia&gt; isa(Float64, Type)
true

julia&gt; isa(Real, Type)
true</code></pre><!--
Any object that is not a type is not an instance of `Type`:
--><p>型ではないオブジェクトは、<code>Type</code>のインスタンスではありません。</p><pre><code class="language-julia-repl">julia&gt; isa(1, Type)
false

julia&gt; isa(&quot;foo&quot;, Type)
false</code></pre><!--
Until we discuss [Parametric Methods](@ref) and [conversions](@ref conversion-and-promotion), it is difficult to explain
the utility of the singleton type construct, but in short, it allows one to specialize function
behavior on specific type *values*. This is useful for writing methods (especially parametric
ones) whose behavior depends on a type that is given as an explicit argument rather than implied
by the type of one of its arguments.

A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage,
the term "singleton type" refers to a type whose only instance is a single value. This meaning
applies to Julia's singleton types, but with that caveat that only type objects have singleton
types.
--><p><a href="methods.html#パラメータメソッド-1">パラメータメソッド</a>と<a href="conversion-and-promotion.html#conversion-and-promotion-1">変換</a>の議論がすむまで、 シングルトン型がどう役に立つのかを説明するのは難しいですが、手短にいうと、関数の挙動を特定の型の<strong>値</strong>だけに特化することができるのです。 これが役に立つのは、挙動が型に依存する（特にパラメトリックな）メソッドを書く時で、 しかもその型が勝手に推測されるのではなく、わざわざ引数として与える場合です。</p><p>Haskell、Scala、Rubyなどの人気のある言語には、シングルトン型が備わっています。 一般的な用法では、「シングルトン型」という術語は、唯一のインスタンスがで単一の値である型を指します。 この意味はJuliaのシングルトン型にも当てはまりますが、型オブジェクトだけがシングルトン型になるという点に注意してください。</p><p>`<a href="### Parametric Primitive Types"></a></p><h3><a class="nav-anchor" id="パラメータプリミティブ型-1" href="#パラメータプリミティブ型-1">パラメータプリミティブ型</a></h3><!--
Primitive types can also be declared parametrically. For example, pointers are represented as
primitive types which would be declared in Julia like this:
--><p>プリミティブ型にもパラメータをつけて宣言することができます。 たとえば、ポインタはプリミティブ型として表現できて、Juliaでは以下のように宣言します。</p><pre><code class="language-julia"># 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end</code></pre><!--
The slightly odd feature of these declarations as compared to typical parametric composite types,
is that the type parameter `T` is not used in the definition of the type itself -- it is just
an abstract tag, essentially defining an entire family of types with identical structure, differentiated
only by their type parameter. Thus, `Ptr{Float64}` and `Ptr{Int64}` are distinct types, even though
they have identical representations. And of course, all specific pointer types are subtypes of
the umbrella [`Ptr`](@ref) type:
--><p>一般的なパラメータ複合型と比べて、この宣言のちょっと変な特徴は、型パラメータ<code>T</code>が型自体の定義に使われていないことです。 つまり、型パラメータは抽象的なタグであり、本質的に同一の構造である型の族全体をに定義し、型パラメータだけで差別化されています。 そのため、<code>Ptr{Float64}</code>と<code>Ptr{Int64}</code>は、表現は同一であっても、型としては異なります。 もちろん、個別のポインタ型はすべて、包括型<code>Ptr</code>のサブタイプです。</p><pre><code class="language-julia-repl">julia&gt; Ptr{Float64} &lt;: Ptr
true

julia&gt; Ptr{Int64} &lt;: Ptr
true</code></pre><p>`<a href="## UnionAll Types"></a></p><h2><a class="nav-anchor" id="全合併型-1" href="#全合併型-1">全合併型</a></h2><!--
We have said that a parametric type like `Ptr` acts as a supertype of all its instances
(`Ptr{Int64}` etc.). How does this work? `Ptr` itself cannot be a normal data type, since without
knowing the type of the referenced data the type clearly cannot be used for memory operations.
The answer is that `Ptr` (or other parametric types like `Array`) is a different kind of type called a
[`UnionAll`](@ref) type. Such a type expresses the *iterated union* of types for all values of some parameter.

`UnionAll` types are usually written using the keyword `where`. For example `Ptr` could be more
accurately written as `Ptr{T} where T`, meaning all values whose type is `Ptr{T}` for some value
of `T`. In this context, the parameter `T` is also often called a "type variable" since it is
like a variable that ranges over types.
Each `where` introduces a single type variable, so these expressions are nested for types with
multiple parameters, for example `Array{T,N} where N where T`.
--><p><code>Ptr</code>のようなパラメータ型はすべてのインスタンス（<code>Ptr{Int64}</code>など）のスーパータイプのように振る舞うと前に述べましました。 これはどのようにして実現しているのでしょうか？ <code>Ptr</code>自体は通常のデータ型ではありえません。というのも、参照するデータの型が分からなければ、 明らかに、その型を記憶操作に使用できないからです。 答えは、<code>Ptr</code>の型（また他の<code>Array</code>のようなパラメータ型）は、<code>全合併型</code>と呼ばれる種類の異なる型です 。 この型は、あるパラメータをすべての値に対して <strong>繰り返し合併した</strong> 型を表現します。</p><p>全合併型は、通常、キーワード<code>where</code>を使って記述されます。 例えば、<code>Ptr</code>は、より正確には<code>Ptr{T} where T</code>と書くことができて、ある<code>T</code>という値によって<code>Ptr{T}</code>と書ける型をもつ値すべてを意味します。 この文脈では、パラメータ<code>T</code>は型をまたぐ変数のようなものであるため、よく「型変数」と呼ばれます。 それぞれの<code>where</code>は型変数を一つ導入するため、こういった式は複数のパラメータを持つ場合、 例えば<code>Array{T,N} where N where T</code>のように、型に対してネストします。</p><!--
The type application syntax `A{B,C}` requires `A` to be a `UnionAll` type, and first substitutes `B`
for the outermost type variable in `A`.
The result is expected to be another `UnionAll` type, into which `C` is then substituted.
So `A{B,C}` is equivalent to `A{B}{C}`.
This explains why it is possible to partially instantiate a type, as in `Array{Float64}`: the first
parameter value has been fixed, but the second still ranges over all possible values.
Using explicit `where` syntax, any subset of parameters can be fixed. For example, the type of all
1-dimensional arrays can be written as `Array{T,1} where T`.

Type variables can be restricted with subtype relations.
`Array{T} where T<:Integer` refers to all arrays whose element type is some kind of
[`Integer`](@ref).
The syntax `Array{<:Integer}` is a convenient shorthand for `Array{T} where T<:Integer`.
Type variables can have both lower and upper bounds.
`Array{T} where Int<:T<:Number` refers to all arrays of [`Number`](@ref)s that are able to
contain `Int`s (since `T` must be at least as big as `Int`).
The syntax `where T>:Int` also works to specify only the lower bound of a type variable,
and `Array{>:Int}` is equivalent to `Array{T} where T>:Int`.
--><p>型の適用構文<code>A{B,C}</code>には、<code>A</code>が全合併型であることが必要です。 まず<code>A</code>の一番外側の型変数を<code>B</code>で置換します。 その結果は別の<code>全合併</code>型になることと想定されているので、<code>C</code>で置換します。 よって<code>A{B,C}</code>と<code>A{B}{C}</code>は同等です。 これは<code>Array{Float64}</code>のように、型を部分的にインスタンス化することができる理由の説明となっています。 最初のパラメータの値は固定されていますが、2番目の値はすべてのとりうる値にまたがっているからです。 明示的に<code>where</code>構文を使用すると、どんなパラメータの部分集合にでも固定できます。 例えば、すべての1次元配列の型は、<code>Array{T,1} where T</code>と書くことができます。</p><p>型変数は、サブタイプの関係をつかって制限することができます。 <code>Array{T} where T&lt;:Integer</code>は、配列で要素の型が<a href="../base/numbers.html#Core.Integer"><code>Integer</code></a>のいずれかになるものすべてを指しています。 構文<code>Array{&lt;:Integer}</code>は<code>Array{T} where T&lt;:Integer</code>の便利な簡略表記です。 型変数は、下限と上限の両方を指定することができます。 <code>Array{T} where Int&lt;:T&lt;:Number</code>は <a href="../base/numbers.html#Core.Number"><code>Number</code></a>の配列で<code>Int</code>を含みうるものすべてを指します（少なくとも、<code>T</code> は<code>Int</code>以上大きくなければなりません）。 構文<code>where T&gt;:Int</code>はまた、型変数の下限のみを指定していて、 <code>Array{&gt;:Int}</code>は、<code>Array{T} where T&gt;:Int</code>同等です。</p><!--
Since `where` expressions nest, type variable bounds can refer to outer type variables.
For example `Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real` refers to 2-tuples
whose first element is some [`Real`](@ref), and whose second element is an `Array` of any
kind of array whose element type contains the type of the first tuple element.

The `where` keyword itself can be nested inside a more complex declaration. For example,
consider the two types created by the following declarations:
--><p><code>where</code>式はネストする場合、型変数を限定する式は外側の型変数を参照することができます。 例えば、<code>Tuple{T,Array{S}} where S&lt;:AbstractArray{T} where T&lt;:Real</code>は、第1要素は<a href="../base/numbers.html#Core.Real"><code>Real</code></a>のいずれかで、 第2要素は、各要素が第1要素の型を含む型の配列である<strong>配列</strong>の、2要素-タプルを参照します。</p><p><code>where</code>キーワード自体は、より複雑な宣言の内側でネストすることができます。 たとえば、次の宣言で作成される2つの型を考えてみましょう。</p><pre><code class="language-julia-repl">julia&gt; const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia&gt; const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T</code></pre><!--
Type `T1` defines a 1-dimensional array of 1-dimensional arrays; each
of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next.
On the other hand, type `T2` defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the
same type.  Note that `T2` is an abstract type, e.g., `Array{Array{Int,1},1} <: T2`, whereas `T1` is a concrete type. As a consequence, `T1` can be constructed with a zero-argument constructor `a=T1()` but `T2` cannot.

There is a convenient syntax for naming such types, similar to the short form of function
definition syntax:
--><p>型<code>T1</code>は、1次元配列を要素とする、1次元配列を定義します。 内側の配列は同じ型のオブジェクトで構成されますが、この型は内側の配列ごとに異なる場合があります。 一方、型<code>T2</code>は、すべての内側の配列の型が等しい1次元配列の1次元配列を定義します。 <code>T2</code>は抽象型であり、<code>Array{Array{Int,1},1} &lt;: T2</code>であるのに対して、<code>T1</code>は具象型である点に注意してください。 したがって、<code>T1</code>は引数のないコンストラクタで<code>a=T1()</code>のように構築することはできますが、<code>T2</code>ではできません。</p><p>このような型を命名する便利な構文で、関数定義の短い形の構文と似ているものがあります：</p><pre><code class="language-julia">Vector{T} = Array{T,1}</code></pre><!--
This is equivalent to `const Vector = Array{T,1} where T`.
Writing `Vector{Float64}` is equivalent to writing `Array{Float64,1}`, and the umbrella type
`Vector` has as instances all `Array` objects where the second parameter -- the number of array
dimensions -- is 1, regardless of what the element type is. In languages where parametric types
must always be specified in full, this is not especially helpful, but in Julia, this allows one
to write just `Vector` for the abstract type including all one-dimensional dense arrays of any
element type.
--><p>これは<code>const Vector = Array{T,1} where T</code>と同等です。 <code>Vector{Float64}</code>と書くのは、<code>Array{Float64,1}</code>と書くのと同等です。 包括型の <code>Vector</code>がインスタンスとして持つのは、2番目のパラメータ（配列の次元数）が1である、要素の種類に関係ないすべての<code>Array</code>オブジェクトです。 パラメータ型を常に完全に指定しなければならない言語では、こういう構文はそんなに有用ではないかもしれません。 しかしJuliaでは、<code>Vector</code>と書くだけで、任意の要素型のすべての1次元の密な配列を含む抽象型を表すことができます。</p><p>`<a href="## Type Aliases"></a></p><h2><a class="nav-anchor" id="型エイリアス-1" href="#型エイリアス-1">型エイリアス</a></h2><!--
Sometimes it is convenient to introduce a new name for an already expressible type.
This can be done with a simple assignment statement.
For example, `UInt` is aliased to either [`UInt32`](@ref) or [`UInt64`](@ref) as is
appropriate for the size of pointers on the system:
--><p>すでに表現可能な型に新しい名前をつけると便利な場合が時々あります。 これは簡単な代入文で行うことができます。 たとえば、<code>UInt</code>は、システム上のポインタのサイズによって、<a href="../base/numbers.html#Core.UInt32"><code>UInt32</code></a> か <a href="../base/numbers.html#Core.UInt64"><code>UInt64</code></a>　のどちらかの別名となります。</p><pre><code class="language-julia-repl"># 32-bit system:
julia&gt; UInt
UInt32

# 64-bit system:
julia&gt; UInt
UInt64</code></pre><!--
This is accomplished via the following code in `base/boot.jl`:
--><p>これは<code>base/boot.jl</code>の中にある以下のコードで実現できます。</p><pre><code class="language-julia">if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end</code></pre><!--
Of course, this depends on what `Int` is aliased to -- but that is predefined to be the correct
type -- either [`Int32`](@ref) or [`Int64`](@ref).

(Note that unlike `Int`, `Float` does not exist as a type alias for a specific sized
[`AbstractFloat`](@ref). Unlike with integer registers, the floating point register sizes
are specified by the IEEE-754 standard. Whereas the size of `Int` reflects the size of a
native pointer on that machine.)
--><p>もちろん、これは <code>Int</code> が<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>と <a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>のどちらの別名なのかで変わりますが、 この別名は正しい型になるように事前に定義されています。</p><p>（<code>Int</code>と違って、<code>Float</code>という、<a href="../base/numbers.html#Core.AbstractFloat"><code>AbstractFloat</code></a>の特定のサイズの型の別名は存在しない点に注意してください。 整数レジスタとは異なり、浮動小数点レジスタのサイズは、IEEE-754規格で規定されています。 一方<code>Int</code>のサイズは、そのマシン上のネイティブポインタのサイズを反映しています。）</p><p>`<a href="## Operations on Types"></a></p><h2><a class="nav-anchor" id="型に対する演算-1" href="#型に対する演算-1">型に対する演算</a></h2><!--
Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions
that are particularly useful for working with or exploring types have already been introduced,
such as the `<:` operator, which indicates whether its left hand operand is a subtype of its right
hand operand.

The [`isa`](@ref) function tests if an object is of a given type and returns true or false:
--><p>Juliaの型はそれ自体がオブジェクトなので、通常の関数を作用させることができます。 特に型の操作や探索に役立つ関数がいくつか既に導入されています。 <code>&lt;:</code>などは、左側の被演算子が右側の被演算子のサブタイプであるかどうかを示す演算子です。</p><p><a href="../base/base.html#Core.isa"><code>isa</code></a> 関数は、オブジェクトが指定された型であるかどうかを検査し、真か偽を返します。</p><pre><code class="language-julia-repl">julia&gt; isa(1, Int)
true

julia&gt; isa(1, AbstractFloat)
false</code></pre><!--
The [`typeof`](@ref) function, already used throughout the manual in examples, returns the type
of its argument. Since, as noted above, types are objects, they also have types, and we can ask
what their types are:
--><p><a href="../base/base.html#Core.typeof"><code>typeof()</code></a> 関数は、既にこのマニュアルを通して例の中で使っていますが、引数の型を返します。 上述のように、型はオブジェクトであり、それ自体の型もあるので、型に対してその型が何であるかを尋ねることができます。</p><pre><code class="language-julia-repl">julia&gt; typeof(Rational{Int})
DataType

julia&gt; typeof(Union{Real,Float64,Rational})
DataType

julia&gt; typeof(Union{Real,String})
Union</code></pre><!--
What if we repeat the process? What is the type of a type of a type? As it happens, types are
all composite values and thus all have a type of `DataType`:
--><p>この操作を繰り返すとどうなるでしょうか？型の型の型は何でしょうか？ 既にみたように、型はすべて複合型の値なので、すべて<code>DataType</code>型になります。</p><pre><code class="language-julia-repl">julia&gt; typeof(DataType)
DataType

julia&gt; typeof(Union)
DataType</code></pre><!--
`DataType` is its own type.

Another operation that applies to some types is [`supertype`](@ref), which reveals a type's
supertype. Only declared types (`DataType`) have unambiguous supertypes:
--><p><code>DataType</code>は自身の型でもあります。</p><p>ある種の型に対する別の演算には、<a href="../base/base.html#Base.supertype"><code>supertype()</code></a>があり、型のスーパータイプを示します。 宣言型（<code>DataType</code>）のみが明確なスーパータイプを持っています：</p><pre><code class="language-julia-repl">julia&gt; supertype(Float64)
AbstractFloat

julia&gt; supertype(Number)
Any

julia&gt; supertype(AbstractString)
Any

julia&gt; supertype(Any)
Any</code></pre><!--
If you apply [`supertype`](@ref) to other type objects (or non-type objects), a [`MethodError`](@ref)
is raised:
--><p><a href="../base/base.html#Base.supertype"><code>supertype()</code></a> を他の型のオブジェクト（または、型ではないオブジェクト）に適用した場合は、<a href="../base/base.html#Core.MethodError"><code>MethodError</code></a> が発生します。</p><pre><code class="language-julia-repl">julia&gt; supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
  supertype(!Matched::DataType) at operators.jl:42
  supertype(!Matched::UnionAll) at operators.jl:47</code></pre><p>`<a href="## [Custom pretty-printing](@id man-custom-pretty-printing)"></a></p><h2><a class="nav-anchor" id="man-custom-pretty-printing-1" href="#man-custom-pretty-printing-1">独自の整形表示</a></h2><!--
Often, one wants to customize how instances of a type are displayed.  This is accomplished by
overloading the [`show`](@ref) function.  For example, suppose we define a type to represent
complex numbers in polar form:
--><p>型のインスタンスがどのように表示されるかを独自に指定したい場合がよくあります。 これは、<a href="../base/io-network.html#Base.show-Tuple{Any}"><code>show()</code></a> 関数のオーバーロードによって可能です。 たとえば、極座標形式で複素数を表す型を定義するとします。</p><pre><code class="language-julia-repl">julia&gt; struct Polar{T&lt;:Real} &lt;: Number
           r::T
           Θ::T
       end

julia&gt; Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar</code></pre><!--
Here, we've added a custom constructor function so that it can take arguments of different
[`Real`](@ref) types and promote them to a common type (see [Constructors](@ref man-constructors)
and [Conversion and Promotion](@ref conversion-and-promotion)).
(Of course, we would have to define lots of other methods, too, to make it act like a
[`Number`](@ref), e.g. `+`, `*`, `one`, `zero`, promotion rules and so on.) By default,
instances of this type display rather simply, with information about the type name and
the field values, as e.g. `Polar{Float64}(3.0,4.0)`.

If we want it to display instead as `3.0 * exp(4.0im)`, we would define the following method to
print the object to a given output object `io` (representing a file, terminal, buffer, etcetera;
see [Networking and Streams](@ref)):
--><p>この例では独自のコンストラクタ関数を追加して、異なる<a href="../base/numbers.html#Core.Real"><code>Real</code></a>型の引数をとると、それらを共通の型に昇格できるようにしました  （ <a href="constructors.html#man-constructors-1">コンストラクタ</a>と<a href="conversion-and-promotion.html#conversion-and-promotion-1">変換と昇格</a>を参照)。 （もちろん、<a href="../base/numbers.html#Core.Number"><code>Number</code></a>型と同じように動作させるためには、他にも多くのメソッドを定義する必要があるでしょう （例えば、<code>+</code>、 <code>*</code>、 <code>one</code>、 <code>zero</code>、昇格のルールなど）。 デフォルトでは、この型のインスタンスの表示はかなり単純で、型名とフィールド値を知らせるだけなので、<code>Polar{Float64}(3.0,4.0)</code>のようになります。</p><p>これに代えて<code>3.0 * exp(4.0im)</code>のように表示したい場合は、オブジェクトを出力オブジェクト<code>io</code>（ファイル、端末、バッファなどを表します。<a href="manual/@ref">ネットワークとストリーム</a> 参照）に出力する次のメソッドを定義します。</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, z::Polar) = print(io, z.r, &quot; * exp(&quot;, z.Θ, &quot;im)&quot;)</code></pre><!--
More fine-grained control over display of `Polar` objects is possible. In particular, sometimes
one wants both a verbose multi-line printing format, used for displaying a single object in the
REPL and other interactive environments, and also a more compact single-line format used for
[`print`](@ref) or for displaying the object as part of another object (e.g. in an array). Although
by default the `show(io, z)` function is called in both cases, you can define a *different* multi-line
format for displaying an object by overloading a three-argument form of `show` that takes the
`text/plain` MIME type as its second argument (see [Multimedia I/O](@ref)), for example:
--><p><code>Polar</code>オブジェクトの表示をさらに細かく制御することが可能です。 特に、冗長な複数行印刷形式は、REPLなどの対話環境で単一のオブジェクトを表示する場合に、簡単な単一行形式は、オブジェクトを別の（配列などの）オブジェクトの一部として表示する場合にと、両方を行いたい場合があります。 デフォルトでは、<code>show(io, z)</code>関数がどちらの場合にも呼び出されますが、ユーザーが定義した <strong>別の</strong> 複数行の形式を表示することもできます。 そのためには、３引数の<code>show</code>関数で、２番目の引数に、<code>text/plain</code>MIMEタイプ（<a href="../base/io-network.html#Multimedia-I/O-1">Multimedia I/O</a>参照）をとるものをオーバーロードします。例えば、</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, ::MIME&quot;text/plain&quot;, z::Polar{T}) where{T} =
           print(io, &quot;Polar{$T} complex number:\n   &quot;, z)</code></pre><!--
(Note that `print(..., z)` here will call the 2-argument `show(io, z)` method.) This results in:
--><p>（ここでは、<code>print(..., z)</code>は、２引数の<code>show(io, z)</code>メソッドを呼び出すことに注意してください）。この結果は以下のようになります。</p><pre><code class="language-julia-repl">julia&gt; Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)</code></pre><!--
where the single-line `show(io, z)` form is still used for an array of `Polar` values.   Technically,
the REPL calls `display(z)` to display the result of executing a line, which defaults to `show(stdout, MIME("text/plain"), z)`,
which in turn defaults to `show(stdout, z)`, but you should *not* define new [`display`](@ref)
methods unless you are defining a new multimedia display handler (see [Multimedia I/O](@ref)).

Moreover, you can also define `show` methods for other MIME types in order to enable richer display
(HTML, images, etcetera) of objects in environments that support this (e.g. IJulia).   For example,
we can define formatted HTML display of `Polar` objects, with superscripts and italics, via:
--><p>単一行の<code>show(io, z)</code>形式は、依然として、<code>Polar</code>の値の配列に使用されています。 技術的には、REPLが、<code>display(z)</code>を呼び出して、実行結果の一行を表示します。 冗長な複数行印刷形式は、<code>show(STDOUT, MIME(&quot;text/plain&quot;), z)</code>が 、簡単な単一行形式は、<code>show(STDOUT, z)</code>がそれぞれデフォルトです。 しかし、新しいマルチメディアディスプレイハンドラを定義する場合を除いて（<a href="../base/io-network.html#Multimedia-I/O-1">Multimedia I/O</a>参照）、新たに<a href="../base/io-network.html#Base.Multimedia.display"><code>display()</code></a>メソッドを定義 <strong>すべきではありません</strong> 。</p><p>さらに、<code>show</code>メソッドを他のMIMEタイプ向けに定義して、対応している環境（例えばIJulia）では、オブジェクトをよりリッチな表示（HTML、画像など）にすることもできます。 たとえば、<code>Polar</code>オブジェクトに対して書式付きのHTML表示を定義し、上付き文字と斜体を使うには、次のようにします。</p><pre><code class="language-julia-repl">julia&gt; Base.show(io::IO, ::MIME&quot;text/html&quot;, z::Polar{T}) where {T} =
           println(io, &quot;&lt;code&gt;Polar{$T}&lt;/code&gt; complex number: &quot;,
                   z.r, &quot; &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;&quot;, z.Θ, &quot; &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;&quot;)</code></pre><!--
A `Polar` object will then display automatically using HTML in an environment that supports HTML
display, but you can call `show` manually to get HTML output if you want:
--><p><code>Polar</code>オブジェクトは、対応している環境ではHTMLを使用して自動的に表示されますが、必要なら手動で<code>show</code>を呼び出して、HTML出力することもできます。</p><pre><code class="language-julia-repl">julia&gt; show(stdout, &quot;text/html&quot;, Polar(3.0,4.0))
&lt;code&gt;Polar{Float64}&lt;/code&gt; complex number: 3.0 &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;4.0 &lt;i&gt;i&lt;/i&gt;&lt;/sup&gt;</code></pre><p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p><!--
As a rule of thumb, the single-line `show` method should print a valid Julia expression for creating
the shown object.  When this `show` method contains infix operators, such as the multiplication
operator (`*`) in our single-line `show` method for `Polar` above, it may not parse correctly when
printed as part of another object.  To see this, consider the expression object (see [Program
representation](@ref)) which takes the square of a specific instance of our `Polar` type:
--><p>経験から言うと、単一行の<code>show</code>メソッドは、表示されたオブジェクトを生成する、Juliaとして有効な式を、表示すべきです。 この<code>show</code>メソッドが、中置演算子を含む時、たとえば、乗法の演算子(<code>*</code>)が上述の<code>Polar</code>の単一行の<code>show</code>メソッドに表れる時は、 別のオブジェクトの一部として印刷される場合は、正しく解析されないかもしれません。 この事例として、式オブジェクト(<a href="manual/@ref">プログラムの表現</a>を参照)で<code>polar</code>型の具体的なインスタンスの二乗を考えます。</p><pre><code class="language-julia-repl">julia&gt; a = Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia&gt; print(:($a^2))
3.0 * exp(4.0im) ^ 2</code></pre><!--
Because the operator `^` has higher precedence than `*` (see [Operator Precedence and Associativity](@ref)), this
output does not faithfully represent the expression `a ^ 2` which should be equal to `(3.0 *
exp(4.0im)) ^ 2`.  To solve this issue, we must make a custom method for `Base.show_unquoted(io::IO,
z::Polar, indent::Int, precedence::Int)`, which is called internally by the expression object when
printing:
--><p><code>^</code>は<code>*</code>より優先順位が高いため、([演算子の優先順位と結合則(@ref)参照])、この式は<code>a^2</code>を忠実に表現していません。 <code>(3.0 * 1xp(4.0im)) ^ 2</code>になるはずです。 この問題を解決するために、独自のメソッド<code>Base.show_unquoted(io::IO,z::Polar, indent::Int, precedence::Int)</code>を作ります。 これは表示の際に、内部的に式オブジェクトから呼びされます。</p><pre><code class="language-julia-repl">julia&gt; function Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)
           if Base.operator_precedence(:*) &lt;= precedence
               print(io, &quot;(&quot;)
               show(io, z)
               print(io, &quot;)&quot;)
           else
               show(io, z)
           end
       end

julia&gt; :($a^2)
:((3.0 * exp(4.0im)) ^ 2)</code></pre><!--
The method defined above adds parentheses around the call to `show` when the precedence of the
calling operator is higher than or equal to the precedence of multiplication.  This check allows
expressions which parse correctly without the parentheses (such as `:($a + 2)` and `:($a == 2)`) to
omit them when printing:
--><p>上で定義されたメソッドは、呼び出す演算子の優先順位が乗法以上の時に、括弧を付け足します。 この検査によって、括弧なしでも、正しく解析される時は省略して表示できます。</p><pre><code class="language-julia-repl">julia&gt; :($a + 2)
:(3.0 * exp(4.0im) + 2)

julia&gt; :($a == 2)
:(3.0 * exp(4.0im) == 2)</code></pre><!--
In some cases, it is useful to adjust the behavior of `show` methods depending
on the context. This can be achieved via the [`IOContext`](@ref) type, which allows
passing contextual properties together with a wrapped IO stream.
For example, we can build a shorter representation in our `show` method
when the `:compact` property is set to `true`, falling back to the long
representation if the property is `false` or absent:
--><p>場合によっては、文脈によって<code>show</code>メソッドの挙動を調整できると有益なことがあります。 これは、<a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a>型によって実現可能で、ラップしたIOストリームと一緒に文脈の特性の受け渡しができます。 例えば、<code>:compact</code>プロパティを<code>true</code>にすると、短い表現になり、<code>false</code>や指定なしだと、かわりに長い表現になるというように<code>show</code>メソッドを定義することができます。</p><pre><code class="language-julia-repl">julia&gt; function Base.show(io::IO, z::Polar)
           if get(io, :compact, false)
               print(io, z.r, &quot;ℯ&quot;, z.Θ, &quot;im&quot;)
           else
               print(io, z.r, &quot; * exp(&quot;, z.Θ, &quot;im)&quot;)
           end
       end</code></pre><!--
This new compact representation will be used when the passed IO stream is an `IOContext`
object with the `:compact` property set. In particular, this is the case when printing
arrays with multiple columns (where horizontal space is limited):
--><p>この新しい簡潔な表現は、<code>:compact</code>プロパティを持つ<code>IOContext</code>をIOストリームとして渡した時に利用可能です。 特に、配列を何段かで表示し、（水平方向の幅が制限されている）時に役立ちます。</p><pre><code class="language-julia-repl">julia&gt; show(IOContext(stdout, :compact=&gt;true), Polar(3, 4.0))
3.0ℯ4.0im

julia&gt; [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Array{Polar{Float64},2}:
 3.0ℯ4.0im  4.0ℯ5.3im</code></pre><!--
See the [`IOContext`](@ref) documentation for a list of common properties which can be used
to adjust printing.
--><p><a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a>の文書では、表示の調整に利用できる共通のプロパティのリストを参照できます。</p><p>`<a href="## &quot;Value types&quot;"></a></p><h2><a class="nav-anchor" id="&quot;値型&quot;-1" href="#&quot;値型&quot;-1">&quot;値型&quot;</a></h2><!--
In Julia, you can't dispatch on a *value* such as `true` or `false`. However, you can dispatch
on parametric types, and Julia allows you to include "plain bits" values (Types, Symbols, Integers,
floating-point numbers, tuples, etc.) as type parameters.  A common example is the dimensionality
parameter in `Array{T,N}`, where `T` is a type (e.g., [`Float64`](@ref)) but `N` is just an `Int`.

You can create your own custom types that take values as parameters, and use them to control dispatch
of custom types. By way of illustration of this idea, let's introduce a parametric type, `Val{x}`,
and a constructor `Val(x) = Val{x}()`, which serves as a customary way to exploit this technique
for cases where you don't need a more elaborate hierarchy.

[`Val`](@ref) is defined as:
--><p>Juliaでは関数のディスパッチに、<code>true</code> や <code>false</code>のような <strong>値</strong> を利用できません。 しかし、パラメータ型によるディスパッチは可能で、その型パラメータとして「普通の」値（型、シンボル、整数、浮動小数点数、タプルなど）を使うことができます。 よくある例としては、<code>Array{T,N}</code>で使われる次元のパラメータがあり、この場合<code>T</code>は型（ <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>など）ですが、<code>N</code>はただの<code>Int</code>型の値です。</p><p>値をパラメータとする独自の型を作成して、その型によってディスパッチを制御することができます。 この考え方を説明するために、パラメータ型の<code>Val{T}</code>を導入しましょう。 手の込んだ階層を必要としない時は、この手法にはこの型を慣用的に使います。</p><p><code>Val{T}</code>は次のように定義します。</p><pre><code class="language-julia-repl">julia&gt; struct Val{x}
       end

julia&gt; Val(x) = Val{x}()
Val</code></pre><!--
There is no more to the implementation of `Val` than this.  Some functions in Julia's standard
library accept `Val` instances as arguments, and you can also use it to write your own functions.
 For example:
--><p><code>Val</code>の実装は、これ以上はありません。 Juliaの標準ライブラリの関数には<code>Val</code>型のインスタンスを引数にとるものもあり、また独自の関数を書く時にも、<code>Val</code>型は利用できます。例えば、</p><pre><code class="language-julia-repl">julia&gt; firstlast(::Val{true}) = &quot;First&quot;
firstlast (generic function with 1 method)

julia&gt; firstlast(::Val{false}) = &quot;Last&quot;
firstlast (generic function with 2 methods)

julia&gt; firstlast(Val(true))
&quot;First&quot;

julia&gt; firstlast(Val(false))
&quot;Last&quot;</code></pre><!--
For consistency across Julia, the call site should always pass a `Val`*instance* rather than using
a *type*, i.e., use `foo(Val(:bar))` rather than `foo(Val{:bar})`.

It's worth noting that it's extremely easy to mis-use parametric "value" types, including `Val`;
in unfavorable cases, you can easily end up making the performance of your code much *worse*.
 In particular, you would never want to write actual code as illustrated above.  For more information
about the proper (and improper) uses of `Val`, please read the more extensive discussion in [the performance tips](@ref man-performance-tips).
--><p>Juliaでは一貫性を保つために、呼び出し側は、常に<code>Val</code>の <strong>型</strong> を使うのではなく、<code>Val</code>の <strong>インスタンス</strong> を渡す必要があります。 つまり、<code>foo(Val{:bar})</code>ではなく<code>foo(Val(:bar))</code>です。</p><p><code>Val</code>を含めて、パラメトリックな「値」型は非常に誤用しやすい点に注意してください。 ひどい時には、コードのパフォーマンスを簡単に大幅に <strong>悪化</strong> させることもありえます。 特に、上述のようなコードを実用のコードとして書きたいとは決して思わないでしょう。 適切な（そして不適切な）<code>Val</code>の使い方の詳細については、<a href="performance-tips.html#man-performance-tips-1">the performance tips</a>の広範に渡る議論を読んでください。</p><!--
[^1]: "Small" is defined by the `MAX_UNION_SPLITTING` constant, which is currently set to 4.
--><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>&quot;Small&quot; は定数 <code>MAX_UNION_SPLITTING</code> で定義されており、現在は4に設定されています。</p></div><footer><hr/><a class="previous" href="variables-and-scoping.html"><span class="direction">Previous</span><span class="title">変数のスコープ</span></a><a class="next" href="methods.html"><span class="direction">Next</span><span class="title">メソッド</span></a></footer></article></body></html>
