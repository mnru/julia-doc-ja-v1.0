<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>多次元配列 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125166476-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting-started.html">始めよう</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術演算と初等関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御フロー</a></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">コンストラクタ</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li><a class="toctext" href="interfaces.html">インターフェイス</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li class="current"><a class="toctext" href="arrays.html">多次元配列</a><ul class="internal"><li><a class="toctext" href="#基本的な関数-1">基本的な関数</a></li><li><a class="toctext" href="#生成と初期化-1">生成と初期化</a></li><li><a class="toctext" href="#連結-1">連結</a></li><li><a class="toctext" href="#型つき配列の初期化-1">型つき配列の初期化</a></li><li><a class="toctext" href="#内包表記-1">内包表記</a></li><li><a class="toctext" href="#ジェネレーター式-1">ジェネレーター式</a></li><li><a class="toctext" href="#man-array-indexing-1">インデックスづけ</a></li><li><a class="toctext" href="#代入-1">代入</a></li><li><a class="toctext" href="#man-supported-index-types-1">対応しているインデックスの型</a></li><li><a class="toctext" href="#イテレーション-1">イテレーション</a></li><li><a class="toctext" href="#配列のトレイト-1">配列のトレイト</a></li><li><a class="toctext" href="#配列とベクトル化した演算子・関数-1">配列とベクトル化した演算子・関数</a></li><li><a class="toctext" href="#ブロードキャスト-1">ブロードキャスト</a></li><li><a class="toctext" href="#実装-1">実装</a></li></ul></li><li><a class="toctext" href="missing.html">Missing Values</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">並列コンピューティング</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="code-loading.html">Code Loading</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base.html">Essentials</a></li><li><a class="toctext" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math.html">Mathematics</a></li><li><a class="toctext" href="../base/numbers.html">Numbers</a></li><li><a class="toctext" href="../base/strings.html">Strings</a></li><li><a class="toctext" href="../base/arrays.html">Arrays</a></li><li><a class="toctext" href="../base/parallel.html">Tasks</a></li><li><a class="toctext" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="toctext" href="../base/constants.html">Constants</a></li><li><a class="toctext" href="../base/file.html">Filesystem</a></li><li><a class="toctext" href="../base/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../base/c.html">C Interface</a></li><li><a class="toctext" href="../base/libc.html">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64.html">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates.html">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging.html">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf.html">Printf</a></li><li><a class="toctext" href="../stdlib/Profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="toctext" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="toctext" href="../stdlib/SHA.html">SHA</a></li><li><a class="toctext" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="toctext" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/Unicode.html">Unicode</a></li><li><a class="toctext" href="../stdlib/UUIDs.html">UUIDs</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li><li><a class="toctext" href="../devdocs/inference.html">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="arrays.html">多次元配列</a></li></ul><a class="edit-page" href="https://github.com/mnru/julia-doc-ja-v1.0-source/blob/master/src/manual/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>多次元配列</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-multi-dim-arrays-1" href="#man-multi-dim-arrays-1">多次元配列</a></h1><p>`<a href="# [Multi-dimensional Arrays](@id man-multi-dim-arrays)"></a></p><!--
Julia, like most technical computing languages, provides a first-class array implementation. Most
technical computing languages pay a lot of attention to their array implementation at the expense
of other containers. Julia does not treat arrays in any special way. The array library is implemented
almost completely in Julia itself, and derives its performance from the compiler, just like any
other code written in Julia. As such, it's also possible to define custom array types by inheriting
from [`AbstractArray`](@ref). See the [manual section on the AbstractArray interface](@ref man-interface-array) for more details
on implementing a custom array type.

An array is a collection of objects stored in a multi-dimensional grid. In the most general case,
an array may contain objects of type `Any`. For most computational purposes, arrays should contain
objects of a more specific type, such as [`Float64`](@ref) or [`Int32`](@ref).
--><p>大抵の技術計算用の言語と同様に、Juliaでは、第一級の配列の実装が利用可能です。 ほとんどの技術計算用の言語は、他のコンテナをないがしろにして配列の実装に注力していますが、 Juliaでは配列を特別扱いしません。 配列のライブラリは、ほぼJuliaだけで完全に実装されており、他のJuliaで書かれたコードと同様に、コンパイラがパフォーマンスをだせるようにしています。 また、<code>AbstractArray</code>を継承して、独自の配列の型を定義することも可能です。 配列に対する独自の型の実装の詳細については、[マニュアルのAbstractArrayインタフェースに関する部分]（@ ref man-interface-array）を参照してください。</p><p>配列は、多次元グリッドに格納されたオブジェクトのコレクションです。 大抵の一般的な場合には、配列には<code>Any</code>型のオブジェクトが含まれていてもかまいません。 しかし殆どの計算用途には、配列は、<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> や<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>のように型を特定すべきです。</p><!--
In general, unlike many other technical computing languages, Julia does not expect programs to
be written in a vectorized style for performance. Julia's compiler uses type inference and generates
optimized code for scalar array indexing, allowing programs to be written in a style that is convenient
and readable, without sacrificing performance, and using less memory at times.

In Julia, all arguments to functions are [passed by
sharing](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)
(i.e. by pointers). Some technical computing languages pass arrays by value, and
while this prevents accidental modification by callees of a value in the caller,
it makes avoiding unwanted copying of arrays difficult. By convention, a
function name ending with a `!` indicates that it will mutate or destroy the
value of one or more of its arguments (see, for example, [`sort`](@ref) and [`sort!`](@ref).
Callees must make explicit copies to ensure that they don't modify inputs that
they don't intend to change. Many non- mutating functions are implemented by
calling a function of the same name with an added `!` at the end on an explicit
copy of the input, and returning that copy.
--><p>他の多くの技術計算用の言語とは異なり、Juliaでは通常、パフォーマンスをあげたいからといって、プログラムをベクトル化したスタイルで書く必要はありません。 Juliaのコンパイラは型推論を使用し、配列のスカラインデックスによる参照に最適化されたコードを生成するので、便利で読みやすいスタイルで書いても、パフォーマンスを犠牲にすることなく、少ないメモリで使用することができます。</p><p>Juliaでは、すべての関数の引数は参照渡しです。技術計算用の言語のなかには配列を値渡しするものもあり、便利な場合も多いです。 Juliaでは、関数が入力用の配列に加えた変更を、親関数から参照できます。 Juliaの配列ライブラリはすべて、ライブラリ関数が入力を変更しないことを、保証しています。 ユーザーのコードも同様の動作をさせる必要がある場合は、変更してもよい入力のコピーを作成するよう注意してください。</p><p>`<a href="## Basic Functions"></a></p><h2><a class="nav-anchor" id="基本的な関数-1" href="#基本的な関数-1">基本的な関数</a></h2><!--
| Function               | Description                                                                      |
|:---------------------- |:-------------------------------------------------------------------------------- |
| [`eltype(A)`](@ref)    | the type of the elements contained in `A`                                        |
| [`length(A)`](@ref)    | the number of elements in `A`                                                    |
| [`ndims(A)`](@ref)     | the number of dimensions of `A`                                                  |
| [`size(A)`](@ref)      | a tuple containing the dimensions of `A`                                         |
| [`size(A,n)`](@ref)    | the size of `A` along dimension `n`                                              |
| [`axes(A)`](@ref)   | a tuple containing the valid indices of `A`                                      |
| [`axes(A,n)`](@ref) | a range expressing the valid indices along dimension `n`                         |
| [`eachindex(A)`](@ref) | an efficient iterator for visiting each position in `A`                          |
| [`stride(A,k)`](@ref)  | the stride (linear index distance between adjacent elements) along dimension `k` |
| [`strides(A)`](@ref)   | a tuple of the strides in each dimension                                         |
--><table><tr><th>関数</th><th>説明</th></tr><tr><td><a href="../base/collections.html#Base.eltype"><code>eltype(A)</code></a></td><td><code>A</code>に含まれる要素の型。</td></tr><tr><td><a href="../base/strings.html#Base.length-Tuple{AbstractString}"><code>length(A)</code></a></td><td><code>A</code>の要素の数</td></tr><tr><td><a href="../base/arrays.html#Base.ndims"><code>ndims(A)</code></a></td><td><code>A</code>の次元の数</td></tr><tr><td><a href="../base/arrays.html#Base.size"><code>size(A)</code></a></td><td><code>A</code>の次元を保持するタプル</td></tr><tr><td><a href="../base/arrays.html#Base.size"><code>size(A,n)</code></a></td><td>次元<code>n</code>に沿った <code>A</code>のサイズ</td></tr><tr><td><a href="manual/@ref"><code>indices(A)</code></a></td><td><code>A</code>の妥当なインデックスを表すタプル</td></tr><tr><td><a href="manual/@ref"><code>indices(A,n)</code></a></td><td>次元<code>n</code>の <code>A</code>の妥当なインデックスを表す範囲</td></tr><tr><td><a href="../base/arrays.html#Base.eachindex"><code>eachindex(A)</code></a></td><td><code>A</code>の各位置を走査する効率的なイテレータ</td></tr><tr><td><a href="../base/arrays.html#Base.stride"><code>stride(A,k)</code></a></td><td>次元<code>k</code>に沿ったストライド(隣接する要素間の線形インデックスの距離)</td></tr><tr><td><a href="../base/arrays.html#Base.strides"><code>strides(A)</code></a></td><td>各次元のストライドのタプル</td></tr></table><p>`<a href="## Construction and Initialization"></a></p><h2><a class="nav-anchor" id="生成と初期化-1" href="#生成と初期化-1">生成と初期化</a></h2><!--
Many functions for constructing and initializing arrays are provided. In the following list of
such functions, calls with a `dims...` argument can either take a single tuple of dimension sizes
or a series of dimension sizes passed as a variable number of arguments. Most of these functions
also accept a first input `T`, which is the element type of the array. If the type `T` is
omitted it will default to [`Float64`](@ref).
--><p>配列の生成と初期化用に多くの関数が用意されています。 下記の関数のリストにある、引数に<code>dims...</code>を使う関数呼び出しは、次元のサイズを表す1個のタプル、または可変引数で渡される次元サイズの列かのいずれかを取ることができます。 これらの関数のほとんどは、配列の要素型である<code>T</code>を入力の最初に受けとります。 型<code>T</code>が省略された場合、デフォルト の<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>になります。</p><!--
| Function                           | Description                                                                                                                                                                                                                                  |
|:---------------------------------- |:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`Array{T}(undef, dims...)`](@ref)             | an uninitialized dense [`Array`](@ref)                                                                                                                                                                                                              |
| [`zeros(T, dims...)`](@ref)                    | an `Array` of all zeros                                                                                                                                                                                                                      |
| [`ones(T, dims...)`](@ref)                     | an `Array` of all ones                                                                                                                                                                                                                       |
| [`trues(dims...)`](@ref)                       | a [`BitArray`](@ref) with all values `true`                                                                                                                                                                                                  |
| [`falses(dims...)`](@ref)                      | a `BitArray` with all values `false`                                                                                                                                                                                                         |
| [`reshape(A, dims...)`](@ref)                  | an array containing the same data as `A`, but with different dimensions                                                                                                                                                                      |
| [`copy(A)`](@ref)                              | copy `A`                                                                                                                                                                                                                                     |
| [`deepcopy(A)`](@ref)                          | copy `A`, recursively copying its elements                                                                                                                                                                                                   |
| [`similar(A, T, dims...)`](@ref)               | an uninitialized array of the same type as `A` (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of `A` if omitted. |
| [`reinterpret(T, A)`](@ref)                    | an array with the same binary data as `A`, but with element type `T`                                                                                                                                                                         |
| [`rand(T, dims...)`](@ref)                     | an `Array` with random, iid [^1] and uniformly distributed values in the half-open interval ``[0, 1)``                                                                                                                                       |
| [`randn(T, dims...)`](@ref)                    | an `Array` with random, iid and standard normally distributed values                                                                                                                                                                         |
| [`Matrix{T}(I, m, n)`](@ref)                   | `m`-by-`n` identity matrix                                                                                                                                                                                                                   |
| [`range(start, stop=stop, length=n)`](@ref)    | range of `n` linearly spaced elements from `start` to `stop`                                                                                                                                                                                 |
| [`fill!(A, x)`](@ref)                          | fill the array `A` with the value `x`                                                                                                                                                                                                        |
| [`fill(x, dims...)`](@ref)                     | an `Array` filled with the value `x`                                                                                                                                                                                                         |

--><table><tr><th>関数</th><th>説明</th></tr><tr><td><a href="../base/arrays.html#Core.Array"><code>Array{T}(dims...)</code></a></td><td>初期化されていない密な <a href="../base/arrays.html#Core.Array"><code>Array</code></a></td></tr><tr><td><a href="../base/arrays.html#Base.zeros"><code>zeros(T, dims...)</code></a></td><td>すべてが0の <code>配列</code></td></tr><tr><td><a href="../base/arrays.html#Base.zeros"><code>zeros(A)</code></a></td><td>要素の型やシェイプが<code>A</code>である、すべてが同じ型の0である配列</td></tr><tr><td><a href="../base/arrays.html#Base.ones"><code>ones(T, dims...)</code></a></td><td>すべてが1の <code>配列</code></td></tr><tr><td><a href="../base/arrays.html#Base.ones"><code>ones(A)</code></a></td><td>要素の型やシェイプが<code>A</code>である、すべてが同じ型の1である配列</td></tr><tr><td><a href="../base/arrays.html#Base.trues"><code>trues(dims...)</code></a></td><td>すべての値が<code>true</code>である<a href="../base/arrays.html#Base.BitArray"><code>BitArray</code></a></td></tr><tr><td><a href="../base/arrays.html#Base.trues"><code>trues(A)</code></a></td><td>すべての値が<code>true</code>でシェイプが<code>A</code>と同じ<code>BitArray</code></td></tr><tr><td><a href="../base/arrays.html#Base.falses"><code>falses(dims...)</code></a></td><td>すべての値が<code>false</code>である<code>BitArray</code></td></tr><tr><td><a href="../base/arrays.html#Base.falses"><code>falses(A)</code></a></td><td>すべての値が<code>false</code>でシェイプが<code>A</code>と同じ<code>BitArray</code></td></tr><tr><td><a href="../base/arrays.html#Base.reshape"><code>reshape(A, dims...)</code></a></td><td><code>A</code>と同じデータだが次元の違う配列</td></tr><tr><td><a href="../base/base.html#Base.copy"><code>copy(A)</code></a></td><td><code>A</code>をコピーする</td></tr><tr><td><a href="../base/base.html#Base.deepcopy"><code>deepcopy(A)</code></a></td><td><code>A</code>をコピーする（再帰的にその要素もコピーする）</td></tr><tr><td><a href="../base/arrays.html#Base.similar"><code>similar(A, T, dims...)</code></a></td><td><code>A</code>(密・疎など)と型が同じだが初期化されていない配列で、要素の型や次元が指定されたもの。2番目と3番目の引数は共に省略可能で、省略した時のデフォルト値は<code>A</code>の要素の型と次元になる。</td></tr><tr><td><a href="../base/arrays.html#Base.reinterpret"><code>reinterpret(T, A)</code></a></td><td><code>A</code>とバイナリデータが同じだが、要素の型が<code>T</code>である配列</td></tr><tr><td><a href="../stdlib/Random.html#Base.rand"><code>rand(T, dims...)</code></a></td><td>半開区間<span>$[0, 1)$</span>で独立同分布、一様分布の乱数の<code>配列</code></td></tr><tr><td><a href="../stdlib/Random.html#Base.randn"><code>randn(T, dims...)</code></a></td><td>独立同分布、標準正規分布の乱数の<code>配列</code></td></tr><tr><td><a href="manual/@ref"><code>eye(T, n)</code></a></td><td><code>n</code>×<code>n</code> の単位行列</td></tr><tr><td><a href="manual/@ref"><code>eye(T, m, n)</code></a></td><td><code>m</code>×<code>n</code> の単位行列</td></tr><tr><td><a href="manual/@ref"><code>linspace(start, stop, n)</code></a></td><td><code>start</code>から<code>stop</code>まで<code>n</code>個の要素が等間隔にある範囲</td></tr><tr><td><a href="../base/arrays.html#Base.fill!"><code>fill!(A, x)</code></a></td><td>配列<code>A</code>を値<code>x</code>で埋める</td></tr><tr><td><a href="../base/arrays.html#Base.fill"><code>fill(x, dims...)</code></a></td><td>値が<code>x</code>で埋まった<code>配列</code></td></tr></table><!--
[^1]: *iid*, independently and identically distributed.
--><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p><em>iid</em>, 独立同分布</p></div><!--
The syntax `[A, B, C, ...]` constructs a 1-d array (vector) of its arguments. If all
arguments have a common [promotion type](@ref conversion-and-promotion) then they get
converted to that type using [`convert`](@ref).

To see the various ways we can pass dimensions to these constructors, consider the following examples:
--><p>構文<code>[A, B, C, ...]</code>では、引数からなる1次元配列（ベクトル）を生成します。 すべての引数が共通の<a href="conversion-and-promotion.html#conversion-and-promotion-1">昇格した型</a>を持つ場合、引数は<code>convert()</code>を使用してその型に変換されます。</p><pre><code class="language-julia-repl">julia&gt; zeros(Int8, 2, 2)
2×2 Array{Int8,2}:
 0  0
 0  0

julia&gt; zeros(Int8, (2, 2))
2×2 Array{Int8,2}:
 0  0
 0  0

julia&gt; zeros((2, 2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre><p>Here, <code>(2, 2)</code> is a <a href="../base/base.html#Core.Tuple"><code>Tuple</code></a>.</p><p>`<a href="## Concatenation"></a></p><h2><a class="nav-anchor" id="連結-1" href="#連結-1">連結</a></h2><!--
Arrays can be constructed and also concatenated using the following functions:
--><p>配列は、以下の関数を使用して生成・連結することもできます。</p><!--
| Function                    | Description                                     |
|:--------------------------- |:----------------------------------------------- |
| [`cat(A...; dims=k)`](@ref) | concatenate input arrays along dimension(s) `k` |
| [`vcat(A...)`](@ref)        | shorthand for `cat(A...; dims=1)`               |
| [`hcat(A...)`](@ref)        | shorthand for `cat(A...; dims=2)`               |
--><table><tr><th>関数</th><th>説明</th></tr><tr><td><a href="../base/arrays.html#Base.cat"><code>cat(k, A...)</code></a></td><td>入力した n次元の配列を次元kに沿って連結する</td></tr><tr><td><a href="../base/arrays.html#Base.vcat"><code>vcat(A...)</code></a></td><td><code>cat(1, A...)</code>の簡略表記</td></tr><tr><td><a href="../base/arrays.html#Base.hcat"><code>hcat(A...)</code></a></td><td><code>cat(2, A...)</code>の簡略表記</td></tr></table><!--
Scalar values passed to these functions are treated as 1-element arrays. For example,
--><p>これらの関数に渡されるスカラー値は、1要素の配列として扱われます。</p><pre><code class="language-julia-repl">julia&gt; vcat([1, 2], 3)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; hcat([1 2], 3)
1×3 Array{Int64,2}:
 1  2  3</code></pre><!--
The concatenation functions are used so often that they have special syntax:
--><p>連結関数はよく使用されるので、特殊構文も存在します。</p><!--
| Expression        | Calls             |
|:----------------- |:----------------- |
| `[A; B; C; ...]`  | [`vcat`](@ref)  |
| `[A B C ...]`     | [`hcat`](@ref)  |
| `[A B; C D; ...]` | [`hvcat`](@ref) |
--><table><tr><th>式</th><th>関数呼び出し</th></tr><tr><td><code>[A; B; C; ...]</code></td><td><a href="../base/arrays.html#Base.vcat"><code>vcat()</code></a></td></tr><tr><td><code>[A B C ...]</code></td><td><a href="../base/arrays.html#Base.hcat"><code>hcat()</code></a></td></tr><tr><td><code>[A B; C D; ...]</code></td><td><a href="../base/arrays.html#Base.hvcat"><code>hvcat()</code></a></td></tr></table><!--
[`hvcat`](@ref) concatenates in both dimension 1 (with semicolons) and dimension 2 (with spaces).
Consider these examples of this syntax:
--><p><a href="../base/arrays.html#Base.hvcat"><code>hvcat()</code></a> は次元１（セミコロンを使う）と次元２（空白を使う）の両方向に連結します。</p><pre><code class="language-julia-repl">julia&gt; [[1; 2]; [3, 4]]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; [[1 2]; [3 4]]
2×2 Array{Int64,2}:
 1  2
 3  4</code></pre><p>`<a href="## Typed array initializers"></a></p><h2><a class="nav-anchor" id="型つき配列の初期化-1" href="#型つき配列の初期化-1">型つき配列の初期化</a></h2><!--
An array with a specific element type can be constructed using the syntax `T[A, B, C, ...]`. This
will construct a 1-d array with element type `T`, initialized to contain elements `A`, `B`, `C`,
etc. For example, `Any[x, y, z]` constructs a heterogeneous array that can contain any values.

Concatenation syntax can similarly be prefixed with a type to specify the element type of the
result.
--><p><code>T[A, B, C, ...]</code>という構文を使うと、要素の型を指定して配列を生成できます。 この時、要素の型が<code>T</code>の1次元配列が生成され、要素が<code>A</code>, <code>B</code>, <code>C</code>などと初期化されます。 例えば<code>Any[x, y, z]</code>とすると、任意の値を含むことができる型の不均質な配列が生成されます。</p><p>連結構文にも同様に型の接頭辞を付けて、演算結果に対して要素の型を指定することができます。</p><pre><code class="language-julia-repl">julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4</code></pre><p>`<a href="## Comprehensions"></a></p><h2><a class="nav-anchor" id="内包表記-1" href="#内包表記-1">内包表記</a></h2><p>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</p><pre><code class="language-none">A = [ F(x,y,...) for x=rx, y=ry, ... ]</code></pre><p>The meaning of this form is that <code>F(x,y,...)</code> is evaluated with the variables <code>x</code>, <code>y</code>, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like <code>1:n</code> or <code>2:(n-1)</code>, or explicit arrays of values like <code>[1.2, 3.4, 5.7]</code>. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges <code>rx</code>, <code>ry</code>, etc. and each <code>F(x,y,...)</code> evaluation returns a scalar.</p><p>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</p><pre><code class="language-julia-repl">julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</code></pre><p>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</p><pre><code class="language-julia">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</code></pre><p>`<a href="## Generator Expressions"></a></p><h2><a class="nav-anchor" id="ジェネレーター式-1" href="#ジェネレーター式-1">ジェネレーター式</a></h2><p>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see <a href="manual/@ref">Iteration</a>). For example, the following expression sums a series without allocating memory:</p><pre><code class="language-julia-repl">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</code></pre><p>When writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments:</p><pre><code class="language-julia-repl">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</code></pre><p>All comma-separated expressions after <code>for</code> are interpreted as ranges. Adding parentheses lets us add a third argument to <a href="../base/collections.html#Base.map"><code>map</code></a>:</p><pre><code class="language-julia-repl">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</code></pre><p>Generators are implemented via inner functions. As in other cases of inner functions in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function.  For example, <code>sum(p[i] - q[i] for i=1:n)</code> captures the three variables <code>p</code>, <code>q</code> and <code>n</code> from the enclosing scope. Captured variables can present performance challenges described in <a href="performance-tips.html#man-performance-tips-1">performance tips</a>.</p><p>Ranges in generators and comprehensions can depend on previous ranges by writing multiple <code>for</code> keywords:</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>In such cases, the result is always 1-d.</p><p>Generated values can be filtered using the <code>if</code> keyword:</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</code></pre><p>`<a href="## [Indexing](@id man-array-indexing)"></a></p><h2><a class="nav-anchor" id="man-array-indexing-1" href="#man-array-indexing-1">インデックスづけ</a></h2><p>The general syntax for indexing into an n-dimensional array A is:</p><pre><code class="language-none">X = A[I_1, I_2, ..., I_n]</code></pre><p>where each <code>I_k</code> may be a scalar integer, an array of integers, or any other <a href="arrays.html#man-supported-index-types-1">supported index</a>. This includes <a href="../base/arrays.html#Base.Colon"><code>Colon</code></a> (<code>:</code>) to select all indices within the entire dimension, ranges of the form <code>a:c</code> or <code>a:b:c</code> to select contiguous or strided subsections, and arrays of booleans to select elements at their <code>true</code> indices.</p><p>If all the indices are scalars, then the result <code>X</code> is a single element from the array <code>A</code>. Otherwise, <code>X</code> is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</p><p>If all indices are vectors, for example, then the shape of <code>X</code> would be <code>(length(I_1), length(I_2), ..., length(I_n))</code>, with location <code>(i_1, i_2, ..., i_n)</code> of <code>X</code> containing the value <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>.</p><p>Example:</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[1, 2, 1, 1] # all scalar indices
3

julia&gt; A[[1, 2], [1], [1, 2], [1]] # all vector indices
2×1×2×1 Array{Int64,4}:
[:, :, 1, 1] =
 1
 2

[:, :, 2, 1] =
 5
 6

julia&gt; A[[1, 2], [1], [1, 2], 1] # a mix of index types
2×1×2 Array{Int64,3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 5
 6</code></pre><p>Note how the size of the resulting array is different in the last two cases.</p><p>If <code>I_1</code> is changed to a two-dimensional matrix, then <code>X</code> becomes an <code>n+1</code>-dimensional array of shape <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>. The matrix adds a dimension.</p><p>Example:</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:16), (2, 2, 2, 2));

julia&gt; A[[1 2; 1 2]]
2×2 Array{Int64,2}:
 1  2
 1  2

julia&gt; A[[1 2; 1 2], 1, 2, 1]
2×2 Array{Int64,2}:
 5  6
 5  6</code></pre><p>The location <code>(i_1, i_2, i_3, ..., i_{n+1})</code> contains the value at <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>. All dimensions indexed with scalars are dropped. For example, the result of <code>A[2, I, 3]</code> is an array with size <code>size(I)</code>. Its <code>i</code>th element is populated by <code>A[2, I[i], 3]</code>.</p><p>As a special part of this syntax, the <code>end</code> keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the <code>end</code> keyword is equivalent to a call to <a href="../base/collections.html#Base.getindex"><code>getindex</code></a>:</p><pre><code class="language-none">X = getindex(A, I_1, I_2, ..., I_n)</code></pre><p>Example:</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1</code></pre><p>Empty ranges of the form <code>n:n-1</code> are sometimes used to indicate the inter-index location between <code>n-1</code> and <code>n</code>. For example, the <a href="../base/sort.html#Base.Sort.searchsorted"><code>searchsorted</code></a> function uses this convention to indicate the insertion point of a value not found in a sorted array:</p><pre><code class="language-julia-repl">julia&gt; a = [1,2,5,6,7];

julia&gt; searchsorted(a, 3)
3:2</code></pre><p>`<a href="## Assignment"></a></p><h2><a class="nav-anchor" id="代入-1" href="#代入-1">代入</a></h2><p>The general syntax for assigning values in an n-dimensional array A is:</p><pre><code class="language-none">A[I_1, I_2, ..., I_n] = X</code></pre><p>where each <code>I_k</code> may be a scalar integer, an array of integers, or any other <a href="arrays.html#man-supported-index-types-1">supported index</a>. This includes <a href="../base/arrays.html#Base.Colon"><code>Colon</code></a> (<code>:</code>) to select all indices within the entire dimension, ranges of the form <code>a:c</code> or <code>a:b:c</code> to select contiguous or strided subsections, and arrays of booleans to select elements at their <code>true</code> indices.</p><p>If <code>X</code> is an array, it must have the same number of elements as the product of the lengths of the indices: <code>prod(length(I_1), length(I_2), ..., length(I_n))</code>. The value in location <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code> of <code>A</code> is overwritten with the value <code>X[i_1, i_2, ..., i_n]</code>. If <code>X</code> is not an array, its value is written to all referenced locations of <code>A</code>.</p><p>Just as in <a href="arrays.html#man-array-indexing-1">Indexing</a>, the <code>end</code> keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the <code>end</code> keyword is equivalent to a call to <a href="../base/collections.html#Base.setindex!"><code>setindex!</code></a>:</p><pre><code class="language-none">setindex!(A, X, I_1, I_2, ..., I_n)</code></pre><p>Example:</p><pre><code class="language-julia-repl">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[3, 3] = -9;

julia&gt; x[1:2, 1:2] = [-1 -4; -2 -5];

julia&gt; x
3×3 Array{Int64,2}:
 -1  -4   7
 -2  -5   8
  3   6  -9</code></pre><p>`<a href="## [Supported index types](@id man-supported-index-types)"></a></p><h2><a class="nav-anchor" id="man-supported-index-types-1" href="#man-supported-index-types-1">対応しているインデックスの型</a></h2><p>In the expression <code>A[I_1, I_2, ..., I_n]</code>, each <code>I_k</code> may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by <a href="../base/arrays.html#Base.to_indices"><code>to_indices</code></a>:</p><ol><li>A scalar index. By default this includes:<ul><li>Non-boolean integers</li><li><a href="../base/arrays.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex{N}</code></a>s, which behave like an <code>N</code>-tuple of integers spanning multiple dimensions (see below for more details)</li></ul></li><li>An array of scalar indices. This includes:<ul><li>Vectors and multidimensional arrays of integers</li><li>Empty arrays like <code>[]</code>, which select no elements</li><li>Ranges like <code>a:c</code> or <code>a:b:c</code>, which select contiguous or strided subsections from <code>a</code> to <code>c</code> (inclusive)</li><li>Any custom array of scalar indices that is a subtype of <code>AbstractArray</code></li><li>Arrays of <code>CartesianIndex{N}</code> (see below for more details)</li></ul></li><li>An object that represents an array of scalar indices and can be converted to such by <a href="../base/arrays.html#Base.to_indices"><code>to_indices</code></a>. By default this includes:<ul><li><a href="../base/arrays.html#Base.Colon"><code>Colon()</code></a> (<code>:</code>), which represents all indices within an entire dimension or across the entire array</li><li>Arrays of booleans, which select elements at their <code>true</code> indices (see below for more details)</li></ul></li></ol><p>Some examples:</p><pre><code class="language-julia-repl">julia&gt; A = reshape(collect(1:2:18), (3, 3))
3×3 Array{Int64,2}:
 1   7  13
 3   9  15
 5  11  17

julia&gt; A[4]
7

julia&gt; A[[2, 5, 8]]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[[1 4; 3 8]]
2×2 Array{Int64,2}:
 1   7
 5  15

julia&gt; A[[]]
0-element Array{Int64,1}

julia&gt; A[1:2:5]
3-element Array{Int64,1}:
 1
 5
 9

julia&gt; A[2, :]
3-element Array{Int64,1}:
  3
  9
 15

julia&gt; A[:, 3]
3-element Array{Int64,1}:
 13
 15
 17</code></pre><p>`<a href="### Cartesian indices"></a></p><h3><a class="nav-anchor" id="直積のインデックス-1" href="#直積のインデックス-1">直積のインデックス</a></h3><p>The special <code>CartesianIndex{N}</code> object represents a scalar index that behaves like an <code>N</code>-tuple of integers spanning multiple dimensions.  For example:</p><pre><code class="language-julia-repl">julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</code></pre><p>Considered alone, this may seem relatively trivial; <code>CartesianIndex</code> simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield <code>CartesianIndex</code>es, however, this can lead directly to very elegant and efficient code. See <a href="manual/@ref">Iteration</a> below, and for some more advanced examples, see <a href="https://julialang.org/blog/2016/02/iteration">this blog post on multidimensional algorithms and iteration</a>.</p><p>Arrays of <code>CartesianIndex{N}</code> are also supported. They represent a collection of scalar indices that each span <code>N</code> dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of <code>A</code> from above:</p><pre><code class="language-julia-repl">julia&gt; page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16</code></pre><p>This can be expressed much more simply with <a href="functions.html#man-vectorized-1">dot broadcasting</a> and by combining it with a normal integer index (instead of extracting the first <code>page</code> from <code>A</code> as a separate step). It can even be combined with a <code>:</code> to extract both diagonals from the two pages at the same time:</p><pre><code class="language-julia-repl">julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>CartesianIndex</code> and arrays of <code>CartesianIndex</code> are not compatible with the <code>end</code> keyword to represent the last index of a dimension. Do not use <code>end</code> in indexing expressions that may contain either <code>CartesianIndex</code> or arrays thereof.</p></div></div><p>`<a href="### Logical indexing"></a></p><h3><a class="nav-anchor" id="論理インデックスづけ-1" href="#論理インデックスづけ-1">論理インデックスづけ</a></h3><p>Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects elements at the indices where its values are <code>true</code>. Indexing by a boolean vector <code>B</code> is effectively the same as indexing by the vector of integers that is returned by <a href="../base/arrays.html#Base.findall-Tuple{Any}"><code>findall(B)</code></a>. Similarly, indexing by a <code>N</code>-dimensional boolean array is effectively the same as indexing by the vector of <code>CartesianIndex{N}</code>s where its values are <code>true</code>. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the only index provided and match the size and dimensionality of the array it indexes into. It is generally more efficient to use boolean arrays as indices directly instead of first calling <a href="../base/arrays.html#Base.findall-Tuple{Any}"><code>findall</code></a>.</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia&gt; x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16</code></pre><p>`<a href="## Iteration"></a></p><h2><a class="nav-anchor" id="イテレーション-1" href="#イテレーション-1">イテレーション</a></h2><p>The recommended ways to iterate over a whole array are</p><pre><code class="language-julia">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end</code></pre><p>The first construct is used when you need the value, but not index, of each element. In the second construct, <code>i</code> will be an <code>Int</code> if <code>A</code> is an array type with fast linear indexing; otherwise, it will be a <code>CartesianIndex</code>:</p><pre><code class="language-julia-repl">julia&gt; A = rand(4,3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex(1, 1)
i = CartesianIndex(2, 1)
i = CartesianIndex(3, 1)
i = CartesianIndex(1, 2)
i = CartesianIndex(2, 2)
i = CartesianIndex(3, 2)</code></pre><p>In contrast with <code>for i = 1:length(A)</code>, iterating with <a href="../base/arrays.html#Base.eachindex"><code>eachindex</code></a> provides an efficient way to iterate over any array type.</p><p>`<a href="## Array traits"></a></p><h2><a class="nav-anchor" id="配列のトレイト-1" href="#配列のトレイト-1">配列のトレイト</a></h2><p>If you write a custom <a href="../base/arrays.html#Core.AbstractArray"><code>AbstractArray</code></a> type, you can specify that it has fast linear indexing using</p><pre><code class="language-julia">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>This setting will cause <code>eachindex</code> iteration over a <code>MyArray</code> to use integers. If you don&#39;t specify this trait, the default value <code>IndexCartesian()</code> is used.</p><p>`<a href="## Array and Vectorized Operators and Functions"></a></p><h2><a class="nav-anchor" id="配列とベクトル化した演算子・関数-1" href="#配列とベクトル化した演算子・関数-1">配列とベクトル化した演算子・関数</a></h2><p>The following operators are supported for arrays:</p><ol><li>Unary arithmetic – <code>-</code>, <code>+</code></li><li>Binary arithmetic – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></li><li>Comparison – <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../base/math.html#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></li></ol><p>Most of the binary arithmetic operators listed above also operate elementwise when one argument is scalar: <code>-</code>, <code>+</code>, and <code>*</code> when either argument is scalar, and <code>/</code> and <code>\</code> when the denominator is scalar. For example, <code>[1, 2] + 3 == [4, 5]</code> and <code>[6, 4] / 2 == [3, 2]</code>.</p><p>Additionally, to enable convenient vectorization of mathematical and other operations, Julia <a href="functions.html#man-vectorized-1">provides the dot syntax</a> <code>f.(args...)</code>, e.g. <code>sin.(x)</code> or <code>min.(x,y)</code>, for elementwise operations over arrays or mixtures of arrays and scalars (a <a href="manual/@ref">Broadcasting</a> operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. <code>sin.(cos.(x))</code>.</p><p>Also, <em>every</em> binary operator supports a <a href="mathematical-operations.html#man-dot-operators-1">dot version</a> that can be applied to arrays (and combinations of arrays and scalars) in such <a href="functions.html#man-vectorized-1">fused broadcasting operations</a>, e.g. <code>z .== sin.(x .* y)</code>.</p><p>Note that comparisons such as <code>==</code> operate on whole arrays, giving a single boolean answer. Use dot operators like <code>.==</code> for elementwise comparisons. (For comparison operations like <code>&lt;</code>, <em>only</em> the elementwise <code>.&lt;</code> version is applicable to arrays.)</p><p>Also notice the difference between <code>max.(a,b)</code>, which <a href="../base/arrays.html#Base.Broadcast.broadcast"><code>broadcast</code></a>s <a href="../base/math.html#Base.max"><code>max</code></a> elementwise over <code>a</code> and <code>b</code>, and <a href="../base/collections.html#Base.maximum"><code>maximum(a)</code></a>, which finds the largest value within <code>a</code>. The same relationship holds for <code>min.(a,b)</code> and <code>minimum(a)</code>.</p><p>`<a href="## Broadcasting"></a></p><h2><a class="nav-anchor" id="ブロードキャスト-1" href="#ブロードキャスト-1">ブロードキャスト</a></h2><p>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</p><pre><code class="language-julia-repl">julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repeat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</code></pre><p>This is wasteful when dimensions get large, so Julia offers <a href="../base/arrays.html#Base.Broadcast.broadcast"><code>broadcast</code></a>, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</p><pre><code class="language-julia-repl">julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</code></pre><p><a href="mathematical-operations.html#man-dot-operators-1">Dotted operators</a> such as <code>.+</code> and <code>.*</code> are equivalent to <code>broadcast</code> calls (except that they fuse, as described below). There is also a <a href="../base/arrays.html#Base.Broadcast.broadcast!"><code>broadcast!</code></a> function to specify an explicit destination (which can also be accessed in a fusing fashion by <code>.=</code> assignment). Moreover, <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, providing a convenient syntax to broadcast any function (<a href="functions.html#man-vectorized-1">dot syntax</a>). Nested &quot;dot calls&quot; <code>f.(...)</code> (including calls to <code>.+</code> etcetera) <a href="mathematical-operations.html#man-dot-operators-1">automatically fuse</a> into a single <code>broadcast</code> call.</p><p>Additionally, <a href="../base/arrays.html#Base.Broadcast.broadcast"><code>broadcast</code></a> is not limited to arrays (see the function documentation), it also handles tuples and treats any argument that is not an array, tuple or <a href="../base/c.html#Core.Ref"><code>Ref</code></a> (except for <a href="../base/c.html#Core.Ptr"><code>Ptr</code></a>) as a &quot;scalar&quot;.</p><pre><code class="language-julia-repl">julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, &quot;. &quot;, [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])
3-element Array{String,1}:
 &quot;1. First&quot;
 &quot;2. Second&quot;
 &quot;3. Third&quot;</code></pre><p>`<a href="## Implementation"></a></p><h2><a class="nav-anchor" id="実装-1" href="#実装-1">実装</a></h2><p>The base array type in Julia is the abstract type <a href="../base/arrays.html#Core.AbstractArray"><code>AbstractArray{T,N}</code></a>. It is parametrized by the number of dimensions <code>N</code> and the element type <code>T</code>. <a href="../base/arrays.html#Base.AbstractVector"><code>AbstractVector</code></a> and <a href="../base/arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> are aliases for the 1-d and 2-d cases. Operations on <code>AbstractArray</code> objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</p><p>The <code>AbstractArray</code> type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete <code>AbstractArray{T,N}</code> type should generally implement at least <a href="../base/arrays.html#Base.size"><code>size(A)</code></a> (returning an <code>Int</code> tuple), <a href="../base/collections.html#Base.getindex"><code>getindex(A,i)</code></a> and <a href="../base/collections.html#Base.getindex"><code>getindex(A,i1,...,iN)</code></a>; mutable arrays should also implement <a href="../base/collections.html#Base.setindex!"><code>setindex!</code></a>. It is recommended that these operations have nearly constant time complexity, or technically Õ(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a <a href="../base/arrays.html#Base.similar"><code>similar(A,T=eltype(A),dims=size(A))</code></a> method, which is used to allocate a similar array for <a href="../base/base.html#Base.copy"><code>copy</code></a> and other out-of-place operations. No matter how an <code>AbstractArray{T,N}</code> is represented internally, <code>T</code> is the type of object returned by <em>integer</em> indexing (<code>A[1, ..., 1]</code>, when <code>A</code> is not empty) and <code>N</code> should be the length of the tuple returned by <a href="../base/arrays.html#Base.size"><code>size</code></a>. For more details on defining custom <code>AbstractArray</code> implementations, see the <a href="interfaces.html#man-interface-array-1">array interface guide in the interfaces chapter</a>.</p><p><code>DenseArray</code> is an abstract subtype of <code>AbstractArray</code> intended to include all arrays where elements are stored contiguously in column-major order (see additional notes in <a href="performance-tips.html#man-performance-tips-1">Performance Tips</a>). The <a href="../base/arrays.html#Core.Array"><code>Array</code></a> type is a specific instance of <code>DenseArray</code>  <a href="../base/arrays.html#Base.Vector"><code>Vector</code></a> and <a href="../base/arrays.html#Base.Matrix"><code>Matrix</code></a> are aliases for the 1-d and 2-d cases. Very few operations are implemented specifically for <code>Array</code> beyond those that are required for all <code>AbstractArrays</code>s; much of the array library is implemented in a generic manner that allows all custom arrays to behave similarly.</p><p><code>SubArray</code> is a specialization of <code>AbstractArray</code> that performs indexing by sharing memory with the original array rather than by copying it. A <code>SubArray</code> is created with the <a href="../base/arrays.html#Base.view"><code>view</code></a> function, which is called the same way as <a href="../base/collections.html#Base.getindex"><code>getindex</code></a> (with an array and a series of index arguments). The result of <a href="../base/arrays.html#Base.view"><code>view</code></a> looks the same as the result of <a href="../base/collections.html#Base.getindex"><code>getindex</code></a>, except the data is left in place. <a href="../base/arrays.html#Base.view"><code>view</code></a> stores the input index vectors in a <code>SubArray</code> object, which can later be used to index the original array indirectly.  By putting the <a href="../base/arrays.html#Base.@views"><code>@views</code></a> macro in front of an expression or block of code, any <code>array[...]</code> slice in that expression will be converted to create a <code>SubArray</code> view instead.</p><p><a href="../base/arrays.html#Base.BitArray"><code>BitArray</code></a>s are space-efficient &quot;packed&quot; boolean arrays, which store one bit per boolean value. They can be used similarly to <code>Array{Bool}</code> arrays (which store one byte per boolean value), and can be converted to/from the latter via <code>Array(bitarray)</code> and <code>BitArray(array)</code>, respectively.</p><p>A &quot;strided&quot; array is stored in memory with elements laid out in regular offsets such that an instance with a supported <code>isbits</code> element type can be passed to external C and Fortran functions that expect this memory layout. Strided arrays must define a <a href="../base/arrays.html#Base.strides"><code>strides(A)</code></a> method that returns a tuple of &quot;strides&quot; for each dimension; a provided <a href="../base/arrays.html#Base.stride"><code>stride(A,k)</code></a> method accesses the <code>k</code>th element within this tuple. Increasing the index of dimension <code>k</code> by <code>1</code> should increase the index <code>i</code> of <a href="../base/collections.html#Base.getindex"><code>getindex(A,i)</code></a> by <a href="../base/arrays.html#Base.stride"><code>stride(A,k)</code></a>. If a pointer conversion method <a href="../base/c.html#Base.unsafe_convert"><code>Base.unsafe_convert(Ptr{T}, A)</code></a> is provided, the memory layout must correspond in the same way to these strides. <code>DenseArray</code> is a very specific example of a strided array where the elements are arranged contiguously, thus it provides its subtypes with the approporiate definition of <code>strides</code>. More concrete examples can be found within the <a href="interfaces.html#man-interface-strided-arrays-1">interface guide for strided arrays</a>. <a href="../base/arrays.html#Base.StridedVector"><code>StridedVector</code></a> and <a href="../base/arrays.html#Base.StridedMatrix"><code>StridedMatrix</code></a> are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</p><p>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</p><pre><code class="language-julia-repl">julia&gt; a = rand(10, 10)
10×10 Array{Float64,2}:
 0.517515  0.0348206  0.749042   0.0979679  …  0.75984     0.950481   0.579513
 0.901092  0.873479   0.134533   0.0697848     0.0586695   0.193254   0.726898
 0.976808  0.0901881  0.208332   0.920358      0.288535    0.705941   0.337137
 0.657127  0.0317896  0.772837   0.534457      0.0966037   0.700694   0.675999
 0.471777  0.144969   0.0718405  0.0827916     0.527233    0.173132   0.694304
 0.160872  0.455168   0.489254   0.827851   …  0.62226     0.0995456  0.946522
 0.291857  0.769492   0.68043    0.629461      0.727558    0.910796   0.834837
 0.775774  0.700731   0.700177   0.0126213     0.00822304  0.327502   0.955181
 0.9715    0.64354    0.848441   0.241474      0.591611    0.792573   0.194357
 0.646596  0.575456   0.0995212  0.038517      0.709233    0.477657   0.0507231

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 view(::Array{Float64,2}, 2:2:8, 2:2:4) with eltype Float64:
 0.873479   0.0697848
 0.0317896  0.534457
 0.455168   0.827851
 0.700731   0.0126213

julia&gt; (q, r) = qr(b);

julia&gt; q
4×4 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.722358    0.227524  -0.247784    -0.604181
 -0.0262896  -0.575919  -0.804227     0.144377
 -0.376419   -0.75072    0.540177    -0.0541979
 -0.579497    0.230151  -0.00552346   0.781782

julia&gt; r
2×2 Array{Float64,2}:
 -1.20921  -0.383393
  0.0      -0.910506</code></pre><footer><hr/><a class="previous" href="metaprogramming.html"><span class="direction">Previous</span><span class="title">Metaprogramming</span></a><a class="next" href="missing.html"><span class="direction">Next</span><span class="title">Missing Values</span></a></footer></article></body></html>
